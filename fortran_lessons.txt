
             `Fortran 90' Lessons for Computational Chemistry
             ------------------------------------------------

             Curro Pérez-Bernal <francisco.perez@dfaie.uhu.es>

                                    0.0


-------------------------------------------------------------------------------


Abstract
--------

     The present document is a basic introduction to the `Fortran'
     programming language based in several textbooks and references (see
     Chapter 13, `Referencias').  It contains the basic scheme of `Fortran'
     programming taught in the _Computational Chemistry_ module (fourth
     year, second semester) of the University of Huelva Chemistry Degree.


-------------------------------------------------------------------------------


Contents
--------

     1.        Introduction
     1.1.      Objectives
     1.2.      Main items.
     1.3.      Example Codes.

     2.        Basic Operations
     2.1.      Objectives
     2.2.      Main items.
     2.3.      Example Codes.

     3.        Introduction to `Fortran' Arrays
     3.1.      Objectivos
     3.2.      Main items.
     3.3.      Example Codes.

     4.        More on Arrays
     4.1.      Objectives
     4.2.      Main items.
     4.3.      Example Codes.

     5.        Control Structures
     5.1.      Objectives
     5.2.      Main items.
     5.3.      Example codes.

     6.        `INPUT/OUTPUT' (I)
     6.1.      Objectivos
     6.2.      Main Items.
     6.3.      Example Codes

     7.        `Input/Output' (II)
     7.1.      Objectives
     7.2.      Main items.
     7.3.      Example Codes

     8.        Subprograms (I): FUNCTIONS
     8.1.      Objectives
     8.2.      Main items.
     8.3.      Example Codes

     9.        Subprograms (II): subroutines
     9.1.      Objectives
     9.2.      Main items.
     9.3.      Example Codes

     10.       Subprograms (III): modules
     10.1.     Objectives
     10.2.     Main items.
     10.3.     Example codes.

     11.       Subprogramas (IV)
     11.1.     Objetivos
     11.2.     Puntos destacables.
     11.3.     Programas usados como ejemplo.

     12.       Instalación y uso de las bibliotecas `BLAS' y `LAPACK'
     12.1.     Objetivos
     12.2.     Puntos destacables.
     12.3.     Programas usados como ejemplo.

     13.       Referencias


-------------------------------------------------------------------------------


1. Introduction
---------------


1.1. Objectives
---------------

     The main aims of this session consist of:

     1.   giving a short introduction on programming and programming
          languages.

     2.   emphasize the importance of a clear understanding of the problem
          under study and the use of flow diagrams for achieving structured
          and clear source code.

     3.   a brief presentation of the main features of the `Fortran'
          programming language.

     4.   installation of the `GNU Fortran' compiler, `gfortran'.

     5.   Studying two simple codes.

     6.   Presenting possible sources of information for the interested
          student.


1.2. Main items.
----------------

     By default we will use the `emacs' text editor.  The first examples
     are the simple programs Section 1.3.1, ``excode_1_1.f90'' y Section
     1.3.2, ``excode_1_2.f90''.

     Using the examples the student should be aware of the main sections
     included in a program::

     1.   Head of the code with the statement `PROGRAM' <program_name>.

     2.   Variable definition.

     3.   Main program body, including `I/O' operations.

     4.   End of the program: `END PROGRAM' <program_name>.

     Things to take into account:

        * Importance of remarks and comments.  Include many comments in
          your code, trying to be as clear as possible.  `Fortran' remarks
          are introduced with the character `!'.  A correct indentation
          also improves the code readability.  The `emacs' text editor
          greatly helps in this task.

        * The importance of the `IMPLICIT NONE' statement.  Declare and
          initialize properly all variables as in example Section 1.3.2,
          ``excode_1_2.f90''.

        * Distinguish the `I/O' operations.


1.3. Example Codes.
-------------------

1.3.1. `excode_1_1.f90'
-----------------------

          PROGRAM ex_1_1
            !
            ! This program reads and displays a string.
            !
            IMPLICIT NONE
            CHARACTER(LEN=50) :: Name
            !
            PRINT *,' Write your name. Do not forget quoting it:'
            PRINT *,' (max 50 characters)'
            READ(*,*), Name
            PRINT *, Name
            !
          END PROGRAM ex_1_1

1.3.2. `excode_1_2.f90'
-----------------------

PROGRAM ex_1_2
  !
  ! This program reads three numbers and compute their sum and mean value
  !
  IMPLICIT NONE
  REAL :: N1, N2, N3, Average = 0.0, Total = 0.0
  INTEGER :: N = 3
  PRINT *,' Input three numbers (return, coma, or space separated).'
  PRINT *,' '
  READ *,N1,N2,N3
  Total =  N1 + N2 + N3
  Average = Total/N
  PRINT *,'Sum: ',Total
  PRINT *,'Mean value: ',Average
END PROGRAM ex_1_2


-------------------------------------------------------------------------------


2. Basic Operations
-------------------


2.1. Objectives
---------------

     The main aims of this session are:

     1.   introducing basic `Fortran' syntax rules and the characters
          allowed in source files.

     2.   Basic arithmetic operations and operator precedence rules.

     3.   The `PARAMETER' declaration.

     4.   Explain the different kinds of numerical variables and its use.


2.2. Main items.
----------------

     Basic syntax rules:

        * Maximum number of characters per line of code: 132.

        * Maximum length of a variable name string: 31.

        * '&' denotes that the statement continues in the next line.  It is
          added at the end of the broken line[1]

        * '!'  is the character that marks the rest of the line as a
          comment.

        * ';' is the character that separates several statements in the
          same line.

     Variable names can include the low hyphen ('`_'') and mix alphanumeric
     characters and digits, though variable names first character cannot be
     a number.

     `Fortran' character set:

          A-Z  Letters              0-9  Digits
          _    Underscore                Blank
          =    Equal                +    Plus
          -    Minus                *    Asterisk
          /    Slash or oblique     '    Apostrophe
          (    Left parenthesis     )    Right parenthesis
          ,    Comma                .    Period or decimal point
          :    Colon                ;    Semicolon
          !    Exclamation mark     ""    Quotation mark
          %    Percent              &   Ampersand
          <    Less than         >   Greater than

     Precedence of arithmetic operators:

        * Operators: {`+',`-',`*',`/',`**'}.

        * Precedence: (1) `**' (right to left); (2) `*',`/' (compiler
          dependent); (3) `+',`-' (compiler dependent).

        * Beware of floating point operations rounding, in particular when
          mixing different numeric variable types.  Minimizing rounding
          errors is at times a complex and subtle task.

          The compiler transform different type variables to a common type
          when performing a calculation.  The priority ordering, from lower
          to higher is: `INTEGER', `REAL', `DOUBLE PRECISION', and
          `COMPLEX'.  Therefore, an operation involving an integer and a
          double precision float is performed transforming the integer
          value to double precision and the result is given in double
          precision too.  The final result is the transformed to the type
          of the variable to which is assigned.

        * Integer types:

          1.   32 bits ::`(2**31)-1 = 2,147,483,647' (~ 10**9)

          2.   64 bits :: `(2**63)-1 = 9,223,372,036,854,774,807' (~
               10**19)

        * Floats types and precision:

          1.   Real 32 bits :: precision = 6-9 `~ 0.3E­38 - 1.7E38'

          2.   Real 64 bits :: precision = 15-18 `~ 0.5E­308 - 0.8E308'

        * Making use of the `PARAMETER' modifier in a variable definition
          we can define constant values in a program.  See Section 2.3.4,
          ``excode_2_4.f90''.

        * (*) Different kinds of floats and integers in `Fortran' and the
          intrinsic functions[2] `KIND', `EPSILON', `PRECISION', and `HUGE'
          and how to define a variable in each of the existing types.

          `INTEGER' VARIABLES: if we would like to define an integer
          variable `i0' that could take values between -999999 y 999999 we
          should define a variable, called e.g.  `ki', making use of the
          intrinsic function `SELECTED_INT_KIND()' and make use of it in
          the variable definition.

               INTEGER, PARAMETER :: ki =  SELECTED_INT_KIND(6)
               INTEGER(KIND=ki) :: i0

          The intrinsic function[3] `SELECTED_INT_KIND(X)' output is an
          integer that indicates the type (_kind_) of an integer variable
          capable of storing any integer in the range `(-10E+X, 10E+X)'
          where `X' is also an integer.  If we want that any integer
          constant in our program to be treated with a particular type of
          integer this can be done as follows:

               -1234_ki
               2354_ki
               2_ki

          The error output of the `SELECTED_INT_KIND(X)' function is `-1'.

          Real numbers are more involved.  We make use a _floating point
          representation_, and all the following are valid real numbers in
          `Fortran':

               -10.66E-20
               0.66E10
               1.
               -0.4
               1.32D-44
               2E-12
               3.141592653

          In this case the statement to control the type of float is
          `SELECTED_REAL_KIND(p=X,r=Y)', with two input parameters.  The
          output is an integer associated with a float that complies with
          the following rules:

             * it has a precision at least equal to `X' and a range of
               decimal exponents given at least by `Y'.  The argument
               labels are optional.

             * Among various possible results, the one with the minimum
               decimal precision will be chosen.

             * At least one of the two input parameter should be specified.
               Both `X' and `Y' are integers.  If there is no variable type
               that fulfills the requested condiotions the output of the
               function will be `-1' if the precision does not reach the
               requested level, `-2' if the problem is in the exponent, and
               `-3' if both requirements cannot be satisfied.

          As an example, if we want to define a real variable called `a0'
          with 15 digit precision and exponents in the range -306 to 307:

               INTEGER, PARAMETER :: kr =  SELECTED_REAL_KIND(15,307)
               REAL(KIND=kr) :: a0

          Scalar floats can be addressed defining its particular kind as
          follows

               -10.66E-20_kr
               0.66E10_kr
               142857._kr
               -0.4_kr
               2E-12_kr
               3.141592653_kr

          Program Section 2.3.5, ``excode_2_5.f90'' contains several
          examples of the use of the `KIND' statement and the default value
          of `KIND' for several variable types.

          Program Section 2.3.6, ``excode_2_6.f90'' contains examples of
          the different types of viariales, how to define them, and how to
          test them using the intrinsics `KIND', `DIGITS', `EPSILON',
          `TINY', `HUGE', `EXPONENT', `MAXEXPONENT', `MINEXPONENT',
          `PRECISION' , `RADIX' y `RANGE'.

          In this program variables are defined using the functions
          `SELECTED_INT_KIND' and `SELECTED_REAL_KIND' This is correct
          though it is more appropriate to define the variables according
          to the process in the notes.

          The used functions are

          1.   `KIND(x)': integer output, type of the variable `x'.

          2.   `DIGITS(x)': integer output, number of significant digits of
               `x'.

          3.   `EPSILON(x)': if the input `x' is a float the output is
               another float, of the same type (_kind_) than `x'.  It is
               the smallest number of this type such that `1.0 + EPSILON(X)
               > 1'.

          4.   `TINY(x)': for float `x' input the output is of the same
               kind than `x', and it is the minimum positive value that can
               be defined for such variables.

          5.   `HUGE(x)': for float `x' input the output is of the same
               kind than `x', and it is the maximum positive value that can
               be defined for such variables.

          6.   `EXPONENT(x)': `x' variable exponent.  If `x = 0' then
               `EXPONENT(x)=0' too.

          7.   `MAXEXPONENT(x)': maximum exponent possible for `x' type
               variables.

          8.   `MINEXPONENT(x)': minimum exponent possible for `x' type
               variables.

          9.   `PRECISION(x)': if `x' is real or complex the output is an
               integer equal to the number of digits of precision of the
               variable `x'.

          10.  `RADIX(x)': integer result equal to the radix basis of `x'.

          11.  `RANGE(x)': integer result equal to the range of exponent
               for the variable `x'.

        * (*) Present how float arithmetic involves precision loss and how
          an appropriate use of the diferent data types can help to
          minimize this problem.

[1]  Except if a string is broken in two lines.  In this particular case it
     is added at the end of the broken line and the beginning of the next
     line.

[2]  See Section 2.3.4, ``excode_2_4.f90''.

[3]  More info on intrinsic functions and function definition in `Fortran'
     can be found in Section 8.1, `Objectives'.


2.3. Example Codes.
-------------------

2.3.1. `excode_2_1.f90'
-----------------------

              PROGRAM ex_2_1
            IMPLICIT NONE
            !
            ! Program computing the energy of a vibrational normal mode
            !
            !  Ge(v) = we (v+1/2) - wexe (v+1/2)^2
            !
            !
            ! Definicion de variables
            REAL            :: energ_0, energ, delta_e ! deltae = energ-energ0
            REAL            :: we = 250.0, wexe = 0.25 ! Units: cm-1
            INTEGER         :: v = 0
            CHARACTER*60    :: for_mol
            ! I/O
            PRINT *,'Formula de la molecula : '
            READ *, for_mol
            PRINT *,'Num. de quanta de excitacion : '
            READ *, v
            ! Calculations
            energ = we*(v+0.5) - wexe*(v+0.5)**2
            energ_0 = we*(0.5) - wexe*(0.5)**2
            delta_e = energ - energ_0
            ! I/O
            PRINT *
            PRINT *,'Especie molecular: ', for_mol
            PRINT *,'num. de quanta: ', v
            PRINT *,'energ = ',energ,'cm-1'
            PRINT *,'energ_0 = ',energ_0,'cm-1'
            PRINT *,'energ - energ_0 = ',delta_e,'cm-1'
          END PROGRAM ex_2_1

2.3.2. `excode_2_2.f90'
-----------------------

          PROGRAM ex_2_2
            IMPLICIT NONE
            REAL :: A,B,C
            INTEGER :: I
            A = 1.5
            B = 2.0
            C = A / B
            I = A / B
            PRINT *
            PRINT *, 'Case (1), Float variable'
            PRINT *,A,'/',B,' = ',C
            PRINT *, 'Case (2), Integer variable'
            PRINT *,A,'/',B,' = ',I
          END PROGRAM ex_2_2

2.3.3. `excode_2_3.f90'
-----------------------

          PROGRAM ex_2_3
            IMPLICIT NONE
            INTEGER :: I,J,K
            REAL :: Answer
            I = 5
            J = 2
            K = 4
            Answer = I / J * K
            PRINT *,'I = ',I
            PRINT *,'J = ',J
            PRINT *,'K = ',K
            PRINT *,'I / J * K = ',Answer
          END PROGRAM ex_2_3

2.3.4. `excode_2_4.f90'
-----------------------

PROGRAM ex_2_4
  ! Program to compute the time that takes to light to travel
  ! a given distance in AU.
  ! 1 AU = 1,50E11 m
  !
  !Definicion de variables
  IMPLICIT NONE
  ! a_u : astronomic unit in km
  REAL , PARAMETER :: a_u=1.50*10.0**8
  ! y_l : year light --> distance travelled by light during a year
  REAL , PARAMETER :: y_l=9.46*10.0**12
  ! m_l : minute light --> distance travelled by light during a minute
  REAL :: m_l
  ! dist : distance travelled in AUs (INPUT)
  REAL :: dist
  ! t_min : time in minutes needed to travel the distance dist
  REAL :: t_min
  !
  ! min : integer part of t_min
  ! seg : seconds from the decimal digits of t_min
  INTEGER :: min, seg
  !
  m_l = y_l/(365.25 * 24.0 * 60.0) ! m_l Calculation
  !
  PRINT *
  PRINT *,'Distance in AUs'
  READ *, dist
  PRINT *
  !
  t_min = (dist*a_u)/m_l
  min = t_min; seg = (t_min - min) * 60
  !
  PRINT *,' It takes light ' , min,' minutes and ', seg,' seconds'
  Print *,' to travel a distance of ',dist,' AU.'
END PROGRAM ex_2_4

2.3.5. `excode_2_5.f90'
-----------------------

          PROGRAM ex_2_5
            INTEGER :: i
            REAL :: r
            CHARACTER(LEN=1) :: c
            LOGICAL :: l
            COMPLEX :: cp
            PRINT *,' Integer ',KIND(i)
            PRINT *,' Real    ',KIND(r)
            PRINT *,' Char    ',KIND(c)
            PRINT *,' Logical ',KIND(l)
            PRINT *,' Complex ',KIND(cp)
          END PROGRAM ex_2_5

2.3.6. `excode_2_6.f90'
-----------------------

PROGRAM ex_2_6
  ! From Program ch0806 of Chivers & Sleightholme
  !
  ! Examples of the use of the kind
  ! function and the numeric inquiry functions
  !
  ! Integer arithmetic
  !
  ! 32 bits is a common word size,
  ! and this leads quite cleanly
  ! to the following
  ! 8 bit integers
  ! -128 to 127 10**2
  ! 16 bit integers
  ! -32768 to 32767 10**4
  ! 32 bit integers
  ! -2147483648 to 2147483647 10**9
  !
  ! 64 bit integers are increasingly available.
  ! This leads to
  ! -9223372036854775808 to
  !  9223372036854775807 10**19
  !
  ! You may need to comment out some of the following
  ! depending on the hardware platform and compiler
  ! that you use.
  INTEGER                         :: I
  INTEGER ( SELECTED_INT_KIND( 2)) :: I1
  INTEGER ( SELECTED_INT_KIND( 4)) :: I2
  INTEGER ( SELECTED_INT_KIND( 8)) :: I3
  INTEGER ( SELECTED_INT_KIND(16)) :: I4
  ! Real arithmetic
  !
  ! 32 and 64 bit reals are normally available.
  !
  ! 32 bit reals 8 bit exponent, 24 bit mantissa
  !
  ! 64 bit reals 11 bit exponent 53 bit mantissa
  !
  REAL :: R = 1.0
  REAL ( SELECTED_REAL_KIND( 6, 37)) :: R1 = 1.0
  REAL ( SELECTED_REAL_KIND(15,307)) :: R2 = 1.0
  REAL ( SELECTED_REAL_KIND(18,310)) :: R3 = 1.0
  PRINT *,' '
  PRINT *,' Integer values'
  PRINT *,'         Kind       Huge'
  PRINT *,' '
  PRINT *,KIND(I ),' ',HUGE(I    )
  PRINT *,' '
  PRINT *,KIND(I1 ),' ',HUGE(I1  )
  PRINT *,KIND(I2 ),' ',HUGE(I2  )
  PRINT *,KIND(I3 ),' ',HUGE(I3  )
  PRINT *,KIND(I4 ),' ',HUGE(I4  )
  PRINT *,' '
  PRINT *,' ----------------------------------- '
  PRINT *,' '
  PRINT *,' Real values'
  !
  PRINT *,'         Kind     ', KIND(R ), '    Digits     ', DIGITS(R )
  PRINT *,'  Huge    = ',HUGE(R ), ' Tiny =', TINY(R)
  PRINT *,'  Epsilon = ',EPSILON(R),' Precision = ', PRECISION(R)
  PRINT *,'  Exponent = ',EXPONENT(R), 'MAXExponent = ', MAXEXPONENT(R), '  MINExponent = ',MINEXPONENT(R)
  PRINT *,'  Radix    = ', RADIX(R ), ' Range =', RANGE(R)
  PRINT *,' '
  !
  !
  PRINT *,'         Kind     ', KIND(R1 ), '    Digits     ', DIGITS(R1 )
  PRINT *,'  Huge    = ',HUGE(R1 ), ' Tiny =', TINY(R1)
  PRINT *,'  Epsilon = ',EPSILON(R1),' Precision = ', PRECISION(R1)
  PRINT *,'  Exponent = ',EXPONENT(R1), 'MAXExponent = ', MAXEXPONENT(R1), '  MINExponent = ',MINEXPONENT(R1)
  PRINT *,'  Radix    = ', RADIX(R1 ), ' Range =', RANGE(R1)
  PRINT *,' '
  !
  !
  PRINT *,'         Kind     ', KIND(R2 ), '    Digits     ', DIGITS(R2 )
  PRINT *,'  Huge    = ',HUGE(R2 ), ' Tiny =', TINY(R2)
  PRINT *,'  Epsilon = ',EPSILON(R2),' Precision = ', PRECISION(R2)
  PRINT *,'  Exponent = ',EXPONENT(R2), 'MAXExponent = ', MAXEXPONENT(R2), '  MINExponent = ',MINEXPONENT(R2)
  PRINT *,'  Radix    = ', RADIX(R2 ), ' Range =', RANGE(R2)
  PRINT *,' '
  !
  !
  PRINT *,'         Kind     ', KIND(R3 ), '    Digits     ', DIGITS(R3 )
  PRINT *,'  Huge    = ',HUGE(R3 ), ' Tiny =', TINY(R3)
  PRINT *,'  Epsilon = ',EPSILON(R3),' Precision = ', PRECISION(R3)
  PRINT *,'  Exponent = ',EXPONENT(R3), 'MAXExponent = ', MAXEXPONENT(R3), '  MINExponent = ',MINEXPONENT(R3)
  PRINT *,'  Radix    = ', RADIX(R3 ), ' Range =', RANGE(R3)
  PRINT *,' '
  !
END PROGRAM ex_2_6


-------------------------------------------------------------------------------


3. Introduction to `Fortran' Arrays
-----------------------------------


3.1. Objectivos
---------------

     The main aims of this session are the following

     1.   present one dimension arrays as `Fortran' data structures.

     2.   present the different ways of defining an array.

     3.   present the `DO' loop syntax and the implicit `DO' and their use
          with matrices.

     4.   explore dynamic arrays in `Fortran 90'

     5.   present multidimensional arrays as `Fortran' data structures.


3.2. Main items.
----------------

     Basic Definitions:

     1.   _rank_: number of indices necessary to indicate unambiguously an
          array element.

     2.   _bounds_: max and min values of the indices labelling array
          elements in each dimension.

     3.   _extent_: number of elements in an array dimension.

     4.   _size_: total number of a matrix.

     5.   _conformal_: two arrays are conformal if both have the same rank
          and extent.

     The following points should be emphasized:

        * one dimensional array (vector) definition making use of the `DO'
          control structure (see Section 3.3.1, ``excode_3_1.f90'' and
          exercise 2_1)

        * use of the `PARAMETER' declaration for the definition of array
          bounds in static array declaration.

        * initialize before use.  Beware of surprises.  The initialization
          to a common constant value is extremely simple: `vec = <valor>'.
          A possible alternative is the use of _array constructors_.  In
          the following example, in order to define an integer array with
          six elements called `vec_int' three possible and equivalent
          options are given

               do i = 0, 5
                  vec_int(i) = 2*i
               enddo
               
               vec_int = (/(2*i, i = 0, 5)/)
               
               vec_int = (/0,2,4,6,8,10/)

          Last two options involve _array constructors_ and can be carried
          out when the array is declared[1]

        * use of the `ALLOCATABLE' declaration and the use of the
          `ALLOCATE' function, as it is shown in example Section 3.3.2,
          ``excode_3_2.f90''.  The `ALLOCATE' option `STAT = <var>' allows
          to chek if the array has been properly defined.  See example in
          program Section 9.3.3, ``excode_9_3.f90''.

        * implicit `DO' and multidimensional arrays.  See example Section
          3.3.3, ``excode_3_3.f90''.

        * most general form of the `DO' control structure and possibility
          of introducing zero or negative array indeces.  See example
          Section 3.3.4, ``excode_3_4.f90''.

        * combination of `bash' redirectioning with `Fortran' programs.
          Necessary for exercise 2, it is explained in Chapter 4, `More on
          Arrays'.

[1]  Beware of this feature in functions and subroutines.


3.3. Example Codes.
-------------------

3.3.1. `excode_3_1.f90'
-----------------------

          PROGRAM ex_3_1
          !
          ! VARIABLES DEFINITION
            IMPLICIT NONE
            REAL :: Total=0.0, Average=0.0
            INTEGER, PARAMETER :: Week=7
            REAL , DIMENSION(1:semana) :: Lab_Hours
            INTEGER :: Day
          !
            PRINT *,' Labor Time (hours per day during a week):'
            DO Day= 1, Week
               READ *, Lab_Hours(Day)
            ENDDO
          !
            DO Day = 1, Week
               Total = Total + Lab_Hours(Day)
            ENDDO
            Average = Total / Week
          !
            PRINT *,' Average Weekly Workload: '
            PRINT *, Average, ' hours'
          END PROGRAM ex_3_1

3.3.2. `excode_3_2.f90'
-----------------------

          PROGRAM ex_3_2
            !
            ! VARIABLE DEFINITION
            IMPLICIT NONE
            REAL :: Total=0.0, Average=0.0
            REAL , DIMENSION(:), ALLOCATABLE :: Lab_Hours
            INTEGER :: Day, Number_Days
            !
            PRINT *,' Number of workdays:'
            READ *, Number_Days
            !
            ALLOCATE(Lab_Hours(1:Number_Days))
            !
            PRINT *,' Daily hours of work in ', Number_Days, ' days.'
            DO Day = 1, Number_Days
               READ *, Lab_Hours(Day)
            ENDDO
            !
            DO Day=1, Number_Days
               Total = Total + Lab_Hours(Day)
            ENDDO
            Average = Total / Number_Days
          !
            PRINT *,' Average daily workhours in ',Number_Days, ' days : '
            PRINT *, Average, ' hours'
          !
          END PROGRAM ex_3_2

3.3.3. `excode_3_3.f90'
-----------------------

PROGRAM ATTEND_CONTROL
  IMPLICIT NONE
  INTEGER , PARAMETER :: N_students = 3
  INTEGER , PARAMETER :: N_courses = 3
  INTEGER , PARAMETER :: N_lab = 3
  INTEGER :: student, course, lab
  CHARACTER*2 , DIMENSION(1:N_lab,1:N_courses,1:N_lab) :: attend = 'NO'
  DO student = 1, N_students
     DO course = 1,N_courses
        READ *,(attend(lab,course,student),lab = 1, N_lab)
     ENDDO
  ENDDO
  PRINT *,' Lab attendance : '
  DO student=1, N_students
     PRINT *,' Student = ', student
     DO course = 1,N_courses
        PRINT *,'   Course = ', course, ' : ', (attend(lab,course,student),lab=1,N_lab)
     ENDDO
  ENDDO
END PROGRAM ATTEND_CONTROL

3.3.4. `excode_3_4.f90'
-----------------------

          PROGRAM ex_3_4
            IMPLICIT NONE
            REAL , DIMENSION(-180:180) :: Time=0
            INTEGER :: Degree, Strip
            REAL :: Value
          !
            DO Degree=-165,165,15
               Value=Degree/15
               DO Strip=-7,7
                  Time(Degree+Strip)=Value
               ENDDO
            ENDDO
          !
            DO Strip=0,7
               Time(-180 + Strip) = -180/15
               Time( 180 - Strip) = 180/15
            ENDDO
          !
            DO Degree=-180,180
               PRINT *,Degree,' ',Time(Degree), 12 + Time(Degree)
            END DO
          END PROGRAM ex_3_4


-------------------------------------------------------------------------------


4. More on Arrays
-----------------


4.1. Objectives
---------------

     The main aims of this lesson are the following:

     1.   presenting storage ordering of multidimensional arrays.

     2.   presenting how to manipulate whole matrices or arrays sections in
          `Fortran'.

     3.   matrix definition using the `WHERE' statement.


4.2. Main items.
----------------

        * Storage ordering

          Multidimensional arrays are stored in memory by `Fortran' in such
          a way that the first subindex varies faster than the second, that
          varies faster than the third and so on and so forth.  This is
          known as _column major order_.

          For example, if we define a `4 x 2' matrix as

          `REAL , DIMENSION(1:4,1:2) :: A',

          the `A' array has eight elements stored into memory as follows

               A(1,1), A(2,1), A(3,1), A(4,1), A(1,2), A(2,2), A(3,2), A(4,2)

          The `A' matrix initialization can be carried out in several ways.
          Assuming that each element should be initialized with a number
          equal to the index of the corresponding row, we could use two
          loops[1]

               DO I_col = 1, 2
                    DO I_row = 1, 4
                       A(I_row, I_col) = I_row
                    ENDDO
               ENDDO

          An _array constructor_ can also be of help, though the seemingly
          simple solution

               A = (/ 1, 2, 3, 4, 1, 2, 3, 4 /)

          does not work.  The _array constructors_ produce vectors and not
          matrices.  The vector defined above is of dimension 8, but not a
          matrix 4x2.  The vector and the array `A' have identical sizes,
          but are not conformal.  The statement `RESHAPE' gives a possible
          solution.  The sytax of this statement is

               <output_array> = RESHAPE(<array_1>, <array_2>)

          Where <array_1> is a matrix that would be reshaped and <array_2>
          is a vector with the dimensions of the new matrix <output_array>.
          The total number of elements of <array_1> and <output_array>
          needs to be identical.  In the previous example a correct _array
          constructor_ is

               A = RESHAPE( (/ 1, 2, 3, 4, 1, 2, 3, 4 /), (/ 4, 2 /) )

          Another example can be found in code Section 4.3.3,
          ``excode_4_3.f90''.  The `RESHAPE' command can be used in the
          array declaration

               INTEGER, DIMENSION(1:4,1:2) :: A = &
                      RESHAPE( (/ 1, 2, 3, 4, 1, 2, 3, 4 /), (/ 4, 2 /) )

          The data ordering in storage is specially important in I/O
          operations.  The command

               PRINT*, A

          will give as a result

               A(1,1), A(2,1), A(3,1), A(4,1), A(1,2), A(2,2), A(3,2), A(4,2)

          It is necessary to take this into account also when making use of
          the `READ' statement to fill with values the elements of a
          multidimensional array: `READ(<unit>,*) A'.  The _implicit_ `DO'
          statement allow to change the standard reading sequence

               READ(unit,*) ( ( A(row,col), col = 1, 2 ), row = 1, 4 )

        * `FORTRAN' allows to define multidimensional arrays, being seven
          is the max number of indices.  The code Section 4.3.2,
          ``excode_4_2.f90'' an array is fully characterized making use of
          several _inquiry_ type functions (see Section 8.3.2,
          ``excode_8_2.f90'').

        * The usage of whole matrices is a great advantage.  Definig
          floating point vectors `V1', `V2', `V3' y `V4' as

               REAL , DIMENSION(1:21) :: V1, V2
               REAL , DIMENSION(-10:10) :: V3
               REAL , DIMENSION(0:10) :: V4

          The following tasks are simply performed using this `Fortran 90'
          feature.

          1.   Assigning a particular value to the full array:

                    V1 = 0.5

          2.   Equating matrices:

                    V1 = V2

               Making each `V1' element equal to the corresponding element
               of `V2'.  This is only valid when both matrices are
               _conformal_.  It is also valid

                    V3 = V2

               but it is _not_ valid

                    V1 = V4

          3.   All arithmetic operation for scalars can be also applied to
               conformal matrices, though they may not be the expected
               mathematical operations.

                    V1 = V2 + V3
                    V1 = V2*V3

               In the first case `V1' is the sum of two vectors, but in the
               second case each `V1' element is the product of the
               corresponding `V2' and `V3' elements, which is not the
               scalar product.  In the two-dimensional matrices case, if we
               define

                    REAL , DIMENSION(1:4,1:4) :: A, B, C

               The following are valid statements in `Fortran 90'

                    A = A**0.5
                    C = A + B
                    C = A * B

               The last case is not the matrix product but a matrix having
               each element as the result of the product of the
               corresponding `A' annd `B' elements.

          4.   A matrix can also be read without a `DO' loop, as in example
               Section 4.3.1, ``excode_4_1.f90'', where also the intrinsic
               function `SUM' is presented.

        * The definition of array slices is possible using the index syntax
          `<liminf>:<limsup>:<step>'

               V1(1:10) = 0.5
               B(1,1:4) = 100.0

          In the first case the first ten elements of the `V1' array take
          the value `0.5', while in the second elements in the first row of
          `B' take the value `100.0'.  See example Section 4.3.1,
          ``excode_4_1.f90''.

          The most general syntax to define a slice is
          `<lowlimit>:<upplimit>:<step>', the first slice element has index
          <lowlimit>, the last one is less than or equal to <upplimit> and
          <step> is the index variable increment.  The default value of
          <step> is `<step>=1'.  Examples:

               V1(:)       ! the whole vector
               V1(3:10)    ! elements V1(3), V1(4), ... ,   V1(10)
               V1(3:10:1)  !   ""      ""     ""             ""
               V1(3:10:2)  !   ""     V1(3), V1(5), ... , V1(9)
               V1(m:n)     ! elements V1(m), V1(m+1), ... , V1(n)
               V1(9:4:-2)  !   ""     V1(9), V1(7), V1(5)
               V1(m:n:-k)  ! elements V1(m), V1(m-k), ... , V1(n)
               V1(::2)     !   ""     V1(1), V1(3), ... , V1(21)
               V1(m:m)     ! 1 x 1 array
               V1(m)       ! Scalar

        * The assignment of values to an array can be done making use of a
          _logic mask_, with the `WHERE' statement.  The use of the mask
          allows to select those array elements that should undergo the
          initialization.  If, e.g., we need to compute the square root of
          the elements of a floating point array called `data_mat' and
          store them in the array `sq_data_mat', we can skip the use of
          loops and conditionals as in the following code

DO j_col = 1, dim_2
   DO i_row = 1, dim_1
         IF ( data_mat(i_row, j_col) >= 0.0 ) THEN
              sq_data_mat(i_row, j_col) = SQRT( data_mat(i_row, j_col) )
         ELSE
              sq_data_mat(i_row, j_col) = -99999.0
         ENDIF
   ENDDO
ENDDO

          The `WHERE' statement greatly simplifies this task.  The
          statement syntax is

               [<name>:] WHERE (<mask_expr_1>)
                  ....
                  Array assignment block 1
                  ....
               ELSEWHERE (<mask_expr_2>) [<name>]
                  ....
                  Array assignment block 2
                  ....
               ELSEWHERE
                  ....
                  Array assignment block 3
                  ....
               ENDWHERE [<name>]

          where <mask_expr_1> and <mask_expr_2> are boolean arrays
          conformal with the array being assigned.  The previous example is
          therefore simplified to

               WHERE ( data_mat >= 0.0 )
                           sq_data_mat = SQRT( data_mat )
               ELSEWHERE
                           sq_data_mat = -99999.0
               ENDWHERE

        * These aspects are treated in the different given examples.
          Example Section 4.3.3, ``excode_4_3.f90'' shows how to initialize
          vectoras and matrices, in the last case making use of the
          `RESHAPE' statement.  The example also introduces the `Fortran'
          intrinsics `DOT_PRODUCT' (scalar product) and `MATMUL' (matrices
          product).

          Example Section 4.3.4, ``excode_4_4.f90'' exemplifies the use
          `WHERE' in combination with a logical mask.

          Example Section 4.3.5, ``excode_4_5.f90'' stress the fact the the
          elimination of `DO' loops can sometimes bring surprising results
          about.

          Example Section 4.3.6, ``excode_4_6.f90'' shows how to use the
          `RESHAPE' statement in the definition of a matrix and how to use
          slicing in the defined array.

[1]  The _column major order_ storage makes optimal to run over columns in
     the inner loop, specially when running with large matrices.


4.3. Example Codes.
-------------------

4.3.1. `excode_4_1.f90'
-----------------------

PROGRAM ex_4_1
  !
  ! VARIABLE DEFINITION
  IMPLICIT NONE
  REAL :: Total=0.0, Average=0.0
  REAL , DIMENSION(:), ALLOCATABLE :: t_worked
  ! Correction Factor
  REAL :: correction =1.05
  INTEGER :: day, num_days
  !
  PRINT *,' Number of workdays: '
  READ *, num_days
  ! Dynamic storage definition
  ALLOCATE(t_worked(1:num_days))
  !
  PRINT *,' Worked hours per day in ', num_days, ' days.'
  ! I/O
  READ *, t_worked
  !
  t_worked(num_days-1:num_days) = correction*t_worked(num_days-1:num_days)
  !
  DO day=1,num_days
     Total = Total + t_worked(day)
  ENDDO
  Average = Total / num_days
  !
  PRINT *,' Average daily hours of work in ',num_days, ' days : '
  PRINT *, Average
  !
END PROGRAM ex_4_1

4.3.2. `excode_4_2.f90'
-----------------------

          PROGRAM ex_4_2
            !
            ! Program to characterize an array making use of inquiry functions
            !
            IMPLICIT NONE
            !
            REAL, DIMENSION(:,:), ALLOCATABLE :: X_grid
            INTEGER :: Ierr
            !
            !
            ALLOCATE(X_grid(-20:20,0:50), STAT = Ierr)
            IF (Ierr /= 0) THEN
               STOP 'X_grid allocation failed'
            ENDIF
            !
            WRITE(*, 100) SHAPE(X_grid)
          100 FORMAT(1X, "Shape :        ", 7I7)
            !
            WRITE(*, 110) SIZE(X_grid)
          110 FORMAT(1X, "Size :         ", I7)
            !
            WRITE(*, 120) LBOUND(X_grid)
          120 FORMAT(1X, "Lower bounds : ", 7I6)
            !
            WRITE(*, 130) UBOUND(X_grid)
          130 FORMAT(1X, "Upper bounds : ", 7I6)
            !
            DEALLOCATE(X_grid, STAT = Ierr)
            IF (Ierr /= 0) THEN
               STOP 'X_grid deallocation failed'
            ENDIF
            !
          END PROGRAM EX_4_2

4.3.3. `excode_4_3.f90'
-----------------------

          PROGRAM ex_4_3
            !
            ! VARIABLES DEFINITION
            IMPLICIT NONE
            REAL, DIMENSION(1:5) :: VA = (/1.0,1.0,1.0,1.0,1.0/), PMAT
            INTEGER I
            INTEGER, DIMENSION(1:5) :: VB = (/(2*I,I=1,5)/)
            REAL :: PE
            REAL , DIMENSION(1:5,1:5) :: MC
            REAL , DIMENSION(25) :: VC = &
                 (/ 0.0,0.0,0.0,0.0,1.0,0.5,2.0,3.2,0.0,0.0, &
                    0.0,0.0,0.0,0.0,11.0,0.5,2.3,3.2,0.0,0.0, &
                    1.0,3.0,-2.0,-2.0,-0.6 /)
            ! Scalar Product
            PE = DOT_PRODUCT(VA,VB)
            !
            PRINT *, 'Scalar Product (VA,VB) = ', PE
            !
            ! Product of matrices VAxMC
            ! RESHAPE VC to make it a  5 x 5 matrix
            MC = RESHAPE(VC,(/5,5/))
            PMAT = MATMUL(VA,MC)
            !
            PRINT *, ' VA x MC = ', PMAT(1:5)
            !
          END PROGRAM ex_4_3

4.3.4. `excode_4_4.f90'
-----------------------

          PROGRAM ex_4_4
            IMPLICIT NONE
            REAL , DIMENSION(-180:180) :: Time=0
            INTEGER :: Degree, Strip
            REAL :: Value
            CHARACTER (LEN=1), DIMENSION(-180:180) :: LEW=' '
          !
            DO Degree=-165,165,15
               Value=Degree/15
               DO Strip=-7,7
                  Time(Degree+Strip)=Value
               ENDDO
            ENDDO
          !
            DO Strip=0,7
               Time(-180 + Strip) = -180/15
               Time( 180 - Strip) = 180/15
            ENDDO
          !
            DO Degree=-180,180
               PRINT *,Degree,' ',Time(Degree), 12 + Time(Degree)
            END DO
          !
            WHERE (Time > 0)
               LEW='E'
            ELSEWHERE (Time < 0)
               LEW='W'
            ENDWHERE
          !
            PRINT*, LEW
          !
          END PROGRAM ex_4_4

4.3.5. `excode_4_5.f90'
-----------------------

          PROGRAM ex_4_5
            !
            ! VARIABLE DEFINITION
            IMPLICIT NONE
            REAL, DIMENSION(1:7) :: VA = (/1.2,2.3,3.4,4.5,5.6,6.7,7.8/)
            REAL, DIMENSION(1:7) :: VA1 = 0.0, VA2 = 0.0
            INTEGER I
            !
            VA1 = VA
            VA2 = VA
            !
            DO I = 2, 7
               VA1(I) = VA1(I) + VA1(I-1)
            ENDDO
            !
            VA2(2:7) = VA2(2:7) + VA2(1:6)
            !
            ! Previous two operations with VA1 and VA2 seem that
            ! should provide the same result. Which is not the case.
            PRINT*, VA1
            PRINT*, VA2
            !
            ! To obtain the same effect without an explicit DO loop we can do
            ! the following
            VA2 = VA
            VA2(2:7) = (/ (SUM(VA2(1:I)), I = 2,7) /)
            !
            PRINT*, VA1
            PRINT*, VA2
          END PROGRAM ex_4_5

4.3.6. `excode_4_6.f90'
-----------------------

PROGRAM ex_4_6
  !
  ! DEFINITION OF VARIABLES
  IMPLICIT NONE
  INTEGER, DIMENSION(1:3,1:3) :: A = RESHAPE( (/ 1,2,3,4,5,6,7,8,9 /), (/ 3,3 /) )
  !
  !
  !      1  4  7
  !  A = 2  5  8
  !      3  6  9
  !
  PRINT*, "Matrix Element", A(2,3)
  PRINT*, "Submatrix", A(1:2,2:3)
  PRINT*, "Submatrix", A(::2,::2)
  PRINT*, "Matrix Column", A(:,3)
  PRINT*, "Matrix Row", A(2,:)
  PRINT*, "Full Matrix", A
  PRINT*, "Transposed Matrix", TRANSPOSE(A)
END PROGRAM ex_4_6


-------------------------------------------------------------------------------


5. Control Structures
---------------------


5.1. Objectives
---------------

     The main aims of this session consist of:

     1.   presenting the different conditional control structures in
          `Fortran' (_branching_).

     2.   presenting the different way of building loops in `Fortran' code.

     These structures allows the programmer to control the program flow,
     allowing the conditional execution of statements according to the user
     input values or the values acquired by variables during the program
     execution.

     It is extremely important to take into account before starting to
     write code in any programming language that a previous step should be
     accomplished.  In encompasses having a clear idea of the problem, the
     inputs and outputs, the program structure, breaking complex tasks into
     simpler subtasks, and the optimal algorithm.  A flow diagram can be of
     great help at this stage.

     The division of the problem into simpler and simpler tasks is called
     _top-down design_.  Each subtasks should be coded and checked in an
     independent manner.


5.2. Main items.
----------------

     We provide a scheme of the main control structures, strting with
     conditionals and later of loops.

        * Conditionals.

          Depend on the evaluation of boolean expressions for which the
          following operators are defined:

             * `==' To be equal to.

             * `/=' Not to be equal to.

             * `>' Greater than.

             * `<' Lesser than.

             * `>=' Greater or equal than.

             * `<=' Lesser or equal than.

          There exist also logical operators to combine several logical
          expressions:

             * `.AND.'

             * `.OR.'

             * `.NOT.'

             * `.EQV.'  (Boolean '==' operator)

             * `.NEQV.'  (Boolean '/=' operator)

          The `==' and `/=' shouldn't be used to compare real type
          variables, due to their nonexact nature.  If e.g.  `A' and `B'
          are real variables, the following code is discouraged

               ...
               IF (A==B) same = .TRUE.
               ...

          The alternative would be to define a tolerance and compare the
          variables as follows

               REAL :: TOL = 0.00001
               ...
               IF (ABS(A-B) < TOL) same = .TRUE.
               ...

          The possible conditional statements are

          1.   `IF THEN ENDIF'

               The syntax of this conditional statement is

                    .
                    . code
                    .
                    IF (<Boolean Expression>) THEN
                             .
                             . code_1
                             .
                    ENDIF
                    .
                    . code
                    .

               Only if the <Boolean Expression> is true the `code_1' block
               instructions are executed.

               If there is only one statement in the `code_1' block the
               command can be simplified to a one liner removing the `THEN'
               and `ENDIF' keywords as follows

                    .
                    . code
                    .
                    IF (<Boolean Expression>) statement
                    .
                    . code
                    .

          2.   `IF THEN ELSE ENDIF'

               The syntax of this conditional statement is

                    .
                    . code
                    .
                    IF (<Boolean Expression>) THEN
                             .
                             . code_1
                             .
                    ELSE
                             .
                             . code_2
                             .
                    ENDIF
                    .
                    . code
                    .

               If the <Boolean Expression> is true the `code_1' block
               instructions are executed, if it is false then `code_2'
               block is run.

          3.   `IF THEN ELSE IF ENDIF'

               The syntax of this conditional statement is

                    .
                    . code
                    .
                    IF (<Boolean Expression_1>) THEN
                             .
                             . code_1
                             .
                    ELSE IF (<Boolean Expression_2>) THEN
                             .
                             . code_2
                             .
                    ENDIF
                    .
                    . code
                    .

               In case that the <Boolean Expression_1> is true the `code_1'
               block instructions are executed, if it is false but <Boolean
               Expression_2> is true then `code_2' block is run.

          4.   `IF THEN ELSE IF ELSE ENDIF'

               The syntax of this conditional statement is

                    .
                    . code
                    .
                    IF (<Boolean Expression_1>) THEN
                             .
                             . code_1
                             .
                    ELSE IF (<Boolean Expression_2>) THEN
                             .
                             . code_2
                             .
                    ELSE
                             .
                             . code_3
                             .
                    ENDIF
                    .
                    . code
                    .

               In case that the <Boolean Expression_1> is true the `code_1'
               block instructions are executed, if it is false but <Boolean
               Expression_2> is true then `code_2' block is run.  If both
               are false then the `code_3' block is run.

          5.   `SELECT CASE'

               The `CASE' statement allows to choose among different
               options in a clear and efficient way, though it has some
               limitations.

               The syntax of this conditional statement is

                    SELECT CASE (selector)
                       CASE (label-1)
                          block-1
                       CASE (label-2)
                          block-2
                       CASE (label-3)
                          block-3
                         .............
                       CASE (label-n)
                          block-n
                       CASE DEFAULT
                          block-default
                    END SELECT

               The `selector' is either a variable or an expression of the
               _integer_, _logical_, or _character_ type.  It cannot be a
               real or complex number.

               The `label-1' ...  `label-n' labels have the following
               syntax

                    value
                    value_1 : value_2
                    value_1 :
                     : value_1

               The first one is positive if the selector is equal to
               `value' and the second if the selector takes a value in the
               range `value_1' to `value_2'.  The third(fourth) is true if
               the selector has a value larger(less) than `value_1'.  The
               `valor', `value_1', and `value_2' should be constants or
               variables defined with the `PARAMETER' declaration.

               The `selector' expression is evaluated first.  The result is
               compared with the values in each one of the labels, running
               the block of instructions of the first successful
               comparison.  If none of the labels is true the
               `block-default' is run if it exists.

               A simple example:

                    SELECT CASE (I)
                         CASE (1)
                           PRINT*, "I = 1"
                         CASE (2:9)
                           PRINT*, "I in [2,9]"
                         CASE (10:)
                           PRINT*, "I in [10,INF]"
                         CASE DEFAULT
                           PRINT*, "I is negative"
                    END SELECT CASE

               The `SELECT CASE' statement is more elegant than a series of
               `IF''s as only one expression controls the access to the
               different alternatives.

          Conditional control structures can be nested in several levels.
          For the sake of clarity in this case the different levels should
          be labeled as follows

               firstif: IF (a == 0) THEN
                           PRINT*,  "a is zero"
                           secondif: IF (c /= 0) THEN
                             PRINT*,  "a is zero and c is not zero"
                           ELSE secondif
                             PRINT*,  "a and c are zero"
                           ENDIF secondif
                         ELSEIF (a > 0) THEN firstif
                           PRINT*,  "a is positive"
                         ELSE firstif
                           PRINT*,  "a is negative"
                         ENDIF firstif

          The role of the lables `firstif' and `secondif' is to clarify the
          source code for the reader.  Once a label is included in the `IF'
          statement, then it has to be present also in the `ENDIF', while
          it is optional in the `ELSE' and `ELSEIF'.  The number of nested
          conditionals is unlimited.

          The example code Section 5.3.1, ``excode_5_1.f90'' contains the
          `IF THEN ELSE IF ELSE ENDIF' structure and, apparently, the same
          task is coped with in example Section 5.3.2, ``excode_5_2.f90''
          with the `CASE' structure.

        * Loops

          1.   Basic loop: The `DO' statement

               We have been already introduced to the basic `DO' loop:

                    DO Var = initial_value, final_value, increment
                           Block of Code
                    END DO

               The variable `Var' changes from `initial_value' to
               `final_value' adding `increment' each iteration.

          2.   The `DO WHILE' loop

               This loop has this structure:

                    DO WHILE (conditional)
                          Block of code
                    ENDDO

               In this case the block of code is run until the
               `conditional' in the head of the block is false.  E.g.  see
               example Section 5.3.4, `Programa ejemplo_5_4.f90'.

          3.   The `REPEAT UNTIL' loop

               This type of loop has the following structure:

                          DO
                             Block of code
                             #
                             IF (conditional) EXIT
                          END DO

               The loop is executed until the conditional is evaluated
               `True'.  This case differs from the previous two in that the
               code block is run at least once.

               In this case we make use of the `EXIT' statement.  When this
               statement is run into a loop the program leaves inmediately
               the loop and keeps running from the order following the
               corresponding `ENDDO'.  Another interesting statement when
               working with loops is `CYCLE'.  The execution of the `CYCLE'
               statement makes the program to return to the beginning of
               the loop, without running the statements in the loop block
               between the `CYCLE' statement and the end of the loop.

               As in the conditionals case, nested loops can be labeled.
               This greatly clarifies the source code and, in particular,
               allows to indicate to which loop level refers the statements
               `EXIT' and `CYCLE'.  By default, they address the inner
               loop.

               There is a last statement, worth to mention, the `GOTO'
               command, though its use is highly discouraged in the moder
               programming standards.


5.3. Example codes.
-------------------

5.3.1. `excode_5_1.f90'
-----------------------

PROGRAM ex_5_1
  !
  IMPLICIT NONE
  !
  REAL :: Grade
  CHARACTER(LEN = 2), DIMENSION(1:5) :: List_Grades=(/'D ','C ','B ','A ','A+'/)
  INTEGER :: IN
  ! READ NOTE
  PRINT *, "Student mark??"
  READ *, Grade
  !
  IF (Grade>=0.0.AND.Grade<5.0) THEN
     IN=1
  ELSE IF (Grade>=5.0.AND.Grade<7.0) THEN
     IN=2
  ELSE IF (Grade>=7.0.AND.Grade<9.0) THEN
     IN=3
  ELSE IF (Grade>=9.0.AND.Grade<10.0) THEN
     IN=4
  ELSE IF (Grade==10.0) THEN
     IN=5
  ELSE
     IN=0
  ENDIF
!
  IF (IN==0) THEN
     PRINT *, "The input : ", Grade," has a wrong value. Only [0,10]"
  ELSE
     PRINT *,  "The student grade is ", List_Grades(IN)
  ENDIF
!
END PROGRAM EX_5_1

5.3.2. `excode_5_2.f90'
-----------------------

PROGRAM ex_5_2
  !
  IMPLICIT NONE
  !
  REAL :: Grade
  INTEGER :: Index, Integer_Grade
  CHARACTER(LEN=2), DIMENSION(1:5) ::  List_Grades=(/'D ','C ','B ','A ','A+'/)
  ! READ Grade
  PRINT *, "Nota del estudiante?"
  READ *, Grade
  !
  Integer_Grade = NINT(Grade)
  !
  SELECT CASE (Integer_Grade)
  CASE (0:4)
     Index = 1
  CASE (5,6)
     Index = 2
  CASE (7,8)
     Index = 3
  CASE (9)
     Index = 4
  CASE (10)
     Index = 5
  CASE DEFAULT
     Index = 0
  END SELECT
  !
  IF (Index==0) THEN
     PRINT *, "The input grade : ", Grade," is out of bounds. Only  [0,10]."
  ELSE
     PRINT 100, Grade, List_Grades(Index)
  ENDIF
  !
100 FORMAT(1X,'Student grade is ',F4.1,' (',A3,')')
  !
END PROGRAM EX_5_2

5.3.3. `excode_5_3.f90'
-----------------------

PROGRAM ex_5_3
  !
  IMPLICIT NONE
  !
  REAL :: PIover2 = ASIN(1.0)
  REAL :: ANGLE1 = 0.0, ANGLE2 = 0.0
  INTEGER :: I
  !
  DO I = 0, 16, 2
     ANGLE1 = I*PIO2/4.0
     !
     WRITE(*,*)
     WRITE(*,*) 'Cos(',I/2,'PI/4) = ',COS(ANGLE1),'; Cos(',I/2,'PI/4) = ',COS(ANGLE2)
     WRITE(*,*) 'Sin(',I/2,'PI/4) = ',SIN(ANGLE1),'; Sin(',I/2,'PI/4) = ',SIN(ANGLE2)
     WRITE(*,*)
     !
     ANGLE2 = ANGLE2 + PIO2/2.0
     !
  ENDDO
END PROGRAM ex_5_3

5.3.4. Programa ejemplo_5_4.f90
-------------------------------

PROGRAM excode_5_4
  !
  IMPLICIT NONE
  !
  REAL :: X_val = 0.0
  REAL :: X_app = 0.0, X_sum = 0.0
  INTEGER :: I_flag = 1, I_count = 0
  !
  ! Taylor Series:  SIN(X) = X - X^3/3! + X^5/5! - X^7/7! + ...
  WRITE(*,*) "Introduce the angle X (RAD) :"
  READ(*,*) X_val
  !
  I_count = 1
  X_app = X_val
  X_sum = X_val
  !
  PRINT*, '         Order     Approx.    SIN(X)       Approx. - SIN(X)'
  !
  DO WHILE (I_flag == 1)
     !
     PRINT*, I_count, X_app, SIN(X_val), X_app - SIN(X_val)
     !
     X_sum = X_sum*(-1)*X_val*X_val/((I_count*2+1)*(I_count*2))
     X_app = X_app + X_sum
     !
     I_count = I_count + 1
     !
     WRITE(*,*) "STOP? (0 yes, 1 no)"
     READ(*,*) I_flag
     IF (I_flag /= 1 .AND. I_flag /= 0) I_flag = 1
     !
  ENDDO
  !
END PROGRAM excode_5_4


-------------------------------------------------------------------------------


6. `INPUT/OUTPUT' (I)
---------------------


6.1. Objectivos
---------------

     The main aims of this lesson are the following:

     1.   present how to make use of the standard `bash' redirection for
          reading and writing data in `Fortran'.

     2.   present the `FORMAT' statement, as well as its differents
          descriptors and its use with the commands `PRINT' and `WRITE'.

     3.   get a basic knowledge about file handling in `Fortran' with the
          commands `OPEN', `CLOSE', and `WRITE'.


6.2. Main Items.
----------------

        * `bash' shell redirection

          The standard input and output (`STDIN/STDOUT') redirection in
          `bash' with `<' and `>' allows a `Fortran' program in a simple
          and direct way to read from and write to a file.

          As an example, the following commands run from a terminal execute
          a program called `a.out'.  Its output is sent to a file called
          `output.dat' in the first case.  In the second case, the program
          reads its input from a file called `input.dat', instead of the
          standard option, the keyboard.  In the third case bot options are
          combined.

               a.out > output.dat
               a.out < input.dat
               a.out <input.dat > output.dat

          The assignment number 4 can be quite done quite easily making use
          of standard redirection.

          The error output (`STDERR') can be redirected too as follows

               a.out 2> output.dat
               a.out 2>&1 ouput.dat

          In the second case `STDERR' and `STDOUT' are merged together in
          file `output.dat'.

        * In order to gain a finer control of the format of input and
          output statementes the so called _format descriptors_ are
          introduced.  We have make use of the default options or free
          format up to now, indicated with the symbol `*' as in
          `READ(*,*)', `READ*', and `PRINT*'.

          To specify a particular format for the input and output in the
          above mentioned commands the syntax used is `PRINT' <nlin>,
          <output_list>, or `READ' <nlin>, <output_list>; where <nlin> is a
          label driving to a `FORMAT' statement with the necessary
          descriptors and <output_list> are the constant and variables that
          will be read or written.  It is possible to include directly the
          descriptors in the statement.

          The format descriptors in `FORTRAN', due to historical reasons
          (line printers), treated the first character as a control
          character.  If the first character is

          1.   `0' : double spacing.

          2.   `1' : new page.

          3.   `+' : no spacing.  Print over the previous line.

          4.   `blank' : simple spacing.

          But this is not anymore true unless you are using a line printer
          (quite bizarre situation in the XXI century).

          The format descriptors can fix the vertical position in a line of
          text, alter the horizontal position of characters in a line,
          control the display of integers (`I'), floats (`F' and `E'),
          strings `A' and logical variables (`L').

          The following symbols are used

          1.   <c> : column number

          2.   <d> : number of digits after decimal point (real values)

          3.   <m> : minimum number of digits displayed

          4.   <n> : number of spaces

          5.   <r> : times a descriptor is repeated

          6.   <w> : number of characters affected by a descriptor

          Descriptors in I/O operations

          1.   Integers: `I': General form <r>`I'<w>

               This descriptor indicates that <r> integer values will be
               read or written, and they occupy <w> characters or columns.
               The number is right justified and if the number of digits is
               less than the number of spacings the rest of the space is
               filled with space characters.  The example

                    PRINT 100, I, I*I
                    100 FORMAT(' ',I3, ' squared is ', I6)

               outputs a space, a three-digit integer, the string '`squared
               is'' and finish with the square of the variable `I', with a
               maximum number of six digits.  More examples can be found in
               Section 6.3.1, ``excode_6_1.f90'', where the reader can see
               the effect of having a number with more digits than the
               allocated space in the format.  In this example we also
               include the `X' descriptor, such that <n>`X' includes <n>
               space characters in the output, or skip <n> characters from
               the input.

               Format descriptors can be also included directly in the
               `PRINT' statement, though the resulting code is generally
               less readable.

                    PRINT "(' ',I3, ' squared is ', I6)", I, I*I

               As can be seen in code example Section 6.3.1,
               ``excode_6_1.f90'' we can have an arithmetic overflow in a
               variable and the solution is shown in example Section 6.3.2,
               ``excode_6_2.f90''.

          2.   Real values descriptor `F': General form <r>`F'<w.d>

               Where <w> is the total number of columns used to fit the
               number, <d> the number of figures after the decimal point,
               and <r> the number of times this descriptor is applied.

               For example if the descriptor is `F7.3' the number will be
               displayed with three figures after the decimal point and
               occupies seven spaces.  This implies that this format
               descriptor is valid for numbers between `-99.999' and
               `999.999'.  The truncated decimal part of the number is
               properly rounded.  It may happens that as a result of the
               truncation the number has more digits than expected.  The
               output will be changed for <w> asterisk characters (`*').
               In source code Section 6.3.3, ``excode_6_3.f90'' we face
               such kind of problems.

          3.   Real descriptor `E': General form <r>`E'<w.d>

               Introduces scientific notation.  The number that multiplies
               the power of ten takes values between 0.1 to 1.0.  This case
               differs from the previous one that some space should be
               devoted to the exponent.  In fact, apart from the
               multiplier, it is needed one character for the sign of the
               number if it is negative, another character for the decimal
               point, another one for the `E' symbol (stands for Exponent),
               and the magnitude and sign of the exponent.  Therefore the
               minimum size in this case is <w = d+7>.  Example code
               Section 6.3.4, ``excode_6_4.f90'' is identical to example
               Section 6.3.3, ``excode_6_3.f90'' changing the `F'
               descriptors to `E'.  This change facilitates to work with
               numbers whose value vary into a big range.

          4.   Real data descriptor `ES': general format <r>`ES'<w.d>

               It allows the use of the standard scientific notation, with
               the factor that multiplies the power of ten taking velues in
               the range 1.0 to 10.0.  Apart from this it is similar to the
               previous float descriptor.

          5.   Logical data descriptor `L': general format <r>`L'<w>

               Logical or boolean data only take the values `TRUE' or
               `FALSE' and the output of this descriptor will be a right
               justified `T' or `F'.

          6.   Character descriptor `A': general format <r>`A' or <r>`A'<w>

               This format implies that there are <r> string fields <w>
               character wide.  If <w> is missing the string is taken with
               the same length of the character variable.  The example
               Section 6.3.5, ``excode_6_5.f90'' shows how this descriptor
               is used.

          7.   `X' descriptor: general format <n>`X'

               The `X' descriptor controls horizontal displacement, and it
               implies that <n> spaces should be included in the output.
               You can find an example of this descriptor in source code
               Section 6.3.5, ``excode_6_5.f90''.

          8.   Descriptor `T':

               El descriptor `T'<c> controla el desplazamiento horizontal e
               indica que se salte directamente a la columna <c>.

          9.   `/' descriptor:

               The `/'descriptor flush the output buffered and feeds a new
               line.  It does not need to be included between commas.

          10.  The repetition of a set of descriptors can be easily
               indicated combining them between parentheses.  For example

                    100 FORMAT(1X, I6, I6, F9.3, F9.3, F9.3)

               can be simplified to

                    100 FORMAT(1X, 3(I6, F9.3))

        * `Fortran' allows file manipulation with the commands `OPEN',
          `WRITE' and `CLOSE'.  Other, more advanced, commands are `REWIND'
          and `BACKSPACE'.

          The `OPEN' command allows to initiate a file.  The simplest
          instance of this command is

               OPEN(UNIT=<unit_number>,FILE='<filename>')

          where the file name and the integer number of the associated unit
          are indicated.  The file is therefore associated to this number
          for any Read/Write operation.  We can write something in this
          file as follows

               OPEN(UNIT=33, FILE='program_OUT.dat')
               WRITE(UNIT=33,FMT=100) <variable_lists>

          which indicates that the data included in <variable_list> will be
          written in the file associated with unit number 33, following the
          format specified in line labeled `100'.  It is possible to
          abbreviate the command to `WRITE(33,100)' or `WRITE(33,*)' if
          free format is required.  In order to send the data to `STDOUT',
          `WRITE(UNIT=6,<format>)', `WRITE(6,*)', `WRITE(*,*)', or `PRINT*'
          are all valid and equivalent commands.  Standard input `STDIN' is
          associated with unit number `5' or the `*' symbol[1].

          Once the write process takes place the unit should be closed
          using the statement `CLOSE(UNIT=<unit_number>)'.  In our case

               CLOSE(UNIT=33)

          Example Section 6.3.6, ``excode_6_6.f90'' shows how data are sent
          to a file and introduces the intrinsic function `CPU_TIME' that
          allows to estimate the cpu time spent in a program and its
          different sections.

          The `OPEN' command can be more specific, adding the following
          arguments:

OPEN(UNIT=<unit_number>,FILE=<file_name>,STATUS=<file_status>, ACTION=<action_var>, IOSTAT=<integer_var>)

          These options control the following aspects:

          1.   `STATUS=<file_status>'

               The constant or variable <file_status> is of character type
               and can take the following values:

                  * 'OLD'

                  * 'NEW'

                  * 'REPLACE'

                  * 'SCRATCH'

                  * 'UNKNOWN'

          2.   `ACTION=<action_var>'

               The constant or variable <action_var> is of character type
               and can have the following forms:

                  * 'READ'

                  * 'WRITE'

                  * 'READWRITE'

               By default.  archives are opened with both read and write
               permissions active.

          3.   `IOSTAT=<integer_var>'

               The variable <integer_stat> is of integer type and gives
               feedback about the success of the opening of the file.  If
               the final value is `0' the file has been correctly opened.
               Any other value indicates a problem.

          A complete example will be

INTEGER ierr
OPEN(UNIT=33, FILE='input_program.dat', STATUS='OLD', ACTION='READ', IOSTAT=ierr)

          If we want to create a file to store some data:

INTEGER ierr
OPEN(UNIT=33, FILE='output_program.dat', STATUS='NEW', ACTION='WRITE', IOSTAT=ierr)

        * It is possible some degree of control on the access to the
          elements stored sequentially using the commands

               BACKSPACE(UNIT = <unit_number>)
               REWIND(UNIT = <unit_number>)

          The `BACKSPACE' statement set the register one line back in the
          associated file while `REWIND' move back to the first register of
          the file.

        * The default is to open formatted files.  Thus, the following two
          statements are equivalent

               OPEN(UNIT=33,FILE='<file_name>')
               OPEN(UNIT=33,FILE='<file_name>',FORM='FORMATTED')

          Formatted files can be edited and read by the user, but they have
          a couple of cons.  Data storage and reading in formatted files
          takes longer than in unformatted files and there may be some
          precision loss in float numbers.  In order to write data without
          format files should be opened including the `FORM='UNFORMATTED''
          option:

               OPEN(UNIT=33,FILE='<file_name>',FORM='UNFORMATTED')

          To write in a file declared unformatted the `WRITE' command takes
          the form

               WRITE(UNIT=33) <variable_list>

     The combination of fortran descriptors and different kinds of loop in
     a code can be found in the example Section 6.3.7, ``excode_6_7.f90''.
     This program reads a data file (a template of this fila can be found
     under the program, and can be saved removing the trailing `!'
     symbols).  When the program opens the datafile with `OPEN' it uses the
     `STATUS = 'OLD'' and `ACTION='READ'' options.  It reads the file,
     skipping some files making use of a `REPEAT UNTIL' loop, until it
     arrives to a line that provides the number of data pairs in the
     file[2].  Knowing the number of data pairs the appropriate matrices
     are allocated and the points are read and saved into vectors `data_X'
     and `data_Y', and computes the maximum (minimum) value of `data_X'
     (`data_Y') making use of the intrinsic functions `MAXVAL' and `MINVAL'
     (see Section 8.1, `Objectives').

[1]  `STDERR' is associated with unit `0'.

[2]  This is achieved making use of the `IERR =' <label> option in the
     `READ' command.  opción indica que si se ha producido un error de
     lectura el programa debe saltar a la línea marcada por <label>.


6.3. Example Codes
------------------

6.3.1. `excode_6_1.f90'
-----------------------

          PROGRAM ex_6_1
            !
            IMPLICIT NONE
            !
            ! Variables
            INTEGER :: i, big=10
            !
            DO i=1,20
               PRINT 100, i, big
               big=big*10
            END DO
            !
            ! Format Statements
          100 FORMAT(1X, '10 to the ',I3,2X,'=',2X,I12)
            !
          END PROGRAM ex_6_1

6.3.2. `excode_6_2.f90'
-----------------------

          PROGRAM ex_6_2
            !
            IMPLICIT NONE
            !
            INTEGER, PARAMETER :: Long=SELECTED_INT_KIND(16) ! 64 bits integer
            INTEGER :: i
            INTEGER (KIND=Long) :: big=10
            !
            DO i=1,18
               !
               PRINT 100, i, big
          100  FORMAT(1X, '10 to the ', I3, 2X, '=', 2X, I16)
               !
               big=big*10
               !
            END DO
            !
          END PROGRAM ex_6_2

6.3.3. `excode_6_3.f90'
-----------------------

          PROGRAM ex_6_3
            ! Program to produce numeric overflow and underflow
            IMPLICIT NONE
            INTEGER :: I
            REAL     :: small = 1.0
            REAL     :: big   = 1.0
          !
            DO i=1,45
               PRINT 100, I, small, big
          100  FORMAT(' ',I3,' ',F9.4,' ',F9.4)
               !
               small = small/10.0
               big = big*10.0
               !
            END DO
          END PROGRAM ex_6_3

6.3.4. `excode_6_4.f90'
-----------------------

          PROGRAM ex_6_4
            ! Program to produce numeric overflow and underflow
             IMPLICIT NONE
            INTEGER :: I
            REAL     :: small = 1.0
            REAL     :: big   = 1.0
          !
            DO i=1,45
               PRINT 100, I, small, big
          100  FORMAT(' ',I3,' ',E10.4,' ',E10.4)
               !
               small = small/10.0
               big = big*10.0
               !
            END DO
          END PROGRAM ex_6_4

6.3.5. `excode_6_5.f90'
-----------------------

PROGRAM ex_6_5
  ! Program to compute the Body Mass Index (Quetelet Index) according to the formula:
  !    BMI = (weight (kg))/(height^2 (m^2))
  !
  IMPLICIT NONE
  CHARACTER (LEN=25) :: Name
  INTEGER :: height_cm = 0, weight_kg = 0 ! height in cm and weight in kg
  REAL     :: height_m = 0.0 ! height in m units
  REAL     :: BMI ! Body Mass Index
  !
  PRINT*,  'Full Name:'; READ*, Name
  !
  PRINT*, 'Weight (kg)?:'; READ*, weight_kg
  !
  PRINT*, 'Height (cm)?:'; READ*, height_cm
  !
  height_m = height_cm/100.0
  BMI = weight_kg/(height_m**2)
  !
  PRINT 100, Name, BMI, BMI
100  FORMAT(1X,A ' BMI  is ', F10.4,' or ', E10.4)
!
END PROGRAM ex_6_5

6.3.6. `excode_6_6.f90'
-----------------------

          PROGRAM ex_6_6
          !
            IMPLICIT NONE
            INTEGER , PARAMETER :: N=1000000
            INTEGER , DIMENSION(1:N) :: X
            REAL    , DIMENSION(1:N) :: Y
            INTEGER :: I
            REAL :: T
            REAL    , DIMENSION(1:5) :: TP
            CHARACTER*10 :: COMMENT
          !
            OPEN(UNIT=10,FILE='/tmp/ex_6_6.txt')
          !
            CALL CPU_TIME(T)
          !
            TP(1)=T
            COMMENT=' Initial Time : '
            PRINT 100, COMMENT, TP(1)
            !
            DO I=1,N
               X(I)=I
            END DO
            !
            CALL CPU_TIME(T)
            !
            TP(2)=T-TP(1)
            COMMENT = ' Integer vector. Time :  '
            PRINT 100,COMMENT,TP(2)
            !
            Y=REAL(X)
            !
            CALL CPU_TIME(T)
            !
            TP(3)=T-TP(1)-TP(2)
            COMMENT = ' Real vector. Time :  '
            !
            PRINT 100,COMMENT,TP(3)
            !
            DO I=1,N
               WRITE(10,200) X(I)
          200  FORMAT(1X,I10)
            END DO
            !
            CALL CPU_TIME(T)
            TP(4)=T-TP(1)-TP(2)-TP(3)
            !
            COMMENT = ' Write Integer vector. Time :  '
            PRINT 100,COMMENT,TP(4)
            !
            DO I=1,N
               WRITE(10,300) Y(I)
          300  FORMAT(1X,f10.0)
            END DO
            !
            CALL CPU_TIME(T)
            TP(5)=T-TP(1)-TP(2)-TP(3)-TP(4)
            !
            COMMENT = ' Write Real vector. Time :  '
            PRINT 100,COMMENT,TP(5)
            !
          100 FORMAT(1X,A,2X,F7.3)
          END PROGRAM ex_6_6

6.3.7. `excode_6_7.f90'
-----------------------

          PROGRAM ex_6_7
            !
            IMPLICIT NONE
            !
            REAL , DIMENSION(:), ALLOCATABLE :: X_vec, Y_vec ! Data Vectors
            INTEGER :: Index, Ierr, Numpoints = 0
            REAL :: Max_x, Min_y
            CHARACTER(LEN=64) :: Filename
            !
            ! READ FILENAME
            READ(5,*) Filename
            ! OPEN FILE (READONLY)
            OPEN( UNIT=10, FILE=Filename, STATUS='OLD', ACTION='READ' )
            !
            DO
               READ(UNIT=10, FMT=100, ERR=10) Numpoints
               IF (Numpoints /= 0) EXIT
          10   READ (UNIT=10, FMT=*) ! JUMP ONE LINE
               CYCLE
            ENDDO
            !
            PRINT*, 'NUMPOINTS = ', Numpoints
            !
            ! ALLOCATE X, Y VECTORS
            ALLOCATE(X_vec(1:NUMPOINTS), STAT = IERR)
            IF (Ierr /= 0) STOP 'X_vec MEM ALLOCATION FAILED'
            ALLOCATE(Y_vec(1:NUMPOINTS), STAT = IERR)
            IF (Ierr /= 0) STOP 'Y_vec MEM ALLOCATION FAILED'
            !
            DO I = 1, Numpoints
               !
               READ(UNIT=10, FMT=110) X_vec(I), Y_vec(I)
               !
            ENDDO
            !
            Max_x = MAXVAL(X_vec)
            Min_y = MINVAL(Y_vec)
            !
            PRINT*, "MAXIMUM X VALUE = ", Max_x
            PRINT*, "MINIMUM Y VALUE = ", Min_y
            ! DEALLOCATE AND CLOSE FILE
            DEALLOCATE(X_vec, STAT = IERR)
            IF (Ierr /= 0) STOP 'X_vec MEM DEALLOCATION FAILED'
            DEALLOCATE(Y_vec, STAT = IERR)
            IF (Ierr /= 0) STOP 'Y_vec MEM DEALLOCATION FAILED'
            !
            CLOSE(10)
            ! FORMAT STATEMENTS
          100 FORMAT(19X,I3)
          110 FORMAT(F6.3,1X,F6.3)
            !
          END PROGRAM ex_6_7
          !# Remark 1
          !# Remark 2
          !Useless line 1
          !Useless line 2
          !Number of points = 4
          !+1.300;-2.443
          !+1.265;-1.453
          !+1.345;-8.437
          !+1.566;+4.455
          !+1.566;+4.455
          !+3.566;+7.755
          !+1.566;+4.457
          !+2.366;+2.454
          !+1.566;+4.405
          !+0.566;+9.450
          !+1.545;+4.465
          !+9.566;+6.455
          !+1.466;+8.405
          !+0.566;+7.055


-------------------------------------------------------------------------------


7. `Input/Output' (II)
----------------------


7.1. Objectives
---------------

     The main aims of this session consist of:

     1.   presenting the use of `FORMAT' in reading operations.

     2.   considering basic techniques about the reading of files in
          `Fortran'.

     3.   presenting possible alternatives to the standard `I/O': _here
          documents_ and the `NAMELIST' type input.

     4.   presenting internal files.

     This chapter is very much linked with the previous one, having an
     emphasis in reading data instead of writing them.  We present
     interesting options for providing input data to a program.  Formatted
     input is seldom used with the keyboard, though it is very important
     when reading data stored in a file.


7.2. Main items.
----------------

        * The `FORMAT' statement acts in a completely equivalent way to the
          one explained in Chapter 6, ``INPUT/OUTPUT' (I)'.

        * A useful option of the `READ' command is `IOSTAT'.  It allows to
          detect if the read process has reached the end-of-file:

READ(UNIT=<unit_number>, FMT=<format_label>, IOSTAT=<integer_var>) <variable_list>

          Thus, if if we read a set of data, e.g.  coordinates in space as
          `(var_X,var_Y,var_Z)' from a file and we do not know the total
          number of coordinates included we can proceed as follows

               num_data = 0
               readloop: DO
                  !
                  READ(UNIT=33, FMT=100, IOSTAT=io_status) var_X, var_Y, var_Z
                  !
                  ! Check reading
                  IF (io_status /= 0) THEN
                    ! Error in the input or EOF
                    EXIT
                  ENDIF
                  num_data = num_dat + 1
                  !   work with the coordinates
                  !
                     ......
                  !
                  ! Format statement
               100 FORMAT(1X, 3F25.10)
                  !
               ENDDO readloop

          The integer variable `num_data' is a counter that indicates the
          number of points read and the integer `io_status' check if the
          reading has been correct.

        * The example Section 7.3.1, `Programa ejemplo_7_1.f90' presents
          how to read array slices from a file were students' grades are
          indicated in rows (students) and columns (subjects).

        * A convenient way to convey the input to a `Fortran' program is
          making use of a _here documents_ from the `bash shell'.

          A _here document_ is a brief script[1], such that apart from
          compiling (if necessary) and running the program, the input is
          given in a way that comments can also be included.  Example
          Section 7.3.2, ``excode_7_2.f90'' is a program that computes the
          roots of a second order algebraic equation `y = A*x**2 + B*x + C'
          and `ej_here_file' included in Section 7.3.3, `Script
          `ej_here_file'', is an application of a _here document_.  In
          order to run this program proceed as follows

               . ej_here_file

        * The `namelist' format is quite informative, consisting in a list
          of values assigned to variables labeled with their names.  The
          command `NAMELIST' syntax is

               NAMELIST/<var_group_name>/ <var1 [var2 var3 ... ]>

          This statement define a set of variables assigned to the
          <var_group_name> and should appear in the program prior to any
          executable statemnt.  The reading of variables included in a
          `NAMELIST' is done with a `READ' statement where, instead of
          specifying a format with the `FMT' option, is used the option
          `NML' as follows[2]

               READ(UNIT=<unit_number>, NML=<var_group_name>, [...])

          The `NAMELIST' file with the variable information must start each
          line with the "&" character, followed by the variable group name,
          <var_group_name>, ending the line with the character "/".  The
          values in the file can be in different lines but always between
          the two mentioned characters.

          Program Section 7.3.4, ``excode_7_3.f90'' is almost identical to
          program Section 7.3.2, ``excode_7_2.f90'' but it has been
          modified to make use of a `namelist' file, called
          `sec_order.inp', included as Section 7.3.5, ``namelist' input
          file'.

        * In the example Section 7.3.6, ``excode_7_4.f90'' you can find an
          _internal file_, where the I/O takes place in an internal buffer
          instead than in a file.  This is rather handy to treat data of
          unknowkn format, reading them first in a character variable and
          treating them later, or to handle data mixing variables of
          different types, like character and integer.  This is the case in
          the example Section 7.3.6, ``excode_7_4.f90'' where a series of
          different numbered files are defined and data saved in them.
          sucesivamente.  In this example the intrinsic function `TRIM' is
          used to remove trailing spaces from the variable `pref'.

[1]  From The Free On-line Dictionary of Computing (8 July 2008) [foldoc]:
     _script_: A program written in a scripting language.

[2]  The `NAMELIST' format could also be used with the `WRITE' command to
     save labeled variables.


7.3. Example Codes
------------------

7.3.1. Programa ejemplo_7_1.f90
-------------------------------

PROGRAM EJEMPLO_7_1
  IMPLICIT NONE
  !Definicion de variables
  INTEGER , PARAMETER :: NROW=5
  INTEGER , PARAMETER :: NCOL=6
  REAL , DIMENSION(1:NROW,1:NCOL)   :: RESULT_EXAMS = 0.0
  REAL , DIMENSION(1:NROW)          :: MEDIA_ESTUD = 0.0
  REAL , DIMENSION(1:NCOL)          :: MEDIA_ASIGN = 0.0
  INTEGER :: R,C
  !
  ! Abrir fichero para lectura
  OPEN(UNIT=20,FILE='notas.dat',STATUS='OLD')
  !
  DO R=1,NROW
     READ(UNIT=20,FMT=100) RESULT_EXAMS(R,1:NCOL),MEDIA_ESTUD(R) ! Lectura de notas y luego de promedio
     100 FORMAT(6(2X,F4.1),2X,F5.2) ! Se leen 6 numeros seguidos y luego un septimo
  ENDDO
  READ (20,*) ! Saltamos una linea con esta orden
  READ (20,110) MEDIA_ASIGN(1:NCOL) !
110 FORMAT(6(2X,F4.1))
!
! IMPRESION DE LAS NOTAS EN LA SALIDA ESTANDAR
  DO R=1,NROW
     PRINT 200, RESULT_EXAMS(R,1:NCOL), MEDIA_ESTUD(R)
200  FORMAT(1X,6(1X,F5.1),' = ',F6.2)
  END DO
  PRINT *,'  ====  ====  ====  ====  ====  ==== '
  PRINT 210, MEDIA_ASIGN(1:NCOL)
210 FORMAT(1X,6(1X,F5.1))
END PROGRAM EJEMPLO_7_1

7.3.2. `excode_7_2.f90'
-----------------------

          PROGRAM ex_7_2
          ! Second degree equation solver
          ! y = A*x**2 + B*x + C
            IMPLICIT NONE
            ! Variables
            REAL :: A = 0.0
            REAL :: B = 0.0
            REAL :: C = 0.0
            REAL, DIMENSION(2) :: SOL
            REAL :: TEMP
            INTEGER :: I
            !
            ! Input: A, B, C
            READ*, A
            READ*, B
            READ*, C
            !
            ! Calculations
            TEMP = SQRT(B*B-4.0*A*C)
            !
            SOL(1) = (-B+TEMP)/(2.0*A)
            SOL(2) = (-B-TEMP)/(2.0*A)
            !
            !
            !
            DO I=1, 2
               PRINT 200, I, SOL(I)
          200  FORMAT(1X,'SOLUTION ', I2,' = ',F18.6)
            END DO
          !
          END PROGRAM EX_7_2

7.3.3. Script `ej_here_file'
----------------------------

          # Compile..
          gfortran -o second_order  excode_7_2.f90
          # And Run...
          ./second_order <<eof
          2.0     # A
          1.0     # B
          -4.0    # C
          eof

7.3.4. `excode_7_3.f90'
-----------------------

          PROGRAM ex_7_3
            ! Solving second order algebraic equation
            ! y = A*x**2 + B*x + C
            IMPLICIT NONE
            ! Variables
            REAL :: A = 0.0
            REAL :: B = 0.0
            REAL :: C = 0.0
            REAL, DIMENSION(2) :: SOL
            REAL :: TEMP
            INTEGER :: I
            !
            !     NAMELIST DEFINITION
            NAMELIST/INP0/ A, B, C
            !     NAMELIST FILE
            OPEN(UNIT=10,FILE='sec_order.inp',STATUS='OLD')
            !     Inpot of A, B, C
            READ(10,INP0)
            !
            ! Calculations
            TEMP = SQRT(B*B-4.0*A*C)
            !
            SOL(1) = (-B+TEMP)/(2.0*A)
            SOL(2) = (-B-TEMP)/(2.0*A)
            !
            !
            ! OUTOPUT
            DO I=1, 2
               PRINT 200, I, SOL(I)
          200  FORMAT(1X,'SOLUTION ', I2,' = ',F18.6)
            END DO
          !
          END PROGRAM EX_7_3

7.3.5. `namelist' input file
----------------------------

          #
          #       INPUT FILE FOR excode_7_3.f90
          #
           &INP0 A=2.0, B=1.0, C=-4.0 /

7.3.6. `excode_7_4.f90'
-----------------------

PROGRAM ex_7_4
  !
  ! Internal file example
  !
  IMPLICIT NONE
  ! Variables
  REAL :: x_var
  INTEGER :: unit_n, index_X
  CHARACTER(LEN=65) :: filename
  CHARACTER(LEN=56) :: pref
  !
  PRINT*, "Introduce file name preffix: "
  READ(*,*) pref
  !
  DO unit_n = 10, 20
     !
     WRITE(filename, '(A, "_", i2,".dat")') TRIM(pref), unit_n
     OPEN(UNIT = unit_n, FILE = filename, STATUS = "UNKNOWN", ACTION = "WRITE")
     !
     DO index_X = 0, 100
        x_var = REAL(index_X)*0.01
        WRITE(unit_n, '(1X,2ES14.6)') x_var, SIN(REAL(unit_n)*x_var)
     ENDDO
     !
     CLOSE(UNIT = unit_n)
     !
  ENDDO
!
END PROGRAM ex_7_4


-------------------------------------------------------------------------------


8. Subprograms (I): FUNCTIONS
-----------------------------


8.1. Objectives
---------------

     The main aims of this lesson are the following:

     1.   presenting the advantages of using functions, subroutines and
          modules.

     2.   presenting the function concept in `Fortran'.

     3.   showing the different types of functions: intrinsic, generic,
          elemental, transformational, and internal.

     4.   making possible the definition of new functions by the user.

     5.   evinving the difference beyween external and internal functions.

     The use of subporgrams allows a more structured and efficient
     programming owing to

        * the possibility of developing and testing different subtasks in
          an independent manner.

        * it makes possible to recycle subprograms in different programs,
          diminishing the necessary time for coding.

        * the isolation in different subtasks of possible errors and the
          minimization of unexpected side effects, due to variable
          encapsulation.


8.2. Main items.
----------------

     We first focus in functions and will follow with subroutines and
     modules.

        * General characteristics of functions.

          The main characteristics of a function are:

             * May require the input of one or several arguments.

             * Arguments can take the form of an expression.

             * In general, a function produces a single output, which is a
               function of the arguments, and this output is of scalar type
               though in some cases it also can be of an array type.

             * The arguments can be of different types.

          There are more than one hundred predefined functions in
          `Fortran', highly tested, and of easy usage.  E.g.  we need
          trigonometric functions we can make use of the following:

             * `Y = SIN(X)'

             * `Y = COS(X)'

             * `Y = TAN(X)'

          where `X' and `Y' are real variables[1]

          This predefined functions are called _intrinsic functions_.  In
          this link URL
          (http://gcc.gnu.org/onlinedocs/gfortran/Intrinsic-Procedures.html#Intrinsic-Procedures)
          you can find a complet list of the intrinsic functions at your
          disposal with the `gfortran' compiler.

          In general intrinsic functions are also _generic_, which means
          that they can admit different argument types, with the exception
          of the functions `LGE', `LGT', `LLE', and `LLT'.

        * _Elemental_ functions may have as an argument both scalars or
          vectors.  The example source codes Section 8.3.1,
          ``excode_8_1.f90'' and Section 8.3.2, ``excode_8_2.f90'' show the
          elemental and generic character of some intrinsic functions.
          When an elemental function is applied to an array the fucntions
          is applied to each array element.

        * Other type of functions are of _inquiry_ type, giving information
          about the characterictics of an array, e.g.  the `SIZE' and
          `ALLOCATED' functions.  Examples of the latter are found in
          Section 6.3.7, ``excode_6_7.f90'' and Section 9.3.3,
          ``excode_9_3.f90''.

          _Transformational_ functions transform between different data
          types, e.g.  `REAL' and `TRANSPOSE', or functions that work with
          time data variables as `SYSTEM_CLOCK' and `DATE_AND_TIME'.

        * Conversion between data types:

             * `REAL(i)': integer `i' is converted to a float.  The
               argument `i' can be an integer, a double precision real or a
               complex number.

             * `INT(x)': transforms the real variable `x' to an integer,
               truncating the decimal part.  No rounding is performed.  The
               `x' variable can be a real, double precision real, or a
               complex variable.

             * The functions that follow allow to transform from real to
               integer values with an adequate control:

                  * `CEILING(x)': real value `x' to the minimum integer
                    value larger than or equal than `x'.

                  * `FLOOR(x)': real value `x' to the maximum integer value
                    less than or equal than `x'.

                  * `NINT(x)': round the real value `x' to the nearest
                    integer.

             * `DBLE(a)': transforms `a' to double precision.  The argument
               can be integer, real, or complex.

             * `CMPLX(x)' or `CMPLX(x,y)': transform to complex values,
               where the second argument is the imaginary part.

        * Apart from the intrinsic functions, user defined functions can
          also be added.  The definition of a function requires, apart from
          the function definition, the way the function is invoked from a
          program.

          A user defined function is created according to the following
          scheme.

               FUNCTION <fun_name>(<argument_list>)
                 IMPLICIT NONE
                 Declaration section (including arguments and fun_name)
                 ....
                 Local variables declaration
                 ....
                 <fun_name> = expr
                 RETURN ! Optional
               END FUNCTION <fun_name>

          The example Section 8.3.3, `Programa ejemplo_8_3.f90' shows how
          to define and invoke a function computing the greatest common
          divisor of two integers.  The following considerations should be
          taken into account:

             * This example is built with two blocks, the main program and
               the function definition.  bloque con el programa principal y
               un segundo bloque donde se define la función.  The function
               definition can be carried out in a separate file.  In such
               case both filenames should be provided to the compiler.

             * The variables defined in a function are _local_ with respect
               to the main program variables.

             * The `MCD' function is of `INTEGER' type.  Therefore, in
               principle, the function output should be of integer type.

             * The `INTENT(IN)' attribute characterizing the `A' and `B'
               variables:

                    INTEGER , INTENT(IN) :: A,B

               marks these two as input variables, whose values cannot be
               modified in the body of the function.

          Every function argument needs to be difined with the `INTENT(IN)'
          attribute to avoid the modification of their values with
          unforeseen consequences.

        * It is possible to define _internal_ functions, restrained to
          certain code segment.  Such functions cannot be called from any
          program unit but the one that defines them.  This is achieved
          with the `CONTAINS' statement (e.g.  Section 8.3.4, `Programa
          ejemplo_8_4.f90' and Section 8.3.5, ``excode_8_5.f90'').

[1]  You should take into account that in `Fortran' angles are expressed in
     radian units.


8.3. Example Codes
------------------

8.3.1. `excode_8_1.f90'
-----------------------

PROGRAM ex_8_1
  IMPLICIT NONE
  ! Variable Definition
  INTEGER, PARAMETER :: Long=SELECTED_REAL_KIND(18,310)
  !
  REAL (KIND=Long), PARAMETER :: DPI = ACOS(-1.0_Long) ! Pi number double precision
  REAL (KIND=Long) :: DANGLE, DANGLERAD
  !
  REAL, PARAMETER :: PI = ACOS(-1.0) ! Pi number single precision
  REAL :: ANGLERAD
  !
  PRINT*, 'ANGLE INPUT (Degrees)'
  READ*, DANGLE
  PRINT*
  ! Transform to  RAD
  DANGLERAD = DPI*DANGLE/180.0_Long
  ANGLERAD  = PI*DANGLE/180.0
  !
  PRINT 20, DANGLE, DANGLERAD
  PRINT 21, DANGLE, ANGLERAD
  PRINT*
  PRINT*
  !
  PRINT 22, DANGLERAD, SIN(DANGLERAD), COS(DANGLERAD), SIN(DANGLERAD)**2+COS(DANGLERAD)**2,&
       1.0_Long-(SIN(DANGLERAD)**2+COS(DANGLERAD)**2)
  PRINT*
  PRINT 22, ANGLERAD, SIN(ANGLERAD), COS(ANGLERAD), SIN(ANGLERAD)**2+COS(ANGLERAD)**2,1.0 - (SIN(ANGLERAD)**2+COS(ANGLERAD)**2)
  !
20 FORMAT (1X, 'An angle of ',F14.8,' degrees = ', F14.8, ' rad. (dp)')
21 FORMAT (1X, 'An angle of ',F14.8,' degrees = ', F14.8, ' rad. (sp)')
22 FORMAT (1X, 'ANGLE ',F14.8,', SIN = ', F13.9, ', COS =',F13.9,/'SIN**2+COS**2 = ', F18.14, ', 1 - SIN**2+COS**2 = ', F18.14)
END PROGRAM EX_8_1

8.3.2. `excode_8_2.f90'
-----------------------

PROGRAM ex_8_2
  IMPLICIT NONE
  ! VARIABLE DEFINITION
  INTEGER , PARAMETER :: NEL=5
  REAL, PARAMETER :: PI = ACOS(-1.0) ! Pi number
  REAL, DIMENSION(1:NEL)   :: XR = (/ 0.0, PI/2.0, PI, 3.0*PI/2.0, 2.0*PI/)
  INTEGER , DIMENSION(1:NEL):: XI = (/ 0, 1, 2, 3, 4/)
  !
  PRINT*, 'Sin  ', XR, ' = ', SIN(XR)
  PRINT*, 'LOG10  ', XR, ' = ', LOG10(XR)
  PRINT*, 'REAL ', XI, ' = ', REAL(XI)
END PROGRAM ex_8_2

8.3.3. Programa ejemplo_8_3.f90
-------------------------------

PROGRAM ex_8_3
  IMPLICIT NONE
  INTEGER :: I,J,Result
  INTEGER :: MCD
  EXTERNAL MCD
  PRINT *,' INTRODUCE TWO INTEGERS:'
  READ *,I,J
  RESULT = MCD(I,J)
  PRINT *,' THE GREATEST COMMON DIVISOR OF ',I,' AND ',J,' IS ',RESULT
END PROGRAM ex_8_3
!
INTEGER FUNCTION MCD(A,B)
IMPLICIT NONE
INTEGER , INTENT(IN) :: A,B
INTEGER :: Temp
  IF (A < B) THEN
     Temp=A
  ELSE
     Temp=B
  ENDIF
  DO WHILE ((MOD(A,Temp) /= 0) .OR. (MOD(B,Temp) /=0))
     Temp=Temp-1
  END DO
  MCD=Temp
END FUNCTION MCD

8.3.4. Programa ejemplo_8_4.f90
-------------------------------

          PROGRAM ex_8_4
            IMPLICIT NONE
            ! Internal function example:
            ! E(v) = we (v+1/2) - wexe (v+1/2)**2.
            INTEGER :: V, VMAX
            REAL :: we, wexe, Energy
            PRINT *,' Vmax?:'
            READ *, VMAX
            PRINT *,' we and wexe?'
            READ *,we, wexe
            DO V = 0, VMAX
               Energy = FEN(V)
               PRINT 100, V, Energy
            ENDDO
          100 FORMAT(1X,'E(',I3,') = ',F14.6)
          CONTAINS
          !
            REAL FUNCTION FEN(V)
              IMPLICIT NONE
              INTEGER , INTENT(IN) :: V
              FEN = we*(V+0.5)-wexe*(V+0.5)**2
            END FUNCTION FEN
          !
          END PROGRAM EX_8_4

8.3.5. `excode_8_5.f90'
-----------------------

PROGRAM ex_8_5
  !
  ! Simple program to compute the prime divisors of a given integer number.
  !
  IMPLICIT NONE
  INTEGER :: NUMVAL
  INTEGER :: NUM
  !
  READ*, NUMVAL ! input
  !
  DO
     NUM = QUOT(NUMVAL)
     IF (NUM == NUMVAL) THEN
        PRINT*, NUM
        EXIT
     ELSE
        PRINT*, NUMVAL/NUM, NUM
        NUMVAL = NUM
     ENDIF
  ENDDO
  !
CONTAINS
  !
  INTEGER FUNCTION QUOT(NUM1)
    !
    INTEGER, INTENT(IN) :: NUM1
    INTEGER :: I
    !
    QUOT = NUM1
    !
    DO I = 2, NUM1-1
       IF (MOD(NUM1,I) == 0) THEN
          QUOT = NUM1/I
          EXIT
       ENDIF
    ENDDO
    !
  END FUNCTION QUOT
  !
END PROGRAM ex_8_5

8.3.6. `excode_8_6.f90'
-----------------------

PROGRAM ex_8_6
  !
  ! Program to evaluate a 1D potential function on grid points
  !
  IMPLICIT NONE
  !
  REAL, DIMENSION(:), ALLOCATABLE :: X_grid, Pot_grid
  !
  REAL :: X_min, X_max, Delta_X
  REAL :: V_0 = 10.0, a_val = 1.0
  INTEGER :: Index, X_dim
  INTEGER :: Ierr
  !
  !
  INTERFACE Potf
     ELEMENTAL FUNCTION Potf(Depth, Inv_length, X)
       !
       IMPLICIT NONE
       !
       REAL, INTENT(IN) :: Depth, Inv_length, X
       REAL :: Potf
       !
     END FUNCTION Potf
  END INTERFACE Potf
  !
  !
  READ(*,*), X_min, X_max, X_dim ! input minimum and maximum values of X and number of points
  !
  ALLOCATE(X_grid(1:X_dim), STAT = Ierr)
  IF (Ierr /= 0) THEN
     STOP 'X_grid allocation failed'
  ENDIF
  !
  ALLOCATE(Pot_grid(1:X_dim), STAT = Ierr)
  IF (Ierr /= 0) THEN
     STOP 'Pot_grid allocation failed'
  ENDIF
  !
  !
  Delta_X = (X_max - X_min)/REAL(X_dim - 1)
  !
  X_grid = (/ (Index, Index = 0 , X_dim - 1 ) /)
  X_grid = X_min + Delta_X*X_grid
  !
  Pot_grid = Potf(V_0, a_val, X_grid)
  !
  DO Index = 1, X_dim
     PRINT*, X_grid, Pot_grid
  ENDDO
  !
  DEALLOCATE(X_grid, STAT = Ierr)
  IF (Ierr /= 0) THEN
     STOP 'X_grid deallocation failed'
  ENDIF
  !
  DEALLOCATE(Pot_grid, STAT = Ierr)
  IF (Ierr /= 0) THEN
     STOP 'Pot_grid deallocation failed'
  ENDIF
  !
  !
END PROGRAM ex_8_6
!
ELEMENTAL FUNCTION Potf(Depth, Inv_length, X)
  !
  IMPLICIT NONE
  !
  REAL, INTENT(IN) :: Depth, Inv_length, X
  !
  REAL :: Potf
  !
  Potf = -Depth/(COSH(Inv_length*X)**2)
  !
END FUNCTION Potf

8.3.7. `excode_8_7.f90'
-----------------------

          PROGRAM ex_8_7
            !
            ! Program to characterize an array making use of inquiry functions
            !
            IMPLICIT NONE
            !
            REAL, DIMENSION(:,:), ALLOCATABLE :: X_grid
            INTEGER :: Ierr
            !
            !
            ALLOCATE(X_grid(-20:20,0:50), STAT = Ierr)
            IF (Ierr /= 0) THEN
               STOP 'X_grid allocation failed'
            ENDIF
            !
            WRITE(*, 100) SHAPE(X_grid)
          100 FORMAT(1X, "Shape :        ", 7I7)
            !
            WRITE(*, 110) SIZE(X_grid)
          110 FORMAT(1X, "Size :         ", I7)
            !
            WRITE(*, 120) LBOUND(X_grid)
          120 FORMAT(1X, "Lower bounds : ", 7I6)
            !
            WRITE(*, 130) UBOUND(X_grid)
          130 FORMAT(1X, "Upper bounds : ", 7I6)
            !
            DEALLOCATE(X_grid, STAT = Ierr)
            IF (Ierr /= 0) THEN
               STOP 'X_grid deallocation failed'
            ENDIF
            !
          END PROGRAM ex_8_7


-------------------------------------------------------------------------------


9. Subprograms (II): subroutines
--------------------------------


9.1. Objectives
---------------

     The main aims of this session consist of:

     1.   considering the differences between functions and subroutines and
          in what cases are the latter useful.

     2.   introducing the user to the subroutine definition procedures.

     3.   explaining subroutine arguments roles.

     4.   defining the commands `CALL' and `INTERFACE'.

     5.   explaining the _scope_ of the variables of a subroutine and the
          role of local variables and of variables with the `SAVE'
          attribute.

     6.   presenting the different ways of passing an array as an argument
          to a subroutine.

     7.   defining the so called automatic arrays.


9.2. Main items.
----------------

     1.   The use of subroutines favors a structured programming through
          the definition of subtasks and avoiding code duplication.
          Together with functions, they make possible to access to an
          extense collection of libraries for multiple applications.

     2.   To better explain this point we will make use of a simple
          example: solving a second order equation.  A possible way of
          dividing this task in simpler subtasks is as follows

          1.   Main program.

          2.   Equation coefficient input.

          3.   Solution of the algebraic equation.

          4.   Solution output.

          The program Section 9.3.1, ``excode_9_1.f90'' follows closely
          this scheme with two subroutines: `Interact' and `Solve'.

     3.   The syntax to define a subroutine is as follows

                 SUBROUTINE <subroutine_name>(arguments [optional])
                        IMPLICIT NONE
                        Arguments (dummy variables) definition (INTENT)
                        ...
                        Local variables definition
                        ...
                        Execution Section
                        ...
                        [RETURN]
                END SUBROUTINE  <subroutine_name>

          Argumentos are called _dummy_ because their definition is not
          followed by a memory assignment, this assignment will take place
          once the subroutine is called.

          Each subroutine is compiled in a separate way by the compiler,
          what allows for the use of _local variables_ that may have the
          same name in different subroutines and the main program without
          clashing due to the different scopes.

          This scheme can be seen in program Section 9.3.1,
          ``excode_9_1.f90''.

     4.   A subroutine is invoked with the `CALL' command as follows

               CALL subroutine_name(arguments [optional])

          Once the subroutine is executed the program flow returns to the
          program unit where the subroutine was invoked, after the `CALL'
          statement.  The subroutine determines when to return to the
          invoking unit once the `RETURN' statement is found or if the
          subroutine execution ends.

     5.   The subroutine and the main program data flow takes place through
          the arguments, also called subroutine parameters.  Arguments in
          the subroutine definition are _dummy_ variables, with an
          associated type but no space reserved in memory.  For example,
          the `E', `F', and `G' arguments in the `Solve' subroutine in the
          code Section 9.3.1, ``excode_9_1.f90'' are of `REAL' type, but
          without any memory allocation.  Only when the subroutine is
          invoked with the `CALL Solve(P,Q,R,Root1,Root2,IFail)' command
          the arguments `E', `F', and `G' are replaced by pointers to the
          main program variables `P', `Q', and `R'.  This is why it is of
          great importance that the data type of variables and arguments
          match correctly.

     6.   Some of the arguments provide the necessary input for the
          subroutine, while others are output arguments that send the
          subroutine results to the invoking program unit.  Mixed character
          input/output arguments can also be used.

          Those parameters that are only input parameters should be defined
          using the `INTENT(IN)' attribute that, as it is the case with
          functions, indicate that the argument values cannot be altered in
          the subroutine.

          If the parameters are output, the arguments should be defined
          with the `INTENT(OUT)' attribute, to avoid taking into account
          the input value of the argument.

          Mixed character arguments should be defined with the
          `INTENT(INOUT)' attribute.

          The subroutine `Solve' in example Section 9.3.1,
          ``excode_9_1.f90'' provides examples for the three cases.  It is
          advisable to label with the corresponding `INTENT' attribute
          every argument.

     7.   In order to facilitate the accordance between variables in the
          invoking program unit and the subroutine the user can defined the
          so called _interface blocks_.  The example Section 9.3.2,
          ``excode_9_2.f90'' is the same code than Section 9.3.1,
          ``excode_9_1.f90'' to which interface blocks have been added for
          the `Interact' and `Solve' subroutines.

     8.   As in the case of functions, those variables defined in a
          subroutine that are not arguments are considered as local
          variables.  For example, the `Interact' subroutine in Section
          9.3.1, ``excode_9_1.f90'' has a local variable called
          `IO_Status'.

          In general the local variables are created once the subroutine is
          called and the value is lost unless they possess the `SAVE'
          attribute, that makes possible to store the variable value from
          one call to the next.  For example

               INTEGER, SAVE:: It = 0

          The variable `It' value is kept among different calls to the
          subroutine.

          As it is the case for functions, it is possible that the
          subprogram has access to the main program variables making use of
          the `CONTAINS' statement.  This solution can be hard to scale
          once programs acquire certain size and it is not very advisable.

     9.   When the argument of a subroutine is of _array_ type it is
          necessary to provide some extra information about the matrix to
          avoid the possible access of the subroutine to wrong memory
          areas.  In order to achieve this there are three possible ways of
          specifying the dimensiones of an array included in a subroutine
          list of arguments.

          1.   _explicit-shape approach_:

               In this case the dimensions of the matrices are included as
               arguments in the subroutine call and the matrices are
               declared making use of these arguments.  For example, if in
               a subroutine called `test_pass' an input vector
               (`space_vec_in') and an output vector (`space_vec_out') with
               equal dimensions are used, if we make use of the
               _explicit-shape approach_ the subroutine starts as follows

SUBROUTINE test_pass(space_vec_in, space_vec_out, dim_vec)
         IMPLICIT NONE
         INTEGER, INTENT(IN) :: dim_vec
         REAL, INTENT(IN), DIMENSION(1:dim_vec) :: space_vec_in
         REAL, INTENT(OUT), DIMENSION(1:dim_vec) :: space_vec_out
         ......
 END SUBROUTINE test_pass

          2.   _assumed-shape approach_:

               The main difference with the previous case is that either
               the corresponding `INTERFACE' block is added or, as
               explained in Chapter 10, `Subprograms (III): modules', the
               subroutine is embedded in a module.

               The example code Section 9.3.3, ``excode_9_3.f90''
               calculates the mean, the median[1], the variance and the
               standard deviation of a set of random numbers following a
               continuous uniform distribution.  Several points of interest
               has been marked in the program.

                  * _(1-3)_ Dynamic memory storage using the `ALLOCATABLE'
                    attribute and the `ALLOCATE' statement.  Notice that
                    the array is a vector (`DIMENSION(:)') and this piece
                    of info needs to be also include in the _interface
                    block_.  The use of the _interface block_ in cases like
                    this one is mandatory.  The statement _(3)_,
                    `ALLOCATE(X(1:N), STAT = IERR)' defines the length of
                    the `X' vector.  We also use the optional field `STAT'
                    to check whether the array has been correctly
                    dimensioned or not.  Only if the output of this field,
                    in the `IERR' variable, is zero the dynamic allocation
                    has worked flawlessly.

  REAL , ALLOCATABLE , DIMENSION(:) :: X  !! (1)

  ...

  INTERFACE
     SUBROUTINE STATS(X,N,MEAN,STD_DEV,MEDIAN)
       IMPLICIT NONE

       ...

       REAL      , INTENT(IN) , DIMENSION(:)   ::    X  !!  (1)

       ...

     END SUBROUTINE STATS
  END INTERFACE

                    It is important to take into account that an argument
                    of a subroutine can have the `ALLOCATABLE' attribute,
                    as well as local subroutine variables, but not _dummy_
                    variables.

                    The _assumed shape arguments_ are nonexistent in
                    `FORTRAN 77', and it is the recommended form of
                    transmitting arguments between a main program and a
                    subprogram.  In this form there is no transmitted
                    information about the dimension of the array, and the
                    argument and the main program variable need to have
                    equal type, range, and class (`KIND').

                  * _(4)_ and _(6)_: these statements take advantage of the
                    `Fortran 90' rules to work with vector and arrays.

                  * _(5)_ In this statement the allocated memory is revoked
                    and freed using the `DEALLOCATE' statement.  This is
                    not mandatory in programs like the present example,
                    though it is necessary to do so when the allocatable
                    array has been defined in a function of subroutine
                    without the `SAVE' attribute.

                  * _(7)_ The `CONTAINS' statement is used to make the
                    sorting subroutine `SELECTION' have access to the
                    variables of the `STATS' subroutine.  This is why in
                    the `SELECTION' subroutine with the sorting algorithm
                    only local variables need to be defined.

               The definition of `INTERFACE' blocks is a task simplified
               making use of modules, that are introduced in the next
               chapter.

          3.   _assumed-size approach_

               This case is not advised due to the lack of info in the
               subroutine about the matrix dimensiones.  This makes easy to
               make errors of difficult diagnose.  Its use is not
               encouraged.

     10.  Multidimensional arrays.  The source code Section 9.3.5,
          ``excode_9_5.f90'' is an example of how to pass multidimensional
          arrays as arguments of a subroutine as _assumed shape arrays_.
          The user defines two arrays , `A' and `B', and the program
          computes the `C' array as the matrix product `A' times `B'.
          Then, the program computes the transpose matrix of `A'.  The
          program makes use of the `Fortran 90' functions `MATMUL' and
          `TRANSPOSE'.

     11.  Subroutines can contain _automatic arrays_, that may depend on
          the subroutine argument values.  These are local array that may
          not have the `SAVE' attribute.  They are created when the
          subroutine is invoked and destroyed when the execution flow
          leaves the subroutine.  It is preferable to use `ALLOCATABLE'
          arrays.

     12.  An argument of `CHARACTER' type is also diffenrent in the sense
          that if such argument is declared with a length `LEN = *', once
          the subroutine is called the variable length is the legth of the
          variable in the call.

          The code Section 9.3.4, ``excode_9_4.f90'' is a program to which
          a file name is given and the number of data pairs stored in the
          file.  The program opens the file and reads the two-column
          dataset.  Notice that, due to the variable size of the
          `CHARACTER' variable, the _interface block_ is required.

          The example Section 9.3.6, ``excode_9_6.f90'' caluculate two
          pseudo random number vectors with a Gaussian or normal
          distribution with a dimension defined by the user.  This is
          achieved with the _Box-Mueller_ method.

          Two `ALLOCATABLE' arrays, `X' and `Y' are difined and in the
          internal subroutine `BOX_MULLER' two vectors of automatic type
          are defined: `RANDOM_u' and `RANDOM_v'.

          The mean value, the median and the standard deviation are
          computed making use of the `STATS' subroutine in the source code
          Section 9.3.3, ``excode_9_3.f90''.  The necessary `INTERFACE'
          block is included in the main program and the subroutine should
          be compiled in a separate file.

     13.  It is important to take into account that when array arguments
          are used as _assumed shape arguments_ the first index of the
          variable in the subroutine by default takes a value `1', unless
          it is explicitly indicated.  The example Section 9.3.7,
          ``excode_9_7.f90'' is a simple case where this initial value is
          indicated.  This program cmputes the factorial of the integers in
          the range between `IMIN' and `IMAX', storing them in a real
          vector.  The program can be compiled making `IMIN = 1' or `IMIN =
          0' with and without the definition of the initial index in the
          subroutine to check the different outputs.

[1]  The _median_ value of a set of data is defined as the value of the
     list such that half the values of the set are less than it and the
     other half are greater than it.  Median and mean are identical for
     symmetrical data distributions.  The calculation of the median
     requires the sorting of the set of values.


9.3. Example Codes
------------------

9.3.1. `excode_9_1.f90'
-----------------------

          PROGRAM ex_9_1
            !
            IMPLICIT NONE
            ! Simple program with two subroutines.
            ! subroutine (1):: Interact :: Data input.
            ! subroutine (2):: Solve :: Solve second order Eq.
            !
            ! Variables
            REAL :: P, Q, R, Root1, Root2
            INTEGER :: IFail=0
            LOGICAL :: OK=.TRUE.
            !
            CALL Interact(P,Q,R,OK) ! Subrutina (1)
            !
            IF (OK) THEN
               !
               CALL Solve(P,Q,R,Root1,Root2,IFail) ! Subrutina (2)
               !
               IF (IFail == 1) THEN
                  PRINT *,' Complex roots'
                  PRINT *,' calculation aborted'
               ELSE
                  PRINT *,' Roots are ',Root1,' ',Root2
               ENDIF
               !
            ELSE
               !
               PRINT*,' Error in data input program ends'
               !
            ENDIF
            !
          END PROGRAM ex_9_1
          !
          !
          SUBROUTINE Interact(A,B,C,OK)
            IMPLICIT NONE
            REAL , INTENT(OUT) :: A
            REAL , INTENT(OUT) :: B
            REAL , INTENT(OUT) :: C
            LOGICAL , INTENT(OUT) :: OK
            INTEGER :: IO_Status=0
            PRINT*,' Type in the coefficients A, B AND C'
            READ(UNIT=*,FMT=*,IOSTAT=IO_Status) A,B,C
            IF (IO_Status == 0) THEN
               OK=.TRUE.
            ELSE
               OK=.FALSE.
            ENDIF
          END SUBROUTINE Interact
          !
          !
          SUBROUTINE Solve(E,F,G,Root1,Root2,IFail)
            IMPLICIT NONE
            REAL , INTENT(IN) :: E
            REAL , INTENT(IN) :: F
            REAL , INTENT(IN) :: G
            REAL , INTENT(OUT) :: Root1
            REAL , INTENT(OUT) :: Root2
            INTEGER , INTENT(INOUT) :: IFail
            ! Local variables
            REAL :: Term
            REAL :: A2
            Term = F*F - 4.*E*G
            A2 = E*2.0
            ! if term < 0, roots are complex
            IF(Term < 0.0)THEN
               IFail=1
            ELSE
               Term = SQRT(Term)
               Root1 = (-F+Term)/A2
               Root2 = (-F-Term)/A2
            ENDIF
          END SUBROUTINE Solve

9.3.2. `excode_9_2.f90'
-----------------------

          PROGRAM ex_9_2
            !
            IMPLICIT NONE
            ! Simple program with two subroutines.
            ! subroutine (1):: Interact :: Data input.
            ! subroutine (2):: Solve :: Solve second order Eq.
            !
            ! Interface blocks
            INTERFACE
               SUBROUTINE Interact(A,B,C,OK)
                 IMPLICIT NONE
                 REAL , INTENT(OUT) ::  A
                 REAL , INTENT(OUT) ::  B
                 REAL , INTENT(OUT) ::  C
                 LOGICAL , INTENT(OUT) :: OK
               END SUBROUTINE Interact
               SUBROUTINE Solve(E,F,G,Root1,Root2,IFail)
                 IMPLICIT NONE
                 REAL , INTENT(IN) :: E
                 REAL , INTENT(IN) :: F
                 REAL , INTENT(IN) :: G
                 REAL , INTENT(OUT) :: Root1
                 REAL , INTENT(OUT) :: Root2
                 INTEGER , INTENT(INOUT) :: IFail
               END SUBROUTINE Solve
            END INTERFACE
            !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
            !
            ! Variables
            REAL :: P, Q, R, Root1, Root2
            INTEGER :: IFail=0
            LOGICAL :: OK=.TRUE.
            !
            CALL Interact(P,Q,R,OK) ! Subrutina (1)
            !
            IF (OK) THEN
               !
               CALL Solve(P,Q,R,Root1,Root2,IFail) ! Subrutina (2)
               !
               IF (IFail == 1) THEN
                  PRINT *,' Complex roots'
                  PRINT *,' calculation aborted'
               ELSE
                  PRINT *,' Roots are ',Root1,' ',Root2
               ENDIF
               !
            ELSE
               !
               PRINT*,' Error in data input program ends'
               !
            ENDIF
            !
          END PROGRAM ex_9_2
          !
          !
          SUBROUTINE Interact(A,B,C,OK)
            IMPLICIT NONE
            REAL , INTENT(OUT) :: A
            REAL , INTENT(OUT) :: B
            REAL , INTENT(OUT) :: C
            LOGICAL , INTENT(OUT) :: OK
            INTEGER :: IO_Status=0
            PRINT*,' Type in the coefficients A, B AND C'
            READ(UNIT=*,FMT=*,IOSTAT=IO_Status)A,B,C
            IF (IO_Status == 0) THEN
               OK=.TRUE.
            ELSE
               OK=.FALSE.
            ENDIF
          END SUBROUTINE Interact
          !
          !
          SUBROUTINE Solve(E,F,G,Root1,Root2,IFail)
            IMPLICIT NONE
            REAL , INTENT(IN) :: E
            REAL , INTENT(IN) :: F
            REAL , INTENT(IN) :: G
            REAL , INTENT(OUT) :: Root1
            REAL , INTENT(OUT) :: Root2
            INTEGER , INTENT(INOUT) :: IFail
            ! Local variables
            REAL :: Term
            REAL :: A2
            Term = F*F - 4.*E*G
            A2 = E*2.0
            ! if term < 0, roots are complex
            IF(Term < 0.0)THEN
               IFail=1
            ELSE
               Term = SQRT(Term)
               Root1 = (-F+Term)/A2
               Root2 = (-F-Term)/A2
            ENDIF
          END SUBROUTINE Solve

9.3.3. `excode_9_3.f90'
-----------------------

          PROGRAM ex_9_3
            !
            IMPLICIT NONE
            !
            ! Variables
            INTEGER :: N
            REAL , ALLOCATABLE , DIMENSION(:) :: X  !! (1)
            REAL :: M,SD,MEDIAN
            INTEGER :: IERR
            !
            ! interface block   !! (2)
            INTERFACE
               SUBROUTINE STATS(VECTOR,N,MEAN,STD_DEV,MEDIAN)
                 IMPLICIT NONE
                 INTEGER , INTENT(IN)                    ::  N
                 REAL      , INTENT(IN) , DIMENSION(:)   :: VECTOR  !!  (1)
                 REAL      , INTENT(OUT)                 :: MEAN
                 REAL      , INTENT(OUT)                 :: STD_DEV
                 REAL      , INTENT(OUT)                 :: MEDIAN
               END SUBROUTINE STATS
            END INTERFACE
            PRINT *,' Length of random values vector ?'
            READ *,N
            ALLOCATE(X(1:N), STAT = IERR)     !!  (3)
            IF (IERR /= 0) THEN
               PRINT*, "X allocation request denied."
               STOP
            ENDIF
            CALL RANDOM_NUMBER(X)
            X=X*1000             !!  (4)
            CALL STATS(X,N,M,SD,MEDIAN)
            !
            PRINT *,' MEAN = ',M
            PRINT *,' STANDARD DEVIATION = ',SD
            PRINT *,' MEDIAN IS = ',MEDIAN
            !
            IF (ALLOCATED(X)) DEALLOCATE(X, STAT = IERR)   !! (5)
            IF (IERR /= 0) THEN
               PRINT*, "X NON DEALLOCATED!"
               STOP
            ENDIF
          END PROGRAM ex_9_3
          !
          SUBROUTINE STATS(VECTOR,N,MEAN,STD_DEV,MEDIAN)
            IMPLICIT NONE
            ! Defincion de variables
            INTEGER , INTENT(IN)                    ::  N
            REAL      , INTENT(IN) , DIMENSION(:)    ::  VECTOR    !! (1)
            REAL      , INTENT(OUT)                  ::  MEAN
            REAL      , INTENT(OUT)                  ::  STD_DEV
            REAL      , INTENT(OUT)                  ::  MEDIAN
            REAL      , DIMENSION(1:N)              ::  Y
            REAL :: VARIANCE = 0.0
            REAL      :: SUMXI = 0.0, SUMXI2 = 0.0
            !
            SUMXI=SUM(VECTOR)       !! (6)
            SUMXI2=SUM(VECTOR*VECTOR)    !! (6)
            MEAN=SUMXI/N
            VARIANCE=(SUMXI2-SUMXI*SUMXI/N)/(N-1)
            STD_DEV = SQRT(VARIANCE)
            Y=VECTOR
            ! Ordena valores por proceso de seleccion
            CALL SELECTION
            IF (MOD(N,2) == 0) THEN
               MEDIAN=(Y(N/2)+Y((N/2)+1))/2
            ELSE
               MEDIAN=Y((N/2)+1)
            ENDIF
          CONTAINS     !! (7)
            SUBROUTINE SELECTION
              IMPLICIT NONE
              INTEGER :: I,J,K
              REAL :: MINIMUM
              DO I=1,N-1
                 K=I
                 MINIMUM=Y(I)
                 DO J=I+1,N
                    IF (Y(J) < MINIMUM) THEN
                       K=J
                       MINIMUM=Y(K)
                    END IF
                 END DO
                 Y(K)=Y(I)
                 Y(I)=MINIMUM
              END DO
            END SUBROUTINE SELECTION
          END SUBROUTINE STATS

9.3.4. `excode_9_4.f90'
-----------------------

          PROGRAM ex_9_4
            IMPLICIT NONE
            REAL,DIMENSION(1:100)::A,B
            INTEGER :: Nos,I
            CHARACTER(LEN=32)::Filename
            INTERFACE
               SUBROUTINE Readin(Name,X,Y,N)
                 IMPLICIT NONE
                 INTEGER , INTENT(IN) :: N
                 REAL,DIMENSION(1:N),INTENT(OUT)::X,Y
                 CHARACTER (LEN=*),INTENT(IN)::Name
               END SUBROUTINE Readin
            END INTERFACE
            PRINT *,' Type in the name of the data file'
            READ '(A)' , Filename
            PRINT *,' Input the number of items in the file'
            READ * , Nos
            CALL Readin(Filename,A,B,Nos)
            PRINT * , ' Data read in was'
            DO I=1,Nos
               PRINT *,' ',A(I),' ',B(I)
            ENDDO
          END PROGRAM ex_9_4
          SUBROUTINE Readin(Name,X,Y,N)
            IMPLICIT NONE
            INTEGER , INTENT(IN) :: N
            REAL,DIMENSION(1:N),INTENT(OUT)::X,Y
            CHARACTER (LEN=*),INTENT(IN)::Name
            INTEGER::I
            OPEN(UNIT=10,STATUS='OLD',FILE=Name)
            DO I=1,N
               READ(10,*)X(I),Y(I)
            END DO
            CLOSE(UNIT=10)
          END SUBROUTINE Readin

9.3.5. `excode_9_5.f90'
-----------------------

          PROGRAM ex_9_5
            IMPLICIT NONE
            REAL , ALLOCATABLE , DIMENSION &
                 (:,:)::One,Two,Three,One_T
            INTEGER :: I,N
            INTERFACE
               SUBROUTINE Matrix_bits(A,B,C,A_T)
                 IMPLICIT NONE
                 REAL, DIMENSION (:,:), INTENT(IN) :: A,B
                 REAL, DIMENSION (:,:), INTENT(OUT) :: C,A_T
               END SUBROUTINE Matrix_bits
            END INTERFACE
            PRINT *,'Matrix Dimension?'
            READ*,N
            ALLOCATE(One(1:N,1:N))
            ALLOCATE(Two(1:N,1:N))
            ALLOCATE(Three(1:N,1:N))
            ALLOCATE(One_T(1:N,1:N))
            DO I=1,N
               PRINT*, 'Row ', I,'-th of the first array?'
               READ*,One(I,1:N)
            END DO
            DO I=1,N
               PRINT*, 'Row ', I,'-th of the second array?'
               READ*,Two(I,1:N)
            END DO
            CALL Matrix_bits(One,Two,Three,One_T)
            PRINT*,' Result: Matrix Product'
            DO I=1,N
               PRINT *,Three(I,1:N)
            END DO
            PRINT *,' Transpose A^T:'
            DO I=1,N
               PRINT *,One_T(I,1:N)
            END DO
          END PROGRAM ex_9_5
          !
          SUBROUTINE Matrix_bits(A,B,C,A_T)
            IMPLICIT NONE
            REAL, DIMENSION (:,:), INTENT(IN) :: A,B
            REAL, DIMENSION (:,:), INTENT(OUT) :: C,A_T
            C=MATMUL(A,B)
            A_T=TRANSPOSE(A)
          END SUBROUTINE Matrix_bits

9.3.6. `excode_9_6.f90'
-----------------------

PROGRAM ex_9_6
  !
  IMPLICIT NONE
  !
  INTEGER :: I, IERR
  REAL, DIMENSION(:), ALLOCATABLE :: X, Y
  REAL :: M, SD, MEDIAN
  ! interface block
  INTERFACE
     SUBROUTINE STATS(VECTOR,N,MEAN,STD_DEV,MEDIAN)
       IMPLICIT NONE
       INTEGER , INTENT(IN)                    ::  N
       REAL      , INTENT(IN) , DIMENSION(:)   :: VECTOR
       REAL      , INTENT(OUT)                 :: MEAN
       REAL      , INTENT(OUT)                 :: STD_DEV
       REAL      , INTENT(OUT)                 :: MEDIAN
     END SUBROUTINE STATS
  END INTERFACE
  !
  READ*, I
  !
  ALLOCATE(X(1:I), STAT = IERR)
  IF (IERR /= 0) THEN
     PRINT*, "X allocation request denied."
     STOP
  ENDIF
  !
  ALLOCATE(Y(1:I), STAT = IERR)
  IF (IERR /= 0) THEN
     PRINT*, "Y allocation request denied."
     STOP
  ENDIF
  !
  CALL BOX_MULLER(I)
  !
  PRINT*, X
  CALL STATS(X,I,M,SD,MEDIAN)
  !
  PRINT *,' MEAN = ',M
  PRINT *,' STANDARD DEVIATION = ',SD
  PRINT *,' MEDIAN IS = ',MEDIAN
  !
  IF (ALLOCATED(X)) DEALLOCATE(X, STAT = IERR)
  IF (IERR /= 0) THEN
     PRINT*, "X NON DEALLOCATED!"
     STOP
  ENDIF
  PRINT*, Y
  CALL STATS(Y,I,M,SD,MEDIAN)
  !
  PRINT *,' MEAN = ',M
  PRINT *,' STANDARD DEVIATION = ',SD
  PRINT *,' MEDIAN IS = ',MEDIAN
  !
  IF (ALLOCATED(Y)) DEALLOCATE(Y, STAT = IERR)
  IF (IERR /= 0) THEN
     PRINT*, "Y NON DEALLOCATED!"
     STOP
  ENDIF
  !
CONTAINS
  !
  SUBROUTINE BOX_MULLER(dim)
    !
    ! Uses the Box-Muller method to create two normally distributed vectors
    !
    INTEGER, INTENT(IN) :: dim
    !
    REAL, PARAMETER :: PI = ACOS(-1.0)
    REAL, DIMENSION(dim) :: RANDOM_u, RANDOM_v ! Automatic arrays
    !
    CALL RANDOM_NUMBER(RANDOM_u)
    CALL RANDOM_NUMBER(RANDOM_v)
    !
    X = SQRT(-2.0*LOG(RANDOM_u))
    Y = X*SIN(2*PI*RANDOM_v)
    X = X*COS(2*PI*RANDOM_v)
    !
  END SUBROUTINE BOX_MULLER
  !
END PROGRAM ex_9_6
!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!
SUBROUTINE STATS(VECTOR,N,MEAN,STD_DEV,MEDIAN)
  IMPLICIT NONE
  ! Arguments
  INTEGER , INTENT(IN)                    ::  N
  REAL      , INTENT(IN) , DIMENSION(:)    ::  VECTOR    !! (1)
  REAL      , INTENT(OUT)                  ::  MEAN
  REAL      , INTENT(OUT)                  ::  STD_DEV
  REAL      , INTENT(OUT)                  ::  MEDIAN
  ! Local Variables
  REAL      , DIMENSION(1:N)              ::  Y
  REAL      :: VARIANCE = 0.0
  REAL      :: SUMXI = 0.0, SUMXI2 = 0.0
  !
  SUMXI=SUM(VECTOR)       !! (6)
  SUMXI2=SUM(VECTOR*VECTOR)    !! (6)
  MEAN=SUMXI/N
  VARIANCE=(SUMXI2-SUMXI*SUMXI/N)/(N-1)
  STD_DEV = SQRT(VARIANCE)
  Y=VECTOR
  ! Sort values
  CALL SELECTION
  IF (MOD(N,2) == 0) THEN
     MEDIAN=(Y(N/2)+Y((N/2)+1))/2
  ELSE
     MEDIAN=Y((N/2)+1)
  ENDIF
CONTAINS     !! (7)
  SUBROUTINE SELECTION
    IMPLICIT NONE
    INTEGER :: I,J,K
    REAL :: MINIMUM
    DO I=1,N-1
       K=I
       MINIMUM=Y(I)
       DO J=I+1,N
          IF (Y(J) < MINIMUM) THEN
             K=J
             MINIMUM=Y(K)
          END IF
       END DO
       Y(K)=Y(I)
       Y(I)=MINIMUM
    END DO
  END SUBROUTINE SELECTION
END SUBROUTINE STATS

9.3.7. `excode_9_7.f90'
-----------------------

          PROGRAM ex_9_7
            !
            IMPLICIT NONE
            !
            INTERFACE
               SUBROUTINE SUBEXAMPLE(IMIN, IMAX, FACT_MAT)
                 INTEGER, intent(in) :: IMIN, IMAX
                 REAL, DIMENSION(IMIN:), intent(out) :: FACT_MAT
               END SUBROUTINE SUBEXAMPLE
            END INTERFACE
            !
            ! Variables
            REAL, DIMENSION(:), ALLOCATABLE :: FACT_MAT
            INTEGER :: IMIN, IMAX, I
            !
            IMIN = 0
            IMAX = 5
            !
            ALLOCATE(FACT_MAT(IMIN:IMAX))
            !
            PRINT*, "MAIN", SIZE(FACT_MAT)
            !
            CALL SUBEXAMPLE(IMIN, IMAX, FACT_MAT)
            !
            DO I = IMIN, IMAX
               PRINT*, I, FACT_MAT(I)
            ENDDO
            !
          END PROGRAM ex_9_7
          !!!!!!!!!!
          !!!!!!!!!!
          SUBROUTINE SUBEXAMPLE(IMIN, IMAX, FACT_MAT)
            !
            IMPLICIT NONE
            INTEGER, intent(in) :: IMIN, IMAX
            REAL, DIMENSION(IMIN:), intent(out) :: FACT_MAT
            ! The subroutine with the next line only would work for IMIN = 1
            !  REAL, DIMENSION(:), intent(out) :: FACT_MAT
            !
            INTEGER :: j,k
            !
            PRINT*, "SUB", SIZE(FACT_MAT)
            !
            DO j = imin, imax
               fact_mat(j) = 1.0
               do k = 2, j
                  fact_mat(j) = k*fact_mat(j)
               enddo
            ENDDO
            !
            !
          END SUBROUTINE SUBEXAMPLE


-------------------------------------------------------------------------------


10. Subprograms (III): modules
------------------------------


10.1. Objectives
----------------

     The main aims of this session consist of:

     1.   Presenting modules and their main pros.

     2.   Use of modules for variable definition, replacing the deprecated
          `COMMON' block, a feature of `FORTRAN 77'.

     3.   Use of modules to define and transmit functions and subroutines.

     4.   Private and publice variables in a module: variable visibility.


10.2. Main items.
-----------------

     1.   Modules allow a clearer and more flexible code production.  A
          module can encompass

          1.   Global variables declaration.

               Modules in this regard replace the deprecated `COMMON' and
               `INCLUDE' `FORTRAN 77' features.

          2.   `INTERFACE' blocks declaration.

          3.   Functions and subroutines declaration, avoiding the
               necessity of including `INTERFACE' blocks.

          4.   Access control to the different variables, assigning public
               or private character.

          5.   Modules allow to pack derived types, functions, subroutines
               and allow the development of an object oriented programming
               approach in `FORTRAN'.

          The syntax of a module declaration is as follows

               MODULE <module_name>
                  IMPLICIT NONE
                  [SAVE]
                    <Variable declarations>
                  [ CONTAINS
                    <Subprograms definition> ]
               END MODULE  <module_name>

          The modules is loaded with the statement `USE MODULE
          <module_name>' that has to preceed the rest of the program
          statements.  From a module another module can be called.

     2.   Modules allow the transmission of variables between subprogram
          units without arguments.  The other main role of modules is,
          making use of the `CONTAINS' statement, to define functions,
          subroutines and `INTERFACE' blocks.

          The subprograms inclusion in a module informs the compiler about
          all the details of them, allowing a fast error detection.
          Subroutines and functions in a module and accessed with `USE
          MODULE' it is said to be an _explicit interface_, whereas in
          other case it is said to have an _implicit interface_.

     3.   The definition of modules favors the encapsulation of code,
          defining easily reusable code, which is the basis of object
          oriented programming.

     4.   Modules are loaded from other programs or subprograms via the
          `USE' command.

     5.   In order to define common variables for several program units the
          deprecated `COMMON' feature should be avoided.  Instead the
          following steps are necessary

          1.   Declare variables in a `MODULE'.

          2.   Give the variables the `SAVE' attribute.

          3.   Load the modue with the statement `USE' <module_name>) from
               those program units that should access the variables.

          As an example, if there are several physical constants that are
          used in severla programs we can define a module as follows

               MODULE PHYS_CONST
                 !
                 IMPLICIT NONE
                 !
                 SAVE
                 !
                 REAL, PARAMETER :: Light_Speed = 2.99792458E08  ! m/s
                 REAL, PARAMETER :: Newton_Ctnt = 6.67428E-11    ! m3 kg-1 s-2
                 REAL, PARAMETER :: Planck_Ctnt = 4.13566733E-15 ! eV s
                 !
                 REAL :: Other_variable
                 !
               END MODULE PHYS_CONST

          In this module three physical constants are defined (with the
          `PARAMETER' attribute) and a fourth variable that is not kept
          constant.  Any program unit that needs access to these variables
          only needs to load the module as follows

               PROGRAM CALCULUS
                 !
                 USE PHYS_CONST
                 !
                 IMPLICIT NONE
                 !
                 REAL DISTANCE, TIME
                 !
                 ...
                 DISTANCE = Light_Speed*TIME
                 ...
                 !
               END PROGRAM CALCULUS

     6.   The use of modules allows a safe, portable, and flexible way of
          controlling the precision of the integer and real numbers in the
          program.  A possible way to define in a protable way the
          precision of a given code is with a module like `NUMERIC_KINDS'
          included in Section 10.3.2, ``excode_10_1_mod.f90'' and we can
          define the precision using this module

               PROGRAM TEST_MINUIT
                 !
                 USE NUMERIC_KINDS
                 !
                 IMPLICIT NONE
                 !
                 ! Variable Definition
                 REAL(KIND=dp), PARAMETER :: PI = 4.0_dp*ATAN(1.0_dp)
                 REAL(KIND=dp) :: ENERF
                  ....
                  ....

          This solution enhances the portability of the code and is less
          error prone than individually defining the precision for each
          program unit.  The example code Section 10.3.1,
          ``excode_10_1.f90'' is the same than Section 9.3.6,
          ``excode_9_6.f90'' apart from this improvement.

     7.   In the source code Section 10.3.4, ``excode_10_2_mod.f90'' we
          present a module, defined with the `MODULE' heading instead of
          `PROGRAM', for the definition of an integers _stack_.  In this
          case it is worth to notice the way the variables `STACK_POS' and
          `STORE' are defined, as `PRIVATE' variables and with the `SAVE'
          attribute.

               PROGRAM Use_Stack
               !
               USE Stack     ! Load the module
               !
               IMPLICIT NONE
               ....
               ....
               CALL POP(23); CAL PUSH(20)
               ....
               ....
               END PROGRAM Use_Stack

     8.   As shown in Section 10.3.4, ``excode_10_2_mod.f90'', variables in
          a module can have either a private or a public character, using
          the `PRIVATE/PUBLIC' attributes.  A private variable can not be
          accessed from the calling program unit.  The program loading the
          module in the proposed example only can access the `POP' and
          `PUSH' subroutines.  The default option is `PUBLIC' ant it's
          possible to define the attribute in the same line of the variable
          definition.

                 INTEGER, PRIVATE, PARAMETER :: STACK_SIZE = 500
                 INTEGER, PRIVATE, SAVE :: STORE(STACK_SIZE) = 0, STACK_POS = 0

     9.   Sometimes it is possible that there are conflicts between a
          variable or a subprogram defined in a module are in conflict with
          variables or subprograms defined in the calling program unit.  In
          order to avoid this problem there exists the possibility of
          renaming the module variables, though this is a last minute
          solution for desperate situations.

          If, for example, we call the module `Stack' from a main program
          that already has a variable called `PUSH', we can rename the
          module `PUSH' object to `STACK_PUSH' when invoking the module.

               USE Stack, STACK_PUSH => PUSH

          Several objects can be simultaneously renamed, separating the
          list with commas.

     10.  Es posible hacer que solo algunos elementos del módulo sean
          accesibles desde el programa que lo invoca con la cláusula
          `ONLY', donde también es posible renombrar los objetos si es
          necesario.  Por ejemplo, con la llamada

               USE Stack, ONLY: POP, STACK_PUSH => PUSH

          Solamente se accede a `POP' y `PUSH', y este último se renombra a
          `STACK_PUSH'.

     11.  Source code Section 10.3.3, ``excode_10_2.f90'' is a simple
          program where module Section 10.3.4, ``excode_10_2_mod.f90'' is
          used to handle a stack to perform integer sums and substraction
          in reversed Polish notation (RPN).

          The RPN does not require the use of parentheses and is faster
          than the usual algebraic notation.  If the stack contains, from
          first to last, the numbers `(23, 10, 33)' and we take into
          account the principle tenemos en cuenta que un stack se rige por
          el principio _last in, first out_, tendremos que si introducimos
          un número más (p.e.  `5') y realizamos las operaciones de suma
          (`plus') y substracción (`minus') tendremos lo siguiente

               -       -         -              -
               -       23        -              -
               23      10        23             -
               10      33        10             23
               33   ->  5   ->   38 (=33+5) -> -28 (=10-38)
               
               5      plus      minus

          Para llevar a cabo esta tarea se carga el módulo `Stack' en
          _(1)_.  Una vez cargado el módulo podemos acceder a las
          subrutinas `POP' y `PUSH' que nos permiten manejar el stack.  En
          _(2)_ comienza el bucle principal, con la etiqueta `inloop', que
          termina cuando el usuario da como input `Q', `q' o `quit'.

          Para controlar este bucle se utiliza una estructura `SELECT CASE'
          que comienza en _(3)_.  Esta estructura analiza cuatro casos
          posibles:

             * _(4)_: salir del programa

             * _(5)_: suma

             * _(6)_: resta

             * _(7)_: introduce número en el stack (`DEFAULT')

          En el último caso se transforma la variable de carácter leída en
          una variable entera para almacenarla en el stack.

          Para compilar y correr este programa podemos hacerlo compilando
          previamente el módulo, si lo hemos salvado en el fichero
          `ejemplo_10_1_Stack.f90'

               $ gfortran -c ejemplo_10_1_Stack.f90
               $ gfortran -o ejemplo_10_2 ejemplo_10_2.f90 ejemplo_10_1_Stack.o

          En un ejercicio se plantean al alumnos diferentes maneras de
          mejorar el programa simple Section 10.3.3, ``excode_10_2.f90''.


10.3. Example codes.
--------------------

10.3.1. `excode_10_1.f90'
-------------------------

PROGRAM ex_10_1
  !
  USE NUMERIC_KINDS
  !
  IMPLICIT NONE
  !
  INTEGER :: I, IERR
  REAL(KIND=dp), DIMENSION(:), ALLOCATABLE :: X, Y
  REAL(KIND=dp) :: M, SD, MEDIAN
  ! interface block
  INTERFACE
     SUBROUTINE STATS(VECTOR,N,MEAN,STD_DEV,MEDIAN)
       !
       USE NUMERIC_KINDS
       !
       IMPLICIT NONE
       INTEGER , INTENT(IN)                    ::  N
       REAL(KIND=dp)      , INTENT(IN) , DIMENSION(:)   :: VECTOR
       REAL(KIND=dp)      , INTENT(OUT)                 :: MEAN
       REAL(KIND=dp)      , INTENT(OUT)                 :: STD_DEV
       REAL(KIND=dp)      , INTENT(OUT)                 :: MEDIAN
     END SUBROUTINE STATS
  END INTERFACE
  !
  READ*, I
  !
  ALLOCATE(X(1:I), STAT = IERR)
  IF (IERR /= 0) THEN
     PRINT*, "X allocation request denied."
     STOP
  ENDIF
  !
  ALLOCATE(Y(1:I), STAT = IERR)
  IF (IERR /= 0) THEN
     PRINT*, "Y allocation request denied."
     STOP
  ENDIF
  !
  CALL BOX_MULLER(I)
  !
  PRINT*, X
  CALL STATS(X,I,M,SD,MEDIAN)
  !
  PRINT *,' MEAN = ',M
  PRINT *,' STANDARD DEVIATION = ',SD
  PRINT *,' MEDIAN IS = ',MEDIAN
  !
  IF (ALLOCATED(X)) DEALLOCATE(X, STAT = IERR)
  IF (IERR /= 0) THEN
     PRINT*, "X NON DEALLOCATED!"
     STOP
  ENDIF
  PRINT*, Y
  CALL STATS(Y,I,M,SD,MEDIAN)
  !
  PRINT *,' MEAN = ',M
  PRINT *,' STANDARD DEVIATION = ',SD
  PRINT *,' MEDIAN IS = ',MEDIAN
  !
  IF (ALLOCATED(Y)) DEALLOCATE(Y, STAT = IERR)
  IF (IERR /= 0) THEN
     PRINT*, "Y NON DEALLOCATED!"
     STOP
  ENDIF
  !
CONTAINS
  !
  SUBROUTINE BOX_MULLER(dim)
    !
    ! Uses the Box-Muller method to create two normally distributed vectors
    !
    INTEGER, INTENT(IN) :: dim
    !
    REAL(KIND=dp), PARAMETER :: PI = ACOS(-1.0_dp)
    REAL(KIND=dp), DIMENSION(dim) :: RANDOM_u, RANDOM_v ! Automatic arrays
    !
    CALL RANDOM_NUMBER(RANDOM_u)
    CALL RANDOM_NUMBER(RANDOM_v)
    !
    X = SQRT(-2.0_dp*LOG(RANDOM_u))
    Y = X*SIN(2.0_dp*PI*RANDOM_v)
    X = X*COS(2.0_dp*PI*RANDOM_v)
    !
  END SUBROUTINE BOX_MULLER
  !
END PROGRAM ex_10_1
SUBROUTINE STATS(VECTOR,N,MEAN,STD_DEV,MEDIAN)
  USE NUMERIC_KINDS
  IMPLICIT NONE
  ! Defincion de variables
  INTEGER , INTENT(IN)                    ::  N
  REAL(KIND=dp)      , INTENT(IN) , DIMENSION(:)    ::  VECTOR    !! (1)
  REAL(KIND=dp)      , INTENT(OUT)                  ::  MEAN
  REAL(KIND=dp)      , INTENT(OUT)                  ::  STD_DEV
  REAL(KIND=dp)      , INTENT(OUT)                  ::  MEDIAN
  REAL(KIND=dp)      , DIMENSION(1:N)              ::  Y
  REAL(KIND=dp)      :: VARIANCE = 0.0_dp
  REAL(KIND=dp)      :: SUMXI = 0.0_dp, SUMXI2 = 0.0_dp
  !
  SUMXI=SUM(VECTOR)       !! (6)
  SUMXI2=SUM(VECTOR*VECTOR)    !! (6)
  MEAN=SUMXI/N
  VARIANCE=(SUMXI2-SUMXI*SUMXI/N)/(N-1)
  STD_DEV = SQRT(VARIANCE)
  Y=VECTOR
  ! Ordena valores por proceso de seleccion
  CALL SELECTION
  IF (MOD(N,2) == 0) THEN
     MEDIAN=(Y(N/2)+Y((N/2)+1))/2
  ELSE
     MEDIAN=Y((N/2)+1)
  ENDIF
CONTAINS     !! (7)
  SUBROUTINE SELECTION
    IMPLICIT NONE
    INTEGER :: I,J,K
    REAL :: MINIMUM
    DO I=1,N-1
       K=I
       MINIMUM=Y(I)
       DO J=I+1,N
          IF (Y(J) < MINIMUM) THEN
             K=J
             MINIMUM=Y(K)
          END IF
       END DO
       Y(K)=Y(I)
       Y(I)=MINIMUM
    END DO
  END SUBROUTINE SELECTION
END SUBROUTINE STATS

10.3.2. `excode_10_1_mod.f90'
-----------------------------

          MODULE NUMERIC_KINDS
            ! 4, 2, AND 1 BYTE INTEGERS
            INTEGER, PARAMETER :: &
                 i4b = SELECTED_INT_KIND(9), &
                 i2b = SELECTED_INT_KIND(4), &
                 i1b = SELECTED_INT_KIND(2)
            ! SINGLE, DOUBLE, AND QUADRUPLE PRECISION
            INTEGER, PARAMETER :: &
                 sp = KIND(1.0), &
                 dp = KIND(1.0D0), &
                 qp = SELECTED_REAL_KIND(2*PRECISION(1.0_dp))
          END MODULE NUMERIC_KINDS

10.3.3. `excode_10_2.f90'
-------------------------

          PROGRAM RPN_CALC
            !
            ! SIMPLE INTEGER RPN CALCULATOR (ONLY SUM AND SUBSTRACT)
            !
            USE Stack                 !!        (1)
            !
            IMPLICIT NONE
            !
            INTEGER :: KEYB_DATA
            CHARACTER(LEN=10) :: INPDAT
            !
            INTEGER :: I, J, K, DATL, NUM, RES
            !
            !
            inloop: DO      !! MAIN LOOP        (2)
               !
               READ 100, INPDAT
               !
               SELECT CASE (INPDAT)   !!        (3)
                  !
               CASE ('Q','q','quit')  !! EXIT          (4)
                  PRINT*, "End of program"
                  EXIT inloop
               CASE ('plus','Plus','PLUS','+')   !! SUM              (5)
                  CALL POP(J)
                  CALL POP(K)
                  RES = K + J
                  PRINT 120, K, J, RES
                  CALL PUSH(RES)
               CASE ('minus','Minus','MINUS','-')   !! SUBSTRACT        (6)
                  CALL POP(J)
                  CALL POP(K)
                  RES = K - J
                  PRINT 130, K, J, RES
                  CALL PUSH(RES)
               CASE DEFAULT !! NUMBER TO STACK  (7)
                  !
                  DATL = LEN_TRIM(INPDAT)
                  !
                  RES = 0
                  DO I = DATL, 1, -1
                     NUM = IACHAR(INPDAT(I:I)) - 48
                     RES = RES + NUM*10**(DATL-I)
                  ENDDO
                  !
                  PRINT 110, RES
                  CALL PUSH(RES)
               END SELECT
               !
            ENDDO inloop
            !
          100 FORMAT(A10)
          110 FORMAT(1X, I10)
          120 FORMAT(1X, I10,' + ', I10,' = ', I20)
          130 FORMAT(1X, I10,' - ', I10,' = ', I20)
          END PROGRAM RPN_CALC

10.3.4. `excode_10_2_mod.f90'
-----------------------------

          MODULE Stack
            !
            ! MODULE THAT DEFINES A BASIC STACK
            !
            IMPLICIT NONE
            !
            SAVE
            !
            INTEGER, PARAMETER :: STACK_SIZE = 500
            INTEGER, DIMENSION(STACK_SIZE) :: STORE = 0
            INTEGER :: STACK_POS = 0
            !
            PRIVATE :: STORE, STACK_POS, STACK_SIZE
            PUBLIC :: POP, PUSH
            !
            CONTAINS
              !
              SUBROUTINE PUSH(I)
                !
                INTEGER, INTENT(IN) :: I
                !
                IF (STACK_POS < STACK_SIZE) THEN
                   !
                   STACK_POS = STACK_POS + 1; STORE(STACK_POS) = I
                   !
                ELSE
                   !
                   STOP "FULL STACK ERROR"
                   !
                ENDIF
                !
              END SUBROUTINE PUSH
          !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
              SUBROUTINE POP(I)
                !
                INTEGER, INTENT(OUT) :: I
                !
                IF (STACK_POS > 0) THEN
                   !
                   I = STORE(STACK_POS); STACK_POS = STACK_POS - 1
                   !
                ELSE
                   !
                   STOP "EMPTY STACK ERROR"
                   !
                ENDIF
                !
              END SUBROUTINE POP
              !
          END MODULE Stack


-------------------------------------------------------------------------------


11. Subprogramas (IV)
---------------------


11.1. Objetivos
---------------

     Los objetivos de esta clase son los siguientes:

     1.   Explicar como se deben gestionar los errores en la invocación de
          funciones y subrutinas.

     2.   Explicar como se pasa el nombre de una función o subrutina como
          argumento declarando las funciones o subrutinas implicadas con el
          atributo `EXTERNAL'.

     3.   Explicar como se pasa el nombre de una función o subrutina como
          argumento declarando las funciones o subrutinas en un módulo.


11.2. Puntos destacables.
-------------------------

     1.   Se debe evitar que un programa termine sin que una subprograma
          (función o subrutina) devuelva el control al programa que lo ha
          invocado.  Por ello se debe no usar la orden `STOP' en el
          interior de subprogramas.  La mejor forma de gestionar errores en
          una subrutina, sobre todo aquellos debidos a una incorrecta
          definición de los argumentos de entrada de la subrutina, es
          mediante el uso de varibles _flag_ (bandera) que marquen que ha
          tenido lugar un error.  En el siguiente ejemplo se calcula la
          raíz cuadrada de la diferencia entre dos números, y la variable
          `sta_flag' es cero si la subrutina se ejecuta sin problemas o uno
          si se trata de calcular la raíz cuadrada de un número negativo.

               SUBROUTINE calc(a_1, a_2, result, sta_flag)
                  IMPLICIT NONE
                  REAL, INTENT(IN) :: a_1, a_2
                  REAL, INTENT(OUT) :: result
                  INTEGER, INTENT(OUT) :: sta_flag
                  !
                  REAL :: temp
                  !
                  temp = a_1 - a_2
                  IF (temp >= 0) THEN
                     result = SQRT(temp)
                     sta_flag = 0
                  ELSE
                     result = 0.0
                     sta_flag = 1
                  ENDIF
               END SUBROUTINE calc

          Una vez ejecutada la subrutina se debe comprobar el valor de la
          variable `sta_flag' para informar si ha existido algún problema.

     2.   Al invocar una subrutina los argumentos pasan como una serie de
          punteros a ciertas posiciones de memoria.  Eso permite que como
          argumento figure una función o subrutina.

     3.   En el caso de funciones, cuando se incluye el nombre de una
          función en la lista de argumentos se transforma en un puntero a
          dicha función.  Para ello las funciones han de ser declaradas con
          el atributo `EXTERNAL'.  Si, por ejemplo, desde un programa
          llamamos a una subrutina llamada `evaluate_func' para evaluar las
          funciones `fun_1' y `fun_2' podemos hacer algo como

               PROGRAM test
                 IMPLICIT NONE
                 REAL :: fun_1, fun_2
                 EXTERNAL fun_1, fun_2
                 REAL :: x, y, output
               
                 ......
               
                 CALL evaluate_func(fun_1, x, y, output)
                 CALL evaluate_func(fun_2, x, y, output)
               
                 ......
               
               END PROGRAM test
               
               SUBROUTINE evaluate_func(fun, a, b, out)
                  REAL, EXTERNAL :: fun
                  REAL, INTENT(IN) :: a, b
                  REAL, INTENT(OUT) :: out
                  !
                  out = fun(a,b)
               END SUBROUTINE evaluate_func

          En el Section 11.3.1, `Programa ejemplo_11_1.f90' se muestra un
          ejemplo en el que se evalua, dependiendo de la elección del
          usuario, el producto o el cociente entre dos números.
          Dependiendo de la elección se utiliza la subrutina `Eval_Func',
          que acepta como uno de sus argumentos el nombre de la función que
          se va a evaluar, `prod_func' o `quot_func'.  Debe indicarse el
          tipo de variable asociado a la función, pero no se puede
          especificar el atributo `INTENT'.

     4.   También pueden usarse nombres de subrutinas como argumentos.
          Para pasar el nombre de una subrutina como argumento dicha
          subrutina debe ser declarada con el atributo EXTERNAL.  En el
          siguiente ejemplo una subrutina llamada `launch_sub' acepta como
          argumentos de entrada las variables `x_1' y `x_2' y el nombre de
          una subrutina a la que invoca con las variables anteriores como
          argumentos y tiene como argumento de salida la variable `result'.

               SUBROUTINE launch_sub(x_1, x_2, sub_name, result)
                 IMPLICIT NONE
                 REAL, INTENT(IN) :: x_1, x_2
                 EXTERNAL sub_name
                 REAL, INTENT(OUT) :: result
               
               
                 ......
               
                 CALL sub_name(x_1, x_2, result)
               
                 ......
               
               END SUBROUTINE launch_sub

          Como puede verse en este ejemplo, el argumento que indica la
          subrutina (`sub_name') no lleva asociado el atributo `INTENT'.
          En el Section 11.3.2, `Programa ejemplo_11_2.f90' se muestra un
          ejemplo similar al anterior, en el que se evalua dependiendo de
          la elección del usuario el producto o el cociente entre dos
          números.  Dependiendo de la elección se utiliza la subrutina
          `Eval_Sub', que acepta como uno de sus argumentos el nombre de la
          subrutina que se va a evaluar, `prod_sub' o `quot_sub'.

     5.   En el Section 11.3.3, `Programa ejemplo_11_3.f90' se muestra un
          ejemplo algo más complejo en el que se evalua, dependiendo de la
          elección del usuario, una función entre tres posibles para un
          intervalo de la variable independiente.  En este caso las
          funciones se declaran como `EXTERNAL' y se utiliza una subrutina
          interna para la definición del vector de la variable
          independiente, de acuerdo con la dimensión que proporciona el
          usuario, y la subrutina `Eval_Func' que acepta como uno de sus
          argumentos el nombre de la función que se evalue mostrando los
          resultados en pantalla.

     6.   Es posible también comunicar a un subprograma el nombre de una
          función o una subrutina mediante el uso de módulos.  En el
          Section 11.3.4, `Programa ejemplo_11_4.f90' se muestra un
          programa similar al Section 11.3.3, `Programa ejemplo_11_3.f90'
          utilizando módulos.  El módulo `Functions_11_4' debe compilarse
          en un fichero separado al del programa principal.  Si, por
          ejemplo el módulo se llama `ejemplo_11_4_mod.f90' y el programa
          principal `ejemplo_11_4.f90' el procedimiento sería el siguiente

               $ gfortran -c ejemplo_11_4_mod.f90
               $ gfortran ejemplo_11_4.f90 ejemplo_11_4_mod.o

          Como ocurría en el caso anterior, el o los argumentos que indican
          funciones o subrutinas no llevan el atributo `INTENT'.


11.3. Programas usados como ejemplo.
------------------------------------

11.3.1. Programa ejemplo_11_1.f90
---------------------------------

PROGRAM func_option
  !
  ! Select between funs to compute the product of the quotient of two quantities
  !
  IMPLICIT NONE
  !
  !
  REAL :: X_1, X_2
  INTEGER :: I_fun
  INTEGER :: I_exit
  !
  REAL, EXTERNAL :: prod_fun, quot_fun
  !
  I_exit = 1
  !
  DO WHILE (I_exit /= 0)
     !
     PRINT*, "X_1, X_2?"
     READ(UNIT = *, FMT = *) X_1, X_2
     !
     PRINT*, "function 1 = X_1 * X_2, 2 = X_1/X_2 ? (0 = exit)"
     READ(UNIT = *, FMT = *) I_fun
     !
     SELECT CASE (I_fun)
        !
     CASE (0)
        I_exit = 1
     CASE (1)
        CALL Eval_func(prod_fun, X_1, X_2)
     CASE (2)
        CALL Eval_func(quot_fun, X_1, X_2)
     CASE DEFAULT
        PRINT*, "Valid options : 0, 1, 2"
        !
     END SELECT
     !
     PRINT*, "Continue? (0 = exit)"
     READ(UNIT=*, FMT = *) I_exit
     !
     !
  ENDDO
  !
END PROGRAM func_option
!
SUBROUTINE Eval_Func(fun, X_1, X_2)
  !
  IMPLICIT NONE
  !
  REAL, INTENT(IN) :: X_1, X_2
  REAL, EXTERNAL :: fun
  !
  PRINT 10, fun(X_1, X_2)
  !
  10 FORMAT(1X, ES16.8)
  !
END SUBROUTINE Eval_Func
!
!
FUNCTION prod_fun(x1, x2)
  !
  IMPLICIT  NONE
  !
  REAL, INTENT(IN) :: x1, x2
  !
  REAL prod_fun
  !
  prod_fun = x1*x2
  !
END FUNCTION prod_fun
!
FUNCTION quot_fun(x1, x2)
  !
  IMPLICIT  NONE
  !
  REAL, INTENT(IN) :: x1, x2
  !
  REAL quot_fun
  !
  quot_fun = x1/x2
  !
END FUNCTION quot_fun

11.3.2. Programa ejemplo_11_2.f90
---------------------------------

PROGRAM sub_option
  !
  ! Select between subs to compute the product or the quotient of two quantities
  !
  IMPLICIT NONE
  !
  !
  REAL :: X_1, X_2
  INTEGER :: I_sub
  INTEGER :: I_exit
  !
  EXTERNAL :: prod_sub, quot_sub
  !
  I_exit = 1
  !
  DO WHILE (I_exit /= 0)
     !
     PRINT*, "X_1, X_2?"
     READ(UNIT = *, FMT = *) X_1, X_2
     !
     PRINT*, "function 1 = X_1 * X_2, 2 = X_1/X_2 ? (0 = exit)"
     READ(UNIT = *, FMT = *) I_sub
     !
     SELECT CASE (I_sub)
        !
     CASE (0)
        I_exit = 0
     CASE (1)
        CALL Eval_Sub(prod_sub, X_1, X_2)
     CASE (2)
        CALL Eval_Sub(quot_sub, X_1, X_2)
     CASE DEFAULT
        PRINT*, "Valid options : 0, 1, 2"
        !
     END SELECT
     !
     PRINT*, "Continue? (0 = exit)"
     READ(UNIT=*, FMT = *) I_exit
     !
  ENDDO
  !
END PROGRAM sub_option
!
SUBROUTINE Eval_Sub(sub, X_1, X_2)
  !
  IMPLICIT NONE
  !
  EXTERNAL :: sub
  REAL, INTENT(IN) :: X_1, X_2
  !
  REAL :: res_sub
  !
  CALL sub(X_1, X_2, res_sub)
  PRINT 10, res_sub
  !
10 FORMAT(1X, ES16.8)
  !
END SUBROUTINE Eval_Sub
!
!
SUBROUTINE prod_sub(x1, x2, y)
  !
  IMPLICIT  NONE
  !
  REAL, INTENT(IN) :: x1, x2
  REAL, INTENT(OUT) :: y
  !
  y = x1*x2
  !
END SUBROUTINE prod_sub
!
!
SUBROUTINE quot_sub(x1, x2, y)
  !
  IMPLICIT  NONE
  !
  REAL, INTENT(IN) :: x1, x2
  REAL, INTENT(OUT) :: y
  !
  y = x1/x2
  !
END SUBROUTINE quot_sub

11.3.3. Programa ejemplo_11_3.f90
---------------------------------

PROGRAM call_func
  !
  ! Select which curve is computed and saved in a given interval e.g. (-2 Pi, 2 Pi)
  !
  ! 1 ---> 10 x^2 cos(2x) exp(-x)
  ! 2 ---> 10 (-x^2 + x^4)exp(-x^2)
  ! 3 ---> 10 (-x^2 + cos(x)*x^4)exp(-x^2)
  !
  IMPLICIT NONE
  !
  !
  REAL, DIMENSION(:), ALLOCATABLE :: X_grid
  !
  REAL, PARAMETER :: pi = ACOS(-1.0)
  !
  REAL :: X_min, X_max, Delta_X
  INTEGER :: X_dim, I_fun
  INTEGER :: I_exit, Ierr
  !
  REAL, EXTERNAL :: fun1, fun2, fun3
  !
  X_min = -2*pi
  X_max = 2*pi
  !
  I_exit = 0
  !
  DO WHILE (I_exit /= 1)
     !
     PRINT*, "number of points? (0 = exit)"
     READ(UNIT=*, FMT = *) X_dim
     !
     IF (X_dim == 0) THEN
        !
        I_exit = 1
        !
     ELSE
        ALLOCATE(X_grid(1:X_dim), STAT = Ierr)
        IF (Ierr /= 0) THEN
           STOP 'X_grid allocation failed'
        ENDIF
        !
        CALL make_Grid(X_min, X_max, X_dim)
        !
        PRINT*, "function 1, 2, or 3? (0 = exit)"
        READ(UNIT = *, FMT = *) I_fun
        !
        SELECT CASE (I_fun)
           !
        CASE (0)
           I_exit = 1
        CASE (1)
           CALL Eval_func(fun1, X_dim, X_grid)
        CASE (2)
           CALL Eval_func(fun2, X_dim, X_grid)
        CASE (3)
           CALL Eval_func(fun3, X_dim, X_grid)
        CASE DEFAULT
           PRINT*, "Valid options : 0, 1, 2, 3"
           !
        END SELECT
        !
        DEALLOCATE(X_grid, STAT = Ierr)
        IF (Ierr /= 0) THEN
           STOP 'X_grid deallocation failed'
        ENDIF
        !
     ENDIF
     !
  ENDDO
  !
CONTAINS
  !
  SUBROUTINE make_Grid(X_min, X_max, X_dim)
    !
    REAL, INTENT(IN) :: X_min, X_max
    INTEGER, INTENT(IN) :: X_dim
    !
    INTEGER :: Index
    REAL :: Delta_X
    !
    !
    Delta_X = (X_max - X_min)/REAL(X_dim - 1)
    !
    X_grid = (/ (Index, Index = 0 , X_dim - 1 ) /)
    X_grid = X_min + Delta_X*X_grid
    !
  END SUBROUTINE make_Grid
  !
END PROGRAM call_func
!
SUBROUTINE Eval_Func(fun, dim, X_grid)
  !
  IMPLICIT NONE
  !
  INTEGER, INTENT(IN) :: dim
  REAL, DIMENSION(dim), INTENT(IN) :: X_grid
  REAL, EXTERNAL :: fun
  !
  INTEGER :: Index
  !
  DO Index = 1, dim
     PRINT 10, X_grid(Index), fun(X_grid(Index))
  ENDDO
  !
  10 FORMAT(1X, ES16.8,2X, ES16.8)
  !
END SUBROUTINE Eval_Func
!
!
FUNCTION fun1(x)
  !
  IMPLICIT  NONE
  !
  REAL, INTENT(IN) :: x
  !
  REAL fun1
  !
  fun1 = 10.0*x**2*cos(2.0*x)*exp(-x)
  !
END FUNCTION fun1
!
FUNCTION fun2(x)
  !
  IMPLICIT  NONE
  !
  REAL, INTENT(IN) :: x
  !
  REAL fun2
  !
  fun2 = 10.0*(-x**2 + x**4)*exp(-x**2)
  !
END FUNCTION fun2
!
FUNCTION fun3(x)
  !
  IMPLICIT  NONE
  !
  REAL, INTENT(IN) :: x
  !
  REAL fun3
  !
  fun3 = 10.0*(-x**2 + cos(x)*x**4)*exp(-x**2)
  !
END FUNCTION fun3

11.3.4. Programa ejemplo_11_4.f90
---------------------------------

PROGRAM call_func
  !
  ! Select which curve is computed and saved in a given interval e.g. (-2 Pi, 2 Pi)
  !
  ! 1 ---> 10 x^2 cos(2x) exp(-x)
  ! 2 ---> 10 (-x^2 + x^4)exp(-x^2)
  ! 3 ---> 10 (-x^2 + cos(x)*x^4)exp(-x^2)
  !
  USE Functions_11_4
  !
  IMPLICIT NONE
  !
  !
  REAL, DIMENSION(:), ALLOCATABLE :: X_grid
  !
  REAL, PARAMETER :: pi = ACOS(-1.0)
  !
  REAL :: X_min, X_max, Delta_X
  INTEGER :: X_dim, I_fun
  INTEGER :: I_exit, Ierr
  !
  X_min = -2*pi
  X_max = 2*pi
  !
  I_exit = 0
  !
  DO WHILE (I_exit /= 1)
     !
     PRINT*, "number of points? (0 = exit)"
     READ(UNIT=*, FMT = *) X_dim
     !
     IF (X_dim == 0) THEN
        !
        I_exit = 1
        !
     ELSE
        ALLOCATE(X_grid(1:X_dim), STAT = Ierr)
        IF (Ierr /= 0) THEN
           STOP 'X_grid allocation failed'
        ENDIF
        !
        CALL make_Grid(X_min, X_max, X_dim)
        !
        PRINT*, "function 1, 2, or 3? (0 = exit)"
        READ(UNIT = *, FMT = *) I_fun
        !
        SELECT CASE (I_fun)
           !
        CASE (0)
           I_exit = 1
        CASE (1)
           CALL Eval_func(fun1, X_dim, X_grid)
        CASE (2)
           CALL Eval_func(fun2, X_dim, X_grid)
        CASE (3)
           CALL Eval_func(fun3, X_dim, X_grid)
        CASE DEFAULT
           PRINT*, "Valid options : 0, 1, 2, 3"
           !
        END SELECT
        !
        DEALLOCATE(X_grid, STAT = Ierr)
        IF (Ierr /= 0) THEN
           STOP 'X_grid deallocation failed'
        ENDIF
        !
     ENDIF
     !
  ENDDO
  !
CONTAINS
  !
  SUBROUTINE make_Grid(X_min, X_max, X_dim)
    !
    REAL, INTENT(IN) :: X_min, X_max
    INTEGER, INTENT(IN) :: X_dim
    !
    INTEGER :: Index
    REAL :: Delta_X
    !
    !
    Delta_X = (X_max - X_min)/REAL(X_dim - 1)
    !
    X_grid = (/ (Index, Index = 0 , X_dim - 1 ) /)
    X_grid = X_min + Delta_X*X_grid
    !
  END SUBROUTINE make_Grid
  !
END PROGRAM call_func
!
SUBROUTINE Eval_Func(fun, dim, X_grid)
  !
  USE Functions_11_4
  !
  IMPLICIT NONE
  !
  REAL :: fun
  INTEGER, INTENT(IN) :: dim
  REAL, DIMENSION(dim), INTENT(IN) :: X_grid
  !
  INTEGER :: Index
  !
  DO Index = 1, dim
     PRINT 10, X_grid(Index), fun(X_grid(Index))
  ENDDO
  !
  10 FORMAT(1X, ES16.8,2X, ES16.8)
  !
END SUBROUTINE Eval_Func
!
MODULE Functions_11_4
  IMPLICIT NONE
  !
CONTAINS
  !
  !
  FUNCTION fun1(x)
    !
    IMPLICIT  NONE
    !
    REAL, INTENT(IN) :: x
    !
    REAL fun1
    !
    fun1 = 10.0*x**2*cos(2.0*x)*exp(-x)
    !
  END FUNCTION fun1
  !
  FUNCTION fun2(x)
    !
    IMPLICIT  NONE
    !
    REAL, INTENT(IN) :: x
    !
    REAL fun2
    !
    fun2 = 10.0*(-x**2 + x**4)*exp(-x**2)
    !
  END FUNCTION fun2
  !
  FUNCTION fun3(x)
    !
    IMPLICIT  NONE
    !
    REAL, INTENT(IN) :: x
    !
    REAL fun3
    !
    fun3 = 10.0*(-x**2 + cos(x)*x**4)*exp(-x**2)
    !
  END FUNCTION fun3
END MODULE Functions_11_4


-------------------------------------------------------------------------------


12. Instalación y uso de las bibliotecas `BLAS' y `LAPACK'
----------------------------------------------------------


12.1. Objetivos
---------------

     Los objetivos de esta clase son los siguientes:

     1.   familiarizar el alumno con la compilación de programas y la
          instalación de librerias o biliotecas usando el compilador
          `gfortran'.

     2.   Instalar las bibliotecas de interés científico `BLAS' y `LAPACK'.

     3.   Aprender a hacer uso de dichas bibliotecas.

     Existe una gran cantidad de código `Fortran' accesible de forma
     abierta, ya sea como código fuente o en forma de biblioteca.  En la
     presente clase el alumno se familiariza con la obtención, compilación,
     instalación y uso de dos bibliotecas de subrutinas de interés
     algebraico, `BLAS' y `LAPACK'.


12.2. Puntos destacables.
-------------------------

     Indicaremos de forma escalonada los diferentes pasos que hay que
     seguir para la instalación de estas bibliotecas.

     El código fuente de las bibliotecas `BLAS' y `LAPACK' puede
     descargarse de diferentes lugares, o instalarse a partir de paquetes
     de la distribución `Debian' o `Ubuntu' que se esté utilizando.  En vez
     de ello las instalaremos compilándolas en nuestro ordenador.

        * Descarga de código fuente de la biblioteca `BLAS'.

          Se puede descargar de la web de `NETLIB'[1], usando este enlace
          BLAS tgz (Netlib) (http://www.netlib.org/blas/blas.tgz).

        * Una vez descargado el código fuente, se descomprime, se compila y
          se crea finalmente la libreria.

               tar xzf blas.tgz
               cd BLAS
               gfortran -O2 -c *.f
               ar cr libblas.a *.o

          Con lo que se debe haber creado la librería estática `libblas.a'.

        * A continuación se sitúa dicha libreria en un lugar apropiado, por
          ejemplo con

               sudo cp libblas.a /usr/local/lib

          y se comprueba que tiene los permisos adecuados.

        * Descarga del código fuente de la biblioteca `LAPACK'.

          Se puede descargar también de la web de `NETLIB' usando este
          enlace LAPACK tgz (Netlib)
          (http://www.netlib.org/lapack/lapack.tgz).  Tras su descarga se
          desempaquetan los ficheros.

               tar xzf lapack.tgz
               cd lapack-3.2.1

        * Esta biblioteca si tiene una serie de ficheros `makefile' para su
          compilación.  Hemos de preparar un fichero `make.inc' adecuado,
          como el que hemos incluido en Section 12.3.1, `Ejemplo de fichero
          `make.inc' para `LAPACK'' y que está disponible en `Moodle' en un
          fichero llamado make.inc.lapack.ubuntu
          (http://moodle.uhu.es/contenidos/file.php/245/src_fortran_clase/make.inc.lapack.ubuntu).

          Usando este fichero compilamos la librería haciendo

               make

        * Por último, instalamos la librería copiando los ficheros creados
          al lugar que creamos más adecuado para su ubicación.

               sudo cp lapack_LINUX.a /usr/local/lib
               sudo cp tmglib_LINUX.a /usr/local/lib

        * Para terminar descargamos el código fuente de la biblioteca
          `LAPACK95'.

          Se puede descargar también de la web de `NETLIB' usando el enlace
          LAPACK95 tgz (Netlib)
          (http://www.netlib.org/lapack95/lapack95.tgz).  Tras su descarga
          se desempaquetan los ficheros.

               tar xzf lapack95.tgz
               cd LAPACK95

        * Esta biblioteca también tiene una serie de ficheros `makefile'
          para su compilación.  Hemos de preparar de nuevo un fichero
          `make.inc' adecuado, como el que hemos incluido en Section
          12.3.2, `Ejemplo de fichero `make.inc' para `LAPACK95'' y que
          está disponible en `Moodle' en un fichero llamado
          make.inc.lapack95.ubuntu
          (http://moodle.uhu.es/contenidos/file.php/245/src_fortran_clase/make.inc.lapack95.ubuntu).

          Usando este fichero compilamos la librería haciendo

               cd SRC
               make single_double_complex_dcomplex

          La opción escogida es la más general, pues general la librería
          para precisión simple, doble, compleja simple y compleja doble.

        * Por último, instalamos la librería copiando los ficheros creados
          al lugar que creamos más adecuado para su ubicación.

               sudo cp lapack95.a /usr/local/lib
               sudo cp -r lapack95_modules /usr/local/lib

        * En los directorios de ejemplos (`LAPACK95/EXAMPLES1' y
          `LAPACK95/EXAMPLES2') encontramos un gran número de ejemplos que
          podemos correr y comprobar las salidas obtenidas con las que se
          encuentran en Lapack95 User's guide
          (http://www.netlib.org/lapack95/lug95/node1.html).  Las
          instrucciones para compilar y correr los ejemplos proporcionados
          pueden verse en el fichero `README' del directorio donde se
          encuentra el código fuente de los ejemplos.

        * En el ejemplo Section 12.3.3, `Ejemplo de programa que invoca
          `LAPACK95'' se encuentra el código de un programa donde se
          recurre a la subrutina `la_spsv' para hallar la solución de un
          sistema lineal de ecuaciones, _Ax = B_, donde la matriz del
          sistema, _A_, es simétrica y se almacena de forma compacta y _x_,
          _B_ son vectores.  Es importante que comprenda como funciona este
          programa, así como que se sepa extraer de la documentación de
          `LAPACK95' el significado de los argumentos de entrada y salida
          de la subrutina.

        * Para correr este programa es necesario descargar el código
          `ejemplo_la_spsv.f90' y los ficheros de datos `spsv.ma' y
          `spsv.mb' de la web del curso.  Para compilar el programa se
          ejecuta la orden

gfortran -o ejemplo_la_spsv -I/usr/local/lib/lapack95_modules ejemplo_la_spsv.f90  /usr/local/lib/lapack95.a /usr/local/lib/tmglib_LINUX.a /usr/local/lib/lapack_LINUX.a /usr/local/lib/libblas.a

          En esta orden de compilación se incluyen todas las librerías y
          módulos necesarios para que pueda crearse el ejecutable, haciendo
          uso de las librerías `BLAS', `LAPACK' y `LAPACK95' que hemos
          instalado.

        * Para proyectos más complejos y evitar tener que escribir comandos
          de compilación tan complejos como el anterior es posible usar un
          fichero `makefile' como el que se proporciona en el ejemplo
          Section 12.3.4, `Ejemplo de `makefile' para compilar programas
          que invocan `LAPACK95''.  Para usar este fichero en la
          compilación del ejemplo Section 12.3.3, `Ejemplo de programa que
          invoca `LAPACK95'' es preciso copiar el fichero proporcionado o
          descargar el fichero `makefile_lapack95' y ejecutar la orden

                make -f makefile_lapack95 ejemplo_la_spsv

[1]  El repositorio de `Netlib' contiene software gratuito, documentación y
     bases de datos de interés para la comunidad científica en general y
     para aquellos interesados en la computación científica en particular.
     El repositorio es mantenido por los Laboratorios AT&T-Bell, la
     Universidad de Tennessee y el laboratorio nacional de Oak Ridge, con
     la ayuda de un gran número de colaboradores en todo el mundo.  La web
     de `Netlib' es http://www.netlib.org.


12.3. Programas usados como ejemplo.
------------------------------------

12.3.1. Ejemplo de fichero `make.inc' para `LAPACK'
---------------------------------------------------

####################################################################
#  LAPACK make include file.                                       #
#  LAPACK, Version 3.2.1                                           #
#  MAY 2009                                                        #
#  Modified by Currix                                              #
####################################################################
#
SHELL = /bin/sh
#
#  The machine (platform) identifier to append to the library names
#
PLAT = _LINUX
#
#  Modify the FORTRAN and OPTS definitions to refer to the
#  compiler and desired compiler options for your machine.  NOOPT
#  refers to the compiler options desired when NO OPTIMIZATION is
#  selected.  Define LOADER and LOADOPTS to refer to the loader and
#  desired load options for your machine.
#
FORTRAN  = gfortran
OPTS     = -O2
DRVOPTS  = $(OPTS)
NOOPT    = -O0
LOADER   = gfortran
LOADOPTS =
#
# Timer for the SECOND and DSECND routines
#
# Default : SECOND and DSECND will use a call to the EXTERNAL FUNCTION ETIME
#TIMER    = EXT_ETIME
# For RS6K : SECOND and DSECND will use a call to the EXTERNAL FUNCTION ETIME_
# TIMER    = EXT_ETIME_
# For gfortran compiler: SECOND and DSECND will use a call to the INTERNAL FUNCTION ETIME
TIMER    = INT_ETIME
# If your Fortran compiler does not provide etime (like Nag Fortran Compiler, etc...)
# SECOND and DSECND will use a call to the INTERNAL FUNCTION CPU_TIME
# TIMER    = INT_CPU_TIME
# If neither of this works...you can use the NONE value... In that case, SECOND and DSECND will always return 0
# TIMER     = NONE
#
#  The archiver and the flag(s) to use when building archive (library)
#  If you system has no ranlib, set RANLIB = echo.
#
ARCH     = ar
ARCHFLAGS= cr
RANLIB   = ranlib
#
#  Location of the extended-precision BLAS (XBLAS) Fortran library
#  used for building and testing extended-precision routines.  The
#  relevant routines will be compiled and XBLAS will be linked only if
#  USEXBLAS is defined.
#
# USEXBLAS    = Yes
XBLASLIB     =
# XBLASLIB    = -lxblas
#
#  The location of the libraries to which you will link.  (The
#  machine-specific, optimized BLAS library should be used whenever
#  possible.)
#
#BLASLIB      = ../../blas$(PLAT).a
BLASLIB      = /usr/local/lib/libblas.a
LAPACKLIB    = lapack$(PLAT).a
TMGLIB       = tmglib$(PLAT).a
EIGSRCLIB    = eigsrc$(PLAT).a
LINSRCLIB    = linsrc$(PLAT).a

12.3.2. Ejemplo de fichero `make.inc' para `LAPACK95'
-----------------------------------------------------

          #
          #  -- LAPACK95 interface driver routine (version 2.0) --
          #     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
          #     August 5, 2000
          #
          FC	 = gfortran
          FC1      = gfortran
          # -dcfuns  Enable recognition of non-standard double
          #          precision  complex intrinsic functions
          # -dusty   Allows the compilation and execution of "legacy"
          #          software by downgrading the category  of  common
          #          errors  found  in  such software from "Error" to
          # -ieee=full enables all IEEE arithmetic facilities
          #          including non-stop arithmetic.
          
          OPTS0    = -u -V -dcfuns -dusty -ieee=full
          MODLIB   = -I./../lapack95_modules
          OPTS1    = -c $(OPTS0)
          OPTS3    = $(OPTS1) $(MODLIB)
          OPTL     = -o
          OPTLIB   =
          
          LAPACK_PATH = /usr/local/lib/
          
          LAPACK95 = ../lapack95.a
          LAPACK77 = $(LAPACK_PATH)/lapack_LINUX.a
          TMG77    = $(LAPACK_PATH)/tmglib_LINUX.a
          BLAS     = $(LAPACK_PATH)/libblas.a
          
          LIBS     = $(LAPACK95) $(TMG77) $(LAPACK77) $(BLAS)
          SUF      = f90
          
          XX = 'rm' -f $@; \
                  'rm' -f $@.res; \
          	$(FC) $(OPTS0) -o $@ $(MODLIB) $@.$(SUF) $(OPTLIB) $(LIBS); \
                  $@ < $@.dat > $@.res; \
                  'rm' -f $@
          
          YY = $(FC) $(OPTS0) -o $@ $(MODLIB) $@.$(SUF) $(OPTLIB) $(LIBS)
          
          .SUFFIXES: .f90 .f .o
          
          .$(SUF).o:
          	$(FC) $(OPTS3) $<
          
          .f.o:
          	$(FC1) $(OPTS3) $<

12.3.3. Ejemplo de programa que invoca `LAPACK95'
-------------------------------------------------

          PROGRAM LA_SSPSV_EXAMPLE
          
            !  -- LAPACK95 EXAMPLE DRIVER ROUTINE (VERSION 1.0) --
            !     UNI-C, DENMARK
            !     DECEMBER, 1999
            !
            !  .. "Use Statements"
            USE LA_PRECISION, ONLY: WP => SP
            USE F95_LAPACK, ONLY: LA_SPSV
            !  .. "Implicit Statement" ..
            IMPLICIT NONE
            !  .. "Local Scalars" ..
            INTEGER :: I, N, NN, NRHS
            !  .. "Local Arrays" ..
            INTEGER, ALLOCATABLE :: IPIV(:)
            REAL(WP), ALLOCATABLE :: B(:,:), AP(:)
            !  .. "Executable Statements" ..
            WRITE (*,*) 'SSPSV Example Program Results.'
            N = 5; NRHS = 1
            WRITE(*,'(5H N = , I4, 9H; NRHS = , I4)') N, NRHS
            NN = N*(N+1)/2
            ALLOCATE ( AP(NN), B(N,NRHS), IPIV(N) )
            !
            OPEN(UNIT=21,FILE='spsv.ma',STATUS='UNKNOWN')
            DO I=1,NN
               READ(21,'(F3.0)') AP(I)
            ENDDO
            CLOSE(21)
            !
            WRITE(*,*)'Matrix AP :'
            DO I=1,NN; WRITE(*,"(15(I3,1X,1X),I3,1X))") INT(AP(I));
            ENDDO
            !
            OPEN(UNIT=21,FILE='spsv.mb',STATUS='UNKNOWN')
            DO I=1,N
               READ(21,'(F3.0)') B(I,1)
            ENDDO
            CLOSE(21)
            !
            WRITE(*,*)'Matrix B :'
            DO I=1,N; WRITE(*,"(10(I3,1X,1X),I3,1X)')") INT(B(I,1));
            ENDDO
            !
            WRITE(*,*)" CALL LA_SPSV( AP, B, 'L', IPIV )"
            !
            CALL LA_SPSV( AP, B, 'L', IPIV )
            !
            WRITE(*,*)'AP on exit: '
            DO I=1,NN; WRITE(*,"(15(E13.5))") AP(I);
            ENDDO
            !
            WRITE(*,*)'Matrix B on exit :'
            DO I=1,N; WRITE(*,"(F9.5)") B(I,1);
            ENDDO
            WRITE(*,*)'IPIV = ', IPIV
            !
          END PROGRAM LA_SSPSV_EXAMPLE

12.3.4. Ejemplo de `makefile' para compilar programas que invocan
`LAPACK95'
----------------------------------------------------------------------------

          #
          #  -- LAPACK95 makefile (version 1.0) --
          #
          FC	 = gfortran
          #
          MODLIB   = -I/usr/local/lib/lapack95_modules
          OPTS1    = -c
          OPTS3    = $(OPTS1) $(MODLIB)
          OPTL     = -o
          OPTLIB   =
          
          LAPACK_PATH = /usr/local/lib
          LAPACK95_PATH = /usr/local/lib
          
          LAPACK95 = $(LAPACK95_PATH)/lapack95.a
          LAPACK77 = $(LAPACK_PATH)/lapack_LINUX.a
          TMG77    = $(LAPACK_PATH)/tmglib_LINUX.a
          BLAS     = $(LAPACK_PATH)/libblas.a
          
          LIBS     = $(LAPACK95) $(TMG77) $(LAPACK77) $(BLAS)
          SUF      = f90
          
          YY = $(FC) -o $@ $(MODLIB) $@.$(SUF) $(OPTLIB) $(LIBS)
          
          .SUFFIXES: .f90 .f .o
          
          .$(SUF).o:
          	$(FC) $(OPTS3) $<
          
          ejemplo_la_spsv:
          	$(YY)
          
          clean:
          	'rm' -f *.o *.mod core


-------------------------------------------------------------------------------


13. Referencias
---------------

     1.   Stephen J.  Chapman; _Fortran 95/2003 for Scientists and
          Engineers_, 3a Ed.  Mc Graw Hill 2008.

     2.   Michael Metcalf, John Reid, and Malcolm Cohen; _Modern Fortran
          Explained_, Oxford University Press 2011.

     3.   Jeanne C.  Adams _et al._; _Fortran 95 Handbook_, MIT Press 1997.

     4.   Ian D.  Chivers and Jane Sleightholme; _Introduction to
          Programming with Fortran_, Springer 2006.

     5.   An Interactive Fortran 90 Programming Course
          (http://www.liv.ac.uk/HPC/HTMLFrontPageF90.html)

     6.   gfortran: The GNU Fortran compiler
          (http://gcc.gnu.org/onlinedocs/gfortran)

     7.   Gfortran - GCC Wiki (http://gcc.gnu.org/wiki/GFortran)

     8.   USER NOTES ON FORTRAN PROGRAMMING (UNFP)
          (http://sunsite.informatik.rwth-aachen.de/fortran/)

     9.   Fortran 90 Tutoria by Michael Metcalf
          (http://wwwasdoc.web.cern.ch/wwwasdoc/WWW/f90/f90.html)


-------------------------------------------------------------------------------


     `Fortran 90' Lessons for Computational Chemistry

     Curro Pérez-Bernal <francisco.perez@dfaie.uhu.es>


     0.0

