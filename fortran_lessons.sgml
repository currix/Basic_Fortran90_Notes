<!doctype debiandoc public "-//DebianDoc//DTD DebianDoc//EN">
<!--<!doctype debiandoc system>-->

<book>

<title><prgn>Fortran 90</prgn> Lessons for Computational Chemistry</title>

<author>Curro Pérez-Bernal
<email>francisco.perez@dfaie.uhu.es</email>
</author>

<version>0.0</version>

<abstract>The present document is a basic introduction to
  the  <prgn>Fortran</prgn> programming language based in several textbooks and
  references (see <ref id="cap_ref">). It contains the basic scheme
  of <prgn>Fortran</prgn> programming taught in
  the  <em>Computational Chemistry</em> module (fourth year, second
  semester) of the University of Huelva Chemistry Degree.
</abstract>

<toc>

<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!--                         Clase 1                         -->
<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->


<chapt id="clase_1"><heading>Introduction</heading> 
<sect id="sec_11"> Objectives

<p>
The main aims of this session consist of:

<enumlist>  
<item> giving a short introduction on programming and programming languages.
<item> emphasize the importance of a clear understanding of the
  problem under study and the use of flow diagrams for achieving
  structured and clear source code.
<item> a brief presentation of the main features of
  the <prgn>Fortran</prgn> programming language.
<item> installation of the <tt>GNU Fortran</tt> compiler, <prgn>gfortran</prgn>.
<item> Studying two simple codes.
<item> Presenting possible sources of information for the interested  student.
</enumlist>  

</sect>

<sect id="sec_12"> Main items.

<p>
By default we will use the <prgn>emacs</prgn> text editor. The first
examples are the simple programs  <ref id="sec_p_1_1"> y <ref id="sec_p_1_2">.

<p>
Using the examples the student should be aware of the main sections
included in a program::

<enumlist>  
<item> Head of the code with the statement <tt>PROGRAM</tt> <var>program_name</var>.
<item> Variable definition.
<item> Main program body, including <tt>I/O</tt> operations.
<item> End of the program: <tt>END PROGRAM</tt> <var>program_name</var>.
</enumlist>  

Things to take into account:
<list>  
<item>  Importance of remarks and comments. Include many comments in
  your code, trying to be as clear as possible. <prgn>Fortran</prgn>
  remarks are introduced with the character <tt>!</tt>. A correct
  indentation also improves the code
  readability. The <prgn>emacs</prgn> text editor greatly helps in this task. 
<item> The importance of the <tt>IMPLICIT NONE</tt> statement. Declare
  and initialize properly all variables as in example <ref id="sec_p_1_2">.
<item> Distinguish the  <tt>I/O</tt> operations.
</list>  


</sect>
<sect id="sec_13">  Example Codes.

  <sect1 id="sec_p_1_1">  <tt>excode_1_1.f90</tt>
<p>
<example>
PROGRAM ex_1_1
  !
  ! This program reads and displays a string.
  !
  IMPLICIT NONE
  CHARACTER(LEN=50) :: Name
  !
  PRINT *,' Write your name. Do not forget quoting it:'
  PRINT *,' (max 50 characters)'
  READ(*,*), Name
  PRINT *, Name
  !
END PROGRAM ex_1_1
</example>
</sect1>
  <sect1 id="sec_p_1_2">  <tt>excode_1_2.f90</tt>
<p>
<example>
PROGRAM ex_1_2
  !
  ! This program reads three numbers and compute their sum and mean value 
  !
  IMPLICIT NONE
  REAL :: N1, N2, N3, Average = 0.0, Total = 0.0
  INTEGER :: N = 3
  PRINT *,' Input three numbers (return, coma, or space separated).'
  PRINT *,' '
  READ *,N1,N2,N3
  Total =  N1 + N2 + N3
  Average = Total/N
  PRINT *,'Sum: ',Total
  PRINT *,'Mean value: ',Average
END PROGRAM ex_1_2
</example>
</sect1>
</sect>
</chapt>


<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!--                         Clase 2                         -->
<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<chapt id="clase_2"><heading>Basic Operations</heading> 
<sect id="sec_21"> Objectives


<p>
The main aims of this session are:

<enumlist>  
<item> introducing basic <prgn>Fortran</prgn> syntax rules and the
  characters allowed in source files.
<item> Basic arithmetic operations and operator precedence rules. 
<item> The  <tt>PARAMETER</tt> declaration.
<item> Explain the different kinds of numerical variables and its use.
</enumlist>  

</sect>

<sect id="sec_22"> Main items.
<p>
Basic syntax rules:
<p>
<list>
<item> Maximum number of characters per line of code: 132.
<item> Maximum length of a variable name string: 31.
<item> '&amp;' denotes that the statement continues in the next
  line. It is added at the end of the broken line<footnote>Except if a
  string is broken in two lines. In this particular case it is added
  at the end of the broken line and the beginning of the next line.</footnote>
<item> '!' is the character that marks the rest of the line as a
  comment. 
<item> ';' is the character that separates several statements in the
  same line.
</list>

<p>
Variable names can include the low hyphen ('<tt>_</tt>') and mix
alphanumeric characters and digits, though variable names first
character cannot be a number.
<p>
<prgn>Fortran</prgn> character set:
<p>
<example>
A-Z  Letters              0-9  Digits
_    Underscore                Blank
=    Equal                +    Plus
-    Minus                *    Asterisk
/    Slash or oblique     '    Apostrophe
(    Left parenthesis     )    Right parenthesis
,    Comma                .    Period or decimal point
:    Colon                ;    Semicolon
!    Exclamation mark     ""    Quotation mark
%    Percent              &amp;   Ampersand
&lt;    Less than         &gt;   Greater than
</example>
<p>
Precedence of arithmetic operators:
<p>
<list>
<item> Operators: {<tt>+</tt>,<tt>-</tt>,<tt>*</tt>,<tt>/</tt>,<tt>**</tt>}.
<item> Precedence: (1) <tt>**</tt> (right to left);
  (2) <tt>*</tt>,<tt>/</tt> (compiler dependent);
  (3) <tt>+</tt>,<tt>-</tt>  (compiler dependent).
<item> Beware of floating point operations rounding, in particular
  when mixing different numeric variable types. Minimizing rounding
  errors is at times a complex and subtle task.

<p>
The compiler transform different type variables to a common type when
performing a calculation. The priority ordering, from lower to higher
is: <tt>INTEGER</tt>, <tt>REAL</tt>, <tt>DOUBLE PRECISION</tt>,
and <tt>COMPLEX</tt>. Therefore, an operation involving an integer and
a double precision float is performed transforming the integer value
to double precision and the result is given in double precision
too. The final result is the transformed to the type of the variable
to which is assigned.

<item> Integer types:
  <enumlist>
    <item>   32 bits ::<tt> (2**31)-1 =  2,147,483,647</tt> (~ 10**9)
    <item>   64 bits :: <tt>(2**63)-1 =  9,223,372,036,854,774,807</tt> (~ 10**19)
  </enumlist>
<item> Floats types and precision:
  <enumlist>
    <item>   Real 32 bits :: precision = 6-9 <tt>~ 0.3E­38 - 1.7E38</tt> 
    <item>   Real 64 bits :: precision = 15-18 <tt>~ 0.5E­308 - 0.8E308</tt> 
  </enumlist>
<item> Making use of the <tt>PARAMETER</tt> modifier in a variable
  definition we can define constant values in a program. See <ref id="sec_p_2_4">.

<item> (*) Different kinds of floats and integers
  in <prgn>Fortran</prgn> and the intrinsic
  functions<footnote>See <ref id="sec_p_2_4">.</footnote> <tt>KIND</tt>, <tt>EPSILON</tt>, <tt>PRECISION</tt>,
  and  <tt>HUGE</tt> and how to define a variable in each of the
  existing types.

  <p> <tt>INTEGER</tt> VARIABLES: if we would like to define an
    integer variable <tt>i0</tt> that could take values between
    -999999 y 999999 we should define a variable, called
    e.g. <tt>ki</tt>, making use of the intrinsic
    function <tt>SELECTED_INT_KIND()</tt> and make use of it in the
    variable definition.

<example>
INTEGER, PARAMETER :: ki =  SELECTED_INT_KIND(6)
INTEGER(KIND=ki) :: i0
</example>

<p>
The intrinsic function<footnote>More info on intrinsic functions and
    function definition in <prgn>Fortran</prgn> can be found in 
 <ref id="sec_81">.</footnote> <tt>SELECTED_INT_KIND(X)</tt> output is
an integer that indicates the type (<em>kind</em>) of an integer
variable capable of storing any integer in the range 
<tt>(-10E+X, 10E+X)</tt> where <tt>X</tt> is also an integer. If we
want that any integer constant in our program to be treated with a
particular type of integer this can be done as follows:
<p>
<example>
-1234_ki
2354_ki
2_ki
</example>

<p>
The error output of the  <tt>SELECTED_INT_KIND(X)</tt>
function is  <tt>-1</tt>. 

<p>
Real numbers are more involved. We make use a <em>floating point
    representation</em>, and all the following are valid real numbers in <prgn>Fortran</prgn>:

<p>
<example>
-10.66E-20
0.66E10
1.
-0.4
1.32D-44
2E-12
3.141592653
</example>

<p>
In this case the statement to control the type of float
is  <tt>SELECTED_REAL_KIND(p=X,r=Y)</tt>, with two input
parameters. The output is an integer associated with a float that
complies with the following rules:

<list>
<item> it has a precision at least equal to <tt>X</tt> and a range of
  decimal exponents given at least by <tt>Y</tt>. The argument labels
  are optional. 
<item> Among various possible results, the one with the minimum
  decimal precision will be chosen.
<item> At least one of the two input parameter should be
  specified. Both <tt>X</tt> and <tt>Y</tt> are integers. If there is
  no variable type that fulfills the requested condiotions the output
  of the function will be  <tt>-1</tt> if the  precision does not
  reach the requested level, <tt>-2</tt> if the problem is in the
  exponent, and <tt>-3</tt> if both requirements cannot be satisfied. 
</list>

<p>
  As an example, if we want to define a real variable
  called  <tt>a0</tt> with 15 digit precision and exponents in the range -306 to 307:
<p>
<example>
INTEGER, PARAMETER :: kr =  SELECTED_REAL_KIND(15,307)
REAL(KIND=kr) :: a0
</example>

<p> 
Scalar floats can be addressed defining its particular kind as follows
<p>
<example>
-10.66E-20_kr
0.66E10_kr
142857._kr
-0.4_kr
2E-12_kr
3.141592653_kr
</example>

<p>
Program <ref id="sec_p_2_5"> contains several examples of the use of
    the <tt>KIND</tt> statement and the default value of <tt>KIND</tt>
    for several variable types. 

<p>
Program <ref id="sec_p_2_6"> contains examples of the different types
    of viariales, how to define them, and how to test them using the intrinsics <tt>KIND</tt>, <tt>DIGITS</tt>, <tt>EPSILON</tt>, <tt>TINY</tt>, <tt>HUGE</tt>, <tt>EXPONENT</tt>, <tt>MAXEXPONENT</tt>, <tt>MINEXPONENT</tt>, <tt>PRECISION</tt> , <tt>RADIX</tt>
    y  <tt>RANGE</tt>.

<p>
In this program variables are defined using the functions <tt>SELECTED_INT_KIND</tt> and <tt>SELECTED_REAL_KIND</tt>
This is correct though it is more appropriate to define the variables
according to the process in the notes.

<p>
The used functions are
<enumlist>
<item> <tt>KIND(x)</tt>: integer output, type of the variable <tt>x</tt>.
<item> <tt>DIGITS(x)</tt>: integer output, number of significant
  digits of <tt>x</tt>.
<item> <tt>EPSILON(x)</tt>: if the input <tt>x</tt> is a float the
  output is another float, of the same type (<em>kind</em>) than
  <tt>x</tt>. It is the smallest number of this type such that 
  <tt>1.0 + EPSILON(X) > 1</tt>.
<item> <tt>TINY(x)</tt>: for float <tt>x</tt> input the output is of
  the same kind than <tt>x</tt>, and it is the minimum positive value
  that can be defined for such variables.
<item> <tt>HUGE(x)</tt>: for float <tt>x</tt> input the output is of
  the same kind than <tt>x</tt>, and it is the maximum positive value
  that can be defined for such variables.
<item> <tt>EXPONENT(x)</tt>:  <tt>x</tt> variable exponent. If <tt>x
    = 0</tt> then <tt>EXPONENT(x)=0</tt> too.
<item> <tt>MAXEXPONENT(x)</tt>: maximum exponent possible
  for <tt>x</tt> type variables. 
<item> <tt>MINEXPONENT(x)</tt>: minimum exponent possible
  for <tt>x</tt> type variables.
<item> <tt>PRECISION(x)</tt>: if  <tt>x</tt> is real or complex the
  output is an integer equal to the number of digits of precision of
  the variable <tt>x</tt>.
<item> <tt>RADIX(x)</tt>: integer result equal to the radix basis of  <tt>x</tt>.
<item> <tt>RANGE(x)</tt>: integer result equal to the range of
  exponent for the variable <tt>x</tt>.
</enumlist>


<item> (*) Present how float arithmetic involves precision loss and
  how an appropriate use of the diferent data types can help to
  minimize this problem.

</list>


<sect id="sec_23">   Example Codes.

  <sect1 id="sec_p_2_1">  <tt>excode_2_1.f90</tt>
<p>
  <example>
    PROGRAM ex_2_1
  IMPLICIT NONE
  !
  ! Program computing the energy of a vibrational normal mode
  ! 
  !  Ge(v) = we (v+1/2) - wexe (v+1/2)^2
  ! 
  !
  ! Definicion de variables
  REAL            :: energ_0, energ, delta_e ! deltae = energ-energ0
  REAL            :: we = 250.0, wexe = 0.25 ! Units: cm-1
  INTEGER         :: v = 0
  CHARACTER*60    :: for_mol
  ! I/O
  PRINT *,'Formula de la molecula : '
  READ *, for_mol
  PRINT *,'Num. de quanta de excitacion : '
  READ *, v
  ! Calculations
  energ = we*(v+0.5) - wexe*(v+0.5)**2
  energ_0 = we*(0.5) - wexe*(0.5)**2
  delta_e = energ - energ_0
  ! I/O
  PRINT *
  PRINT *,'Especie molecular: ', for_mol
  PRINT *,'num. de quanta: ', v
  PRINT *,'energ = ',energ,'cm-1'
  PRINT *,'energ_0 = ',energ_0,'cm-1'
  PRINT *,'energ - energ_0 = ',delta_e,'cm-1'
END PROGRAM ex_2_1
  </example>
  </sect1>
  <sect1 id="sec_p_2_2">  <tt>excode_2_2.f90</tt>

    <p>
      <example>
PROGRAM ex_2_2
  IMPLICIT NONE
  REAL :: A,B,C
  INTEGER :: I
  A = 1.5
  B = 2.0
  C = A / B
  I = A / B
  PRINT *
  PRINT *, 'Case (1), Float variable'
  PRINT *,A,'/',B,' = ',C
  PRINT *, 'Case (2), Integer variable'
  PRINT *,A,'/',B,' = ',I
END PROGRAM ex_2_2
      </example>
</sect1>
  <sect1 id="sec_p_2_3">  <tt>excode_2_3.f90</tt>

<p>
  <example>
PROGRAM ex_2_3
  IMPLICIT NONE
  INTEGER :: I,J,K
  REAL :: Answer
  I = 5
  J = 2
  K = 4
  Answer = I / J * K
  PRINT *,'I = ',I
  PRINT *,'J = ',J
  PRINT *,'K = ',K
  PRINT *,'I / J * K = ',Answer
END PROGRAM ex_2_3
    </example>
</sect1>
  <sect1 id="sec_p_2_4">  <tt>excode_2_4.f90</tt>

<p>
  <example>
PROGRAM ex_2_4
  ! Program to compute the time that takes to light to travel 
  ! a given distance in AU.
  ! 1 AU = 1,50E11 m
  !
  !Definicion de variables
  IMPLICIT NONE
  ! a_u : astronomic unit in km
  REAL , PARAMETER :: a_u=1.50*10.0**8
  ! y_l : year light --> distance travelled by light during a year
  REAL , PARAMETER :: y_l=9.46*10.0**12
  ! m_l : minute light --> distance travelled by light during a minute
  REAL :: m_l
  ! dist : distance travelled in AUs (INPUT)
  REAL :: dist
  ! t_min : time in minutes needed to travel the distance dist
  REAL :: t_min
  !
  ! min : integer part of t_min
  ! seg : seconds from the decimal digits of t_min
  INTEGER :: min, seg
  !
  m_l = y_l/(365.25 * 24.0 * 60.0) ! m_l Calculation
  !
  PRINT *
  PRINT *,'Distance in AUs'
  READ *, dist
  PRINT *
  !
  t_min = (dist*a_u)/m_l
  min = t_min; seg = (t_min - min) * 60
  !
  PRINT *,' It takes light ' , min,' minutes and ', seg,' seconds'
  Print *,' to travel a distance of ',dist,' AU.'
END PROGRAM ex_2_4

</example>
</sect1>
  <sect1 id="sec_p_2_5">  <tt>excode_2_5.f90</tt>
<p>
<example>
PROGRAM ex_2_5
  INTEGER :: i
  REAL :: r
  CHARACTER(LEN=1) :: c
  LOGICAL :: l
  COMPLEX :: cp
  PRINT *,' Integer ',KIND(i)
  PRINT *,' Real    ',KIND(r)
  PRINT *,' Char    ',KIND(c)
  PRINT *,' Logical ',KIND(l)
  PRINT *,' Complex ',KIND(cp)
END PROGRAM ex_2_5
</example>
</sect1>
  <sect1 id="sec_p_2_6">  <tt>excode_2_6.f90</tt>
<p>
<example>
PROGRAM ex_2_6
  ! From Program ch0806 of Chivers & Sleightholme
  !
  ! Examples of the use of the kind
  ! function and the numeric inquiry functions
  !
  ! Integer arithmetic
  !
  ! 32 bits is a common word size,
  ! and this leads quite cleanly
  ! to the following
  ! 8 bit integers
  ! -128 to 127 10**2
  ! 16 bit integers
  ! -32768 to 32767 10**4
  ! 32 bit integers
  ! -2147483648 to 2147483647 10**9
  !
  ! 64 bit integers are increasingly available.
  ! This leads to
  ! -9223372036854775808 to
  !  9223372036854775807 10**19
  !
  ! You may need to comment out some of the following
  ! depending on the hardware platform and compiler
  ! that you use.
  INTEGER                         :: I
  INTEGER ( SELECTED_INT_KIND( 2)) :: I1
  INTEGER ( SELECTED_INT_KIND( 4)) :: I2
  INTEGER ( SELECTED_INT_KIND( 8)) :: I3
  INTEGER ( SELECTED_INT_KIND(16)) :: I4
  ! Real arithmetic
  !
  ! 32 and 64 bit reals are normally available.
  !
  ! 32 bit reals 8 bit exponent, 24 bit mantissa
  !
  ! 64 bit reals 11 bit exponent 53 bit mantissa
  !
  REAL :: R = 1.0
  REAL ( SELECTED_REAL_KIND( 6, 37)) :: R1 = 1.0
  REAL ( SELECTED_REAL_KIND(15,307)) :: R2 = 1.0 
  REAL ( SELECTED_REAL_KIND(18,310)) :: R3 = 1.0
  PRINT *,' '
  PRINT *,' Integer values'
  PRINT *,'         Kind       Huge'
  PRINT *,' '
  PRINT *,KIND(I ),' ',HUGE(I    )
  PRINT *,' '
  PRINT *,KIND(I1 ),' ',HUGE(I1  )
  PRINT *,KIND(I2 ),' ',HUGE(I2  )
  PRINT *,KIND(I3 ),' ',HUGE(I3  )
  PRINT *,KIND(I4 ),' ',HUGE(I4  )
  PRINT *,' '
  PRINT *,' ----------------------------------- '
  PRINT *,' '
  PRINT *,' Real values'
  !
  PRINT *,'         Kind     ', KIND(R ), '    Digits     ', DIGITS(R )
  PRINT *,'  Huge    = ',HUGE(R ), ' Tiny =', TINY(R)
  PRINT *,'  Epsilon = ',EPSILON(R),' Precision = ', PRECISION(R)
  PRINT *,'  Exponent = ',EXPONENT(R), 'MAXExponent = ', MAXEXPONENT(R), '  MINExponent = ',MINEXPONENT(R)
  PRINT *,'  Radix    = ', RADIX(R ), ' Range =', RANGE(R)
  PRINT *,' ' 
  !
  !
  PRINT *,'         Kind     ', KIND(R1 ), '    Digits     ', DIGITS(R1 )
  PRINT *,'  Huge    = ',HUGE(R1 ), ' Tiny =', TINY(R1)
  PRINT *,'  Epsilon = ',EPSILON(R1),' Precision = ', PRECISION(R1)
  PRINT *,'  Exponent = ',EXPONENT(R1), 'MAXExponent = ', MAXEXPONENT(R1), '  MINExponent = ',MINEXPONENT(R1)
  PRINT *,'  Radix    = ', RADIX(R1 ), ' Range =', RANGE(R1)
  PRINT *,' ' 
  !
  !
  PRINT *,'         Kind     ', KIND(R2 ), '    Digits     ', DIGITS(R2 )
  PRINT *,'  Huge    = ',HUGE(R2 ), ' Tiny =', TINY(R2)
  PRINT *,'  Epsilon = ',EPSILON(R2),' Precision = ', PRECISION(R2)
  PRINT *,'  Exponent = ',EXPONENT(R2), 'MAXExponent = ', MAXEXPONENT(R2), '  MINExponent = ',MINEXPONENT(R2)
  PRINT *,'  Radix    = ', RADIX(R2 ), ' Range =', RANGE(R2)
  PRINT *,' ' 
  !
  !
  PRINT *,'         Kind     ', KIND(R3 ), '    Digits     ', DIGITS(R3 )
  PRINT *,'  Huge    = ',HUGE(R3 ), ' Tiny =', TINY(R3)
  PRINT *,'  Epsilon = ',EPSILON(R3),' Precision = ', PRECISION(R3)
  PRINT *,'  Exponent = ',EXPONENT(R3), 'MAXExponent = ', MAXEXPONENT(R3), '  MINExponent = ',MINEXPONENT(R3)
  PRINT *,'  Radix    = ', RADIX(R3 ), ' Range =', RANGE(R3)
  PRINT *,' ' 
  !
END PROGRAM ex_2_6
</example>
</sect1>
</sect>
</chapt>
<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!--                         Clase 3                         -->
<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<chapt id="clase_3"><heading>Introduction to <prgn>Fortran</prgn> Arrays</heading> 
<sect id="sec_31"> Objectivos

<p>
The main aims of this session are the following

<enumlist>  
  <item> present one dimension arrays as <prgn>Fortran</prgn> data structures. 
    <item> present the different ways of defining an array.
      <item> present the <tt>DO</tt> loop syntax and the implicit <tt>DO</tt> and their use with 
matrices.
	<item> explore dynamic arrays in <prgn>Fortran 90</prgn>
	  <item> present multidimensional arrays as <prgn>Fortran</prgn> data structures. 
</enumlist>  

</sect>

<sect id="sec_32"> Main items.

<p>
Basic Definitions:

<enumlist>  
  <item> <em>rank</em>: number of indices necessary to indicate unambiguously an array element.
    <item> <em>bounds</em>: max and min values of the indices labelling array elements in each dimension. 
      <item> <em>extent</em>: number of elements in an array dimension.
	<item> <em>size</em>: total number of a matrix.
	  <item> <em>conformal</em>: two arrays are conformal if both have the same rank and extent.
</enumlist>  

<p>
 The following points should be emphasized:
 <list>  
   <item> one dimensional array (vector) definition making use of the <tt>DO</tt> control structure (see <ref id="sec_p_3_1"> and exercise 2_1)
       <item> use of the <tt>PARAMETER</tt> declaration for the definition of array bounds in static array declaration.
	 <item> initialize before use. Beware of surprises. The initialization to a common constant value is extremely simple: <tt>vec = <var>valor</var></tt>. A possible alternative is the use of <em>array
constructors</em>. In the following example, in order to define an integer array with six elements called <tt>vec_int</tt> three possible and equivalent options are given
<p>
<example>
do i = 0, 5
   vec_int(i) = 2*i
enddo

vec_int = (/(2*i, i = 0, 5)/)

vec_int = (/0,2,4,6,8,10/)
</example>
<p>
Last two options involve <em>array constructors</em> and can be carried out when the array is declared<footnote>Beware of this feature in functions and subroutines.</footnote>
<item> use of the <tt>ALLOCATABLE</tt> declaration and the use of the <tt>ALLOCATE</tt> function, as it is shown in example <ref id="sec_p_3_2">. The <tt>ALLOCATE</tt> option <tt>STAT = <var>var</var></tt> allows to chek if the array has been properly defined. See example in program <ref id="sec_p_9_3">.
<item> implicit <tt>DO</tt> and multidimensional arrays. See example <ref id="sec_p_3_3">.
<item> most general form of the <tt>DO</tt> control structure and possibility of introducing zero or negative array indeces. See example
<ref id="sec_p_3_4">.
<item> combination of <prgn>bash</prgn> redirectioning with <prgn>Fortran</prgn> programs. Necessary for exercise 2, it is explained in  <ref id="clase_4">.
</list>  


</sect>
<sect id="sec_33"> Example Codes.

  <sect1 id="sec_p_3_1">  <tt>excode_3_1.f90</tt>
<p>
<example>
PROGRAM ex_3_1
!
! VARIABLES DEFINITION 
  IMPLICIT NONE
  REAL :: Total=0.0, Average=0.0
  INTEGER, PARAMETER :: Week=7
  REAL , DIMENSION(1:semana) :: Lab_Hours
  INTEGER :: Day
!
  PRINT *,' Labor Time (hours per day during a week):'
  DO Day= 1, Week
     READ *, Lab_Hours(Day)
  ENDDO
!
  DO Day = 1, Week
     Total = Total + Lab_Hours(Day)
  ENDDO
  Average = Total / Week
!
  PRINT *,' Average Weekly Workload: '
  PRINT *, Average, ' hours'
END PROGRAM ex_3_1
</example>
</sect1>
  <sect1 id="sec_p_3_2">  <tt>excode_3_2.f90</tt>

<p>
<example>
PROGRAM ex_3_2
  !
  ! VARIABLE DEFINITION
  IMPLICIT NONE
  REAL :: Total=0.0, Average=0.0
  REAL , DIMENSION(:), ALLOCATABLE :: Lab_Hours
  INTEGER :: Day, Number_Days
  !
  PRINT *,' Number of workdays:'
  READ *, Number_Days
  !
  ALLOCATE(Lab_Hours(1:Number_Days))
  !
  PRINT *,' Daily hours of work in ', Number_Days, ' days.'
  DO Day = 1, Number_Days
     READ *, Lab_Hours(Day)
  ENDDO
  !
  DO Day=1, Number_Days
     Total = Total + Lab_Hours(Day)
  ENDDO
  Average = Total / Number_Days
!
  PRINT *,' Average daily workhours in ',Number_Days, ' days : '
  PRINT *, Average, ' hours'
!
END PROGRAM ex_3_2
</example>
</sect1>
  <sect1 id="sec_p_3_3">  <tt>excode_3_3.f90</tt>

<p>
<example>
PROGRAM ATTEND_CONTROL
  IMPLICIT NONE
  INTEGER , PARAMETER :: N_students = 3
  INTEGER , PARAMETER :: N_courses = 3
  INTEGER , PARAMETER :: N_lab = 3
  INTEGER :: student, course, lab
  CHARACTER*2 , DIMENSION(1:N_lab,1:N_courses,1:N_lab) :: attend = 'NO'
  DO student = 1, N_students
     DO course = 1,N_courses
        READ *,(attend(lab,course,student),lab = 1, N_lab)
     ENDDO
  ENDDO
  PRINT *,' Lab attendance : '
  DO student=1, N_students
     PRINT *,' Student = ', student
     DO course = 1,N_courses
        PRINT *,'   Course = ', course, ' : ', (attend(lab,course,student),lab=1,N_lab)
     ENDDO
  ENDDO
END PROGRAM ATTEND_CONTROL
</example>
</sect1>
  <sect1 id="sec_p_3_4">  <tt>excode_3_4.f90</tt>

<p>
<example>
PROGRAM ex_3_4
  IMPLICIT NONE
  REAL , DIMENSION(-180:180) :: Time=0
  INTEGER :: Degree, Strip
  REAL :: Value
!
  DO Degree=-165,165,15
     Value=Degree/15
     DO Strip=-7,7
        Time(Degree+Strip)=Value
     ENDDO
  ENDDO
!
  DO Strip=0,7
     Time(-180 + Strip) = -180/15
     Time( 180 - Strip) = 180/15
  ENDDO
!
  DO Degree=-180,180
     PRINT *,Degree,' ',Time(Degree), 12 + Time(Degree)
  END DO
END PROGRAM ex_3_4
</example>
</sect1>
</sect>
</chapt>
<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!--                         Clase 4                         -->
<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<chapt id="clase_4"><heading>More on Arrays</heading> 
<sect id="sec_41"> Objectives

<p>
The main aims of this lesson are the following:

<enumlist>  
<item> presenting storage ordering of multidimensional arrays.
<item> presenting how to manipulate whole matrices or arrays  sections in <prgn>Fortran</prgn>.
<item> matrix definition using the <tt>WHERE</tt> statement.
</enumlist>  

</sect>

<sect id="sec_42"> Main items.

<p>

<list>  
<item> Storage ordering
<p>
  Multidimensional arrays are stored in memory by <prgn>Fortran</prgn> in such a way that the first subindex varies faster than the second, that varies faster than the third and so on and so forth. This is known as <em>column major order</em>.
<p> 
  For example, if we define a <tt>4 x 2</tt> matrix as
<p>
<tt>REAL , DIMENSION(1:4,1:2) :: A</tt>, 

<p> the <tt>A</tt> array has eight elements stored into memory as follows

<p>
<example>
A(1,1), A(2,1), A(3,1), A(4,1), A(1,2), A(2,2), A(3,2), A(4,2)
</example>

<p>
The <tt>A</tt> matrix initialization can be carried out in several ways. Assuming that each element should be initialized with a number equal to the index of the corresponding row, we could use two loops<footnote>The <em>column major order</em> storage makes optimal to run over columns in the inner loop, specially when running with large matrices.</footnote>
<p>
<example>
DO I_col = 1, 2
     DO I_row = 1, 4
        A(I_row, I_col) = I_row
     ENDDO
ENDDO
</example>
<p>
An <em>array constructor</em> can also be of help, though the seemingly simple solution
<p>
<example>
A = (/ 1, 2, 3, 4, 1, 2, 3, 4 /)
</example>
<p>
does not work. The  <em>array constructors</em> produce vectors and not matrices. The vector defined above is of dimension 8, but not a matrix 4x2. The vector and the array <tt>A</tt> have identical sizes, but are not conformal. The statement <tt>RESHAPE</tt> gives a possible solution. The sytax of this statement is
<p>
<example>
<var>output_array</var> = RESHAPE(<var>array_1</var>, <var>array_2</var>)
</example>
<p>
Where <var>array_1</var> is a matrix that would be reshaped and <var>array_2</var> is a vector with the dimensions of the new matrix <var>output_array</var>. The total number of elements of <var>array_1</var> and <var>output_array</var> needs to be identical. In the previous example a correct <em>array constructor</em> is
<p>
<example>
A = RESHAPE( (/ 1, 2, 3, 4, 1, 2, 3, 4 /), (/ 4, 2 /) )
</example> 

<p>
Another example can be found in code <ref id="sec_p_4_3">. The <tt>RESHAPE</tt> command can be used in the array declaration
<p>
<example>
INTEGER, DIMENSION(1:4,1:2) :: A = &
       RESHAPE( (/ 1, 2, 3, 4, 1, 2, 3, 4 /), (/ 4, 2 /) )
</example> 

<p>
The data ordering in storage is specially important in I/O operations. The command
<p>
<example>
PRINT*, A
</example>
<p>
will give as a result
<p>
<example>
A(1,1), A(2,1), A(3,1), A(4,1), A(1,2), A(2,2), A(3,2), A(4,2)
</example>

<p> It is necessary to take this into account also when making use of the  <tt>READ</tt> statement to fill with values the elements of a multidimensional array: <tt>READ(<var>unit</var>,*) A</tt>. The <em>implicit</em> <tt>DO</tt> statement allow to change the standard reading sequence
<p>
<example>
READ(unit,*) ( ( A(row,col), col = 1, 2 ), row = 1, 4 )
</example>

<item> <prgn>FORTRAN</prgn> allows to define multidimensional arrays, being seven is the max number of indices.
The code <ref id="sec_p_4_2"> an array is fully characterized making use of several <em>inquiry</em> type functions (see <ref id="sec_p_8_2">).
<item> The usage of whole matrices is a great advantage. Definig floating point vectors
<tt>V1</tt>, <tt>V2</tt>, <tt>V3</tt> y <tt>V4</tt> as
<p>
<example>
REAL , DIMENSION(1:21) :: V1, V2
REAL , DIMENSION(-10:10) :: V3
REAL , DIMENSION(0:10) :: V4
</example>
<p> 
The following tasks are simply performed using this <prgn>Fortran 90</prgn> feature.
<enumlist>
<item> Assigning a particular value to the full array:
<p>
<example>
V1 = 0.5
</example>
<item> Equating matrices:
<p>
<example>
V1 = V2
</example>
<p> 
Making each <tt>V1</tt> element equal to the corresponding element of <tt>V2</tt>. This is only valid when both matrices are <em>conformal</em>. It is also valid 
<p>
<example>
V3 = V2
</example>
<p> but it is <em>not</em> valid
<p>
<example>
V1 = V4
</example>
<item> All arithmetic operation for scalars can be also applied to conformal matrices, though they may not be the expected mathematical operations.
<p>
<example>
V1 = V2 + V3
V1 = V2*V3
</example>
In the first case <tt>V1</tt> is the sum of two vectors, but in the second case each <tt>V1</tt> element is the product of the corresponding  <tt>V2</tt> and <tt>V3</tt> elements, which is not the scalar product. In the two-dimensional matrices case, if we define
<p>
<example>
REAL , DIMENSION(1:4,1:4) :: A, B, C
</example>
<p>
The following are valid statements in <prgn>Fortran 90</prgn>
<example>
A = A**0.5
C = A + B
C = A * B
</example>
<p> 
  The last case is not the matrix product but a matrix having each element as the result of the product of the corresponding <tt>A</tt> annd <tt>B</tt> elements.

<item> A matrix can also be read without a <tt>DO</tt> loop, as in example <ref id="sec_p_4_1">, where also the intrinsic function <tt>SUM</tt> is presented.

</enumlist>

<item> The definition of array slices is possible using the index syntax <tt><var>liminf</var>:<var>limsup</var>:<var>step</var></tt>
<p>
<example>
V1(1:10) = 0.5
B(1,1:4) = 100.0
</example>
<p>
  In the first case the first ten elements of the  <tt>V1</tt> array take the value <tt>0.5</tt>, while in the second elements in the first row of <tt>B</tt> take the value <tt>100.0</tt>. See example  <ref id="sec_p_4_1">.

<p>
  The most general syntax to define a slice is  <tt><var>lowlimit</var>:<var>upplimit</var>:<var>step</var></tt>, the first slice element has index <var>lowlimit</var>, the last one is less than or equal to <var>upplimit</var> and  <var>step</var> is the index variable increment. The default value of  <var>step</var> is <tt><var>step</var>=1</tt>.
Examples:
<p>
<example>
V1(:)       ! the whole vector
V1(3:10)    ! elements V1(3), V1(4), ... ,   V1(10) 
V1(3:10:1)  !   ""      ""     ""             ""
V1(3:10:2)  !   ""     V1(3), V1(5), ... , V1(9)
V1(m:n)     ! elements V1(m), V1(m+1), ... , V1(n) 
V1(9:4:-2)  !   ""     V1(9), V1(7), V1(5)
V1(m:n:-k)  ! elements V1(m), V1(m-k), ... , V1(n) 
V1(::2)     !   ""     V1(1), V1(3), ... , V1(21)
V1(m:m)     ! 1 x 1 array
V1(m)       ! Scalar
</example>

<item> The assignment of values to an array can be done making use of a <em>logic mask</em>, with the <tt>WHERE</tt> statement. The use of the mask allows to select those array elements that should undergo the initialization. If, e.g., we need to compute the square root of the elements of a floating point array called  <tt>data_mat</tt> and store them in the array  <tt>sq_data_mat</tt>, we can skip the use of loops and conditionals as in the following code
<p>
<example>
DO j_col = 1, dim_2
   DO i_row = 1, dim_1
         IF ( data_mat(i_row, j_col) >= 0.0 ) THEN
              sq_data_mat(i_row, j_col) = SQRT( data_mat(i_row, j_col) )
         ELSE
              sq_data_mat(i_row, j_col) = -99999.0
         ENDIF
   ENDDO
ENDDO
</example> 
<p> The <tt>WHERE</tt> statement greatly simplifies this task. The statement syntax is 
<p>
<example>
[<var>name</var>:] WHERE (<var>mask_expr_1</var>) 
   ....
   Array assignment block 1
   ....
ELSEWHERE (<var>mask_expr_2</var>) [<var>name</var>]
   ....
   Array assignment block 2
   ....
ELSEWHERE
   ....
   Array assignment block 3
   ....
ENDWHERE [<var>name</var>]
</example> 
<p> where <var>mask_expr_1</var> and <var>mask_expr_2</var> are boolean arrays conformal with the array being assigned. The previous example is therefore simplified to 
<p>
<example>
WHERE ( data_mat >= 0.0 ) 
            sq_data_mat = SQRT( data_mat )
ELSEWHERE
            sq_data_mat = -99999.0
ENDWHERE
</example> 

<item> These aspects are treated in the different given examples. Example  <ref id="sec_p_4_3"> shows how to initialize vectoras and matrices, in the last case making use of the <tt>RESHAPE</tt> statement. The example also introduces the <prgn>Fortran</prgn> intrinsics <tt>DOT_PRODUCT</tt> (scalar product) and <tt>MATMUL</tt> (matrices product).
<p>
 Example  <ref id="sec_p_4_4"> exemplifies the use <tt>WHERE</tt> in combination with a logical mask.
    <p> Example <ref id="sec_p_4_5"> stress the fact the the elimination of <tt>DO</tt> loops can sometimes bring surprising results about.
<p> Example   <ref id="sec_p_4_6"> shows how to use the  <tt>RESHAPE</tt> statement in the definition of a  matrix and how to use slicing in the defined array.
</list>  


</sect>
<sect id="sec_43">  Example Codes.

  <sect1 id="sec_p_4_1">  <tt>excode_4_1.f90</tt>
<p>
<example>
PROGRAM ex_4_1
  !
  ! VARIABLE DEFINITION
  IMPLICIT NONE
  REAL :: Total=0.0, Average=0.0
  REAL , DIMENSION(:), ALLOCATABLE :: t_worked
  ! Correction Factor
  REAL :: correction =1.05 
  INTEGER :: day, num_days
  !
  PRINT *,' Number of workdays: '
  READ *, num_days
  ! Dynamic storage definition
  ALLOCATE(t_worked(1:num_days))
  !
  PRINT *,' Worked hours per day in ', num_days, ' days.'
  ! I/O
  READ *, t_worked
  !
  t_worked(num_days-1:num_days) = correction*t_worked(num_days-1:num_days)
  !
  DO day=1,num_days
     Total = Total + t_worked(day)
  ENDDO
  Average = Total / num_days
  !
  PRINT *,' Average daily hours of work in ',num_days, ' days : '
  PRINT *, Average
  !
END PROGRAM ex_4_1
</example>
</sect1>
  <sect1 id="sec_p_4_2">  <tt>excode_4_2.f90</tt>
<p>
<example>
PROGRAM ex_4_2
  !
  ! Program to characterize an array making use of inquiry functions
  !
  IMPLICIT NONE
  !
  REAL, DIMENSION(:,:), ALLOCATABLE :: X_grid
  INTEGER :: Ierr
  !
  ! 
  ALLOCATE(X_grid(-20:20,0:50), STAT = Ierr)
  IF (Ierr /= 0) THEN
     STOP 'X_grid allocation failed'
  ENDIF
  !
  WRITE(*, 100) SHAPE(X_grid)
100 FORMAT(1X, "Shape :        ", 7I7)
  !
  WRITE(*, 110) SIZE(X_grid)
110 FORMAT(1X, "Size :         ", I7)
  !
  WRITE(*, 120) LBOUND(X_grid)
120 FORMAT(1X, "Lower bounds : ", 7I6)
  !
  WRITE(*, 130) UBOUND(X_grid)
130 FORMAT(1X, "Upper bounds : ", 7I6)
  !
  DEALLOCATE(X_grid, STAT = Ierr)
  IF (Ierr /= 0) THEN
     STOP 'X_grid deallocation failed'
  ENDIF
  !
END PROGRAM EX_4_2
</example>
</sect1>
<sect1 id="sec_p_4_3">  <tt>excode_4_3.f90</tt>

<p>
<example>
PROGRAM ex_4_3
  !
  ! VARIABLES DEFINITION
  IMPLICIT NONE
  REAL, DIMENSION(1:5) :: VA = (/1.0,1.0,1.0,1.0,1.0/), PMAT
  INTEGER I
  INTEGER, DIMENSION(1:5) :: VB = (/(2*I,I=1,5)/) 
  REAL :: PE
  REAL , DIMENSION(1:5,1:5) :: MC
  REAL , DIMENSION(25) :: VC = &
       (/ 0.0,0.0,0.0,0.0,1.0,0.5,2.0,3.2,0.0,0.0, & 
          0.0,0.0,0.0,0.0,11.0,0.5,2.3,3.2,0.0,0.0, & 
          1.0,3.0,-2.0,-2.0,-0.6 /)
  ! Scalar Product
  PE = DOT_PRODUCT(VA,VB)
  !
  PRINT *, 'Scalar Product (VA,VB) = ', PE
  !
  ! Product of matrices VAxMC
  ! RESHAPE VC to make it a  5 x 5 matrix
  MC = RESHAPE(VC,(/5,5/))
  PMAT = MATMUL(VA,MC)
  !
  PRINT *, ' VA x MC = ', PMAT(1:5)
  !
END PROGRAM ex_4_3
</example>
</sect1>
<sect1 id="sec_p_4_4">  <tt>excode_4_4.f90</tt>

<p>
<example>
PROGRAM ex_4_4
  IMPLICIT NONE
  REAL , DIMENSION(-180:180) :: Time=0
  INTEGER :: Degree, Strip
  REAL :: Value
  CHARACTER (LEN=1), DIMENSION(-180:180) :: LEW=' '
!
  DO Degree=-165,165,15
     Value=Degree/15
     DO Strip=-7,7
        Time(Degree+Strip)=Value
     ENDDO
  ENDDO
!
  DO Strip=0,7
     Time(-180 + Strip) = -180/15
     Time( 180 - Strip) = 180/15
  ENDDO
!
  DO Degree=-180,180
     PRINT *,Degree,' ',Time(Degree), 12 + Time(Degree)
  END DO
!
  WHERE (Time > 0) 
     LEW='E'
  ELSEWHERE (Time < 0)
     LEW='W'
  ENDWHERE
!
  PRINT*, LEW
!
END PROGRAM ex_4_4
</example>
</sect1>

<sect1 id="sec_p_4_5">  <tt>excode_4_5.f90</tt>

<p>
<example>
PROGRAM ex_4_5
  !
  ! VARIABLE DEFINITION 
  IMPLICIT NONE
  REAL, DIMENSION(1:7) :: VA = (/1.2,2.3,3.4,4.5,5.6,6.7,7.8/)
  REAL, DIMENSION(1:7) :: VA1 = 0.0, VA2 = 0.0
  INTEGER I
  !
  VA1 = VA
  VA2 = VA
  !
  DO I = 2, 7
     VA1(I) = VA1(I) + VA1(I-1)
  ENDDO
  !
  VA2(2:7) = VA2(2:7) + VA2(1:6)
  !
  ! Previous two operations with VA1 and VA2 seem that
  ! should provide the same result. Which is not the case.
  PRINT*, VA1
  PRINT*, VA2
  !
  ! To obtain the same effect without an explicit DO loop we can do 
  ! the following
  VA2 = VA
  VA2(2:7) = (/ (SUM(VA2(1:I)), I = 2,7) /)
  !
  PRINT*, VA1
  PRINT*, VA2
END PROGRAM ex_4_5
</example>

</sect1>

<sect1 id="sec_p_4_6">   <tt>excode_4_6.f90</tt>

<p>
<example>
PROGRAM ex_4_6
  !
  ! DEFINITION OF VARIABLES
  IMPLICIT NONE
  INTEGER, DIMENSION(1:3,1:3) :: A = RESHAPE( (/ 1,2,3,4,5,6,7,8,9 /), (/ 3,3 /) )
  !
  !
  !      1  4  7     
  !  A = 2  5  8
  !      3  6  9
  !
  PRINT*, "Matrix Element", A(2,3)
  PRINT*, "Submatrix", A(1:2,2:3)
  PRINT*, "Submatrix", A(::2,::2)
  PRINT*, "Matrix Column", A(:,3)
  PRINT*, "Matrix Row", A(2,:)
  PRINT*, "Full Matrix", A
  PRINT*, "Transposed Matrix", TRANSPOSE(A)
END PROGRAM ex_4_6
</example>
</sect1>


</sect>

</chapt>
<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!--                         Clase 5                         -->
<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<chapt id="clase_7"><heading>Control Structures</heading> 
<sect id="sec_71"> Objectives

<p>
The main aims of this session consist of:

<enumlist>  
<item> presenting the different conditional control structures in <prgn>Fortran</prgn> (<em>branching</em>).
<item> presenting the different way of building loops
  in <prgn>Fortran</prgn> code.
</enumlist>  
<p>
  These structures allows the programmer to control the program flow,
  allowing the conditional execution of statements according to the
  user input values or the values acquired by variables during the
  program execution.


<p>
It is extremely important to take into account before starting to
write code in any programming language that a previous step should be
accomplished. In encompasses having a clear idea of the problem, the
inputs and outputs, the program structure, breaking complex tasks into
simpler subtasks, and the optimal algorithm. A flow diagram can be of
great help at this stage.

<p>
The division of the problem into simpler and simpler tasks is
called <em>top-down design</em>. Each subtasks should be coded and
checked in an independent manner.
</sect>

<sect id="sec_72"> Main items.

<p>
We provide a scheme of the main control structures, strting with
conditionals and later of loops.
<p>
<list>  
<item> Conditionals.
<p>
Depend on the evaluation of boolean expressions for which the
following operators are defined:
<list>
<item> <tt>==</tt> To be equal to.
<item> <tt>/=</tt> Not to be equal to.
<item> <tt>&gt;</tt> Greater than.
<item> <tt>&lt;</tt> Lesser than.
<item> <tt>&gt;=</tt> Greater or equal than.
<item> <tt>&lt;=</tt> Lesser or equal than.
</list>
<p> There exist also logical operators to combine several logical expressions:
<list>
<item> <tt>.AND.</tt> 
<item> <tt>.OR.</tt> 
<item> <tt>.NOT.</tt>
  <item> <tt>.EQV.</tt> (Boolean '==' operator)
<item> <tt>.NEQV.</tt> (Boolean '/=' operator)
</list>


<p>
The <tt>==</tt> and <tt>/=</tt> shouldn't be used to compare real type
variables, due to their nonexact nature. If e.g.  <tt>A</tt>
and <tt>B</tt> are real variables, the following code is discouraged
<example>
...
IF (A==B) same = .TRUE.
...
</example>
<p>
The alternative would be to define a tolerance and compare the
variables as follows
<p>
<example>
REAL :: TOL = 0.00001
... 
IF (ABS(A-B) < TOL) same = .TRUE. 
...
</example>


<p>
The possible conditional statements are
<enumlist>  
<item> <tt>IF THEN ENDIF</tt>
<p> 
The syntax of this conditional statement is
<p>
<example>
. 
. code
. 
IF (<var>Boolean Expression</var>) THEN
         .
         . code_1
         .
ENDIF
.
. code
. 
</example>
<p>
  Only if the <var>Boolean Expression</var> is true
  the <tt>code_1</tt> block instructions are executed. 

<p> If there is only one statement in the <tt>code_1</tt> block the
  command can be simplified to a one liner removing the  <tt>THEN</tt>
  and <tt>ENDIF</tt> keywords as follows
<p>
<example>
. 
. code
. 
IF (<var>Boolean Expression</var>) statement
.
. code
. 
</example>
 
<item> <tt>IF THEN ELSE ENDIF</tt>
<p> 
The syntax of this conditional statement is
<p>
<example>
. 
. code
. 
IF (<var>Boolean Expression</var>) THEN
         .
         . code_1
         .
ELSE
         .
         . code_2
         .
ENDIF
.
. code
. 
</example>
<p>
If the <var>Boolean Expression</var> is true
  the <tt>code_1</tt> block instructions are executed, if it is false
then <tt>code_2</tt> block is run.

<item> <tt>IF THEN ELSE IF ENDIF</tt>
<p> 
The syntax of this conditional statement is
<p>
<example>
. 
. code
. 
IF (<var>Boolean Expression_1</var>) THEN
         .
         . code_1
         .
ELSE IF (<var>Boolean Expression_2</var>) THEN
         .
         . code_2
         .
ENDIF
.
. code
. 
</example>
<p>
In case that the <var>Boolean Expression_1</var> is true
  the <tt>code_1</tt> block instructions are executed, if it is false
but <var>Boolean Expression_2</var> is true then <tt>code_2</tt> block is run.

<item> <tt>IF THEN ELSE IF ELSE ENDIF</tt>
<p> 
The syntax of this conditional statement is
<p>
<example>
. 
. code
. 
IF (<var>Boolean Expression_1</var>) THEN
         .
         . code_1
         .
ELSE IF (<var>Boolean Expression_2</var>) THEN
         .
         . code_2
         .
ELSE 
         .
         . code_3
         .
ENDIF
.
. code
. 
</example>
<p>
In case that the <var>Boolean Expression_1</var> is true
  the <tt>code_1</tt> block instructions are executed, if it is false
but <var>Boolean Expression_2</var> is true then <tt>code_2</tt> block
  is run. If both are false then the <tt>code_3</tt> block is run.



<item> <tt>SELECT CASE</tt>
<p>
The <tt>CASE</tt> statement allows to choose among different options
in a clear and efficient way, though it has some limitations.
<p> 
The syntax of this conditional statement is
<p>
<example>
SELECT CASE (selector)
   CASE (label-1)
      block-1
   CASE (label-2)
      block-2
   CASE (label-3)
      block-3
     .............
   CASE (label-n)
      block-n
   CASE DEFAULT
      block-default
END SELECT
</example>
<p>
The <tt>selector</tt> is either a variable or an expression of the <em>integer</em>, <em>logical</em>,
or <em>character</em> type. It cannot be a real or complex number. 

<p>
The  <tt>label-1</tt> ... <tt>label-n</tt> labels have the following syntax
<p>
<example>
value
value_1 : value_2
value_1 :
 : value_1
</example>
<p>
The first one is positive if the selector is equal to <tt>value</tt> and
the second if the selector takes a value in the range <tt>value_1</tt>
to <tt>value_2</tt>. The third(fourth) is true if the selector has a value
larger(less)
than <tt>value_1</tt>. The <tt>valor</tt>, <tt>value_1</tt>, and 
<tt>value_2</tt> should be constants or variables defined with
the  <tt>PARAMETER</tt> declaration.


<p>
The  <tt>selector</tt> expression is evaluated first. The result is
compared with the values in each one of the labels, running the block
of instructions of the first successful comparison. If none of the
labels is true the <tt>block-default</tt> is run if it exists. 

<p>
A simple example:

<p>
<example>
SELECT CASE (I)
     CASE (1)
       PRINT*, "I = 1"
     CASE (2:9) 
       PRINT*, "I in [2,9]"
     CASE (10:)
       PRINT*, "I in [10,INF]"
     CASE DEFAULT
       PRINT*, "I is negative"
END SELECT CASE
</example>


<p>
The <tt>SELECT CASE</tt> statement is more elegant than a series
of  <tt>IF</tt>'s as only one expression controls the access to the
different alternatives. 
</enumlist>



<p> 
Conditional control structures can be nested in several levels. For
the sake of clarity in this case the different levels should be labeled as follows
<p>
<example>
firstif: IF (a == 0) THEN
            PRINT*,  "a is zero"
            secondif: IF (c /= 0) THEN 
              PRINT*,  "a is zero and c is not zero"
            ELSE secondif
              PRINT*,  "a and c are zero"
            ENDIF secondif
          ELSEIF (a &gt; 0) THEN firstif
            PRINT*,  "a is positive"
          ELSE firstif
            PRINT*,  "a is negative"
          ENDIF firstif
</example>

<p>
The role of the lables <tt>firstif</tt> and <tt>secondif</tt> is to
clarify the source code for the reader. Once a label is included in
the <tt>IF</tt> statement, then it has to be present also in the <tt>ENDIF</tt>,
while it is optional in the <tt>ELSE</tt> and <tt>ELSEIF</tt>. The
number of nested conditionals is unlimited. 

<p>
The example code <ref id="sec_p_7_1"> contains the  
<tt>IF THEN ELSE IF ELSE ENDIF</tt> structure
and, apparently, the same task is coped with in
example <ref id="sec_p_7_2"> with the <tt>CASE</tt> structure.



<item> Loops 
<enumlist>
<item> Basic loop: The  <tt>DO</tt> statement
<p> 
We have been already introduced to the basic <tt>DO</tt> loop:
<p>
<example>
DO Var = initial_value, final_value, increment
       Block of Code
END DO
</example>
<p>
  The variable <tt>Var</tt> changes from  <tt>initial_value</tt> to <tt>final_value</tt> adding <tt>increment</tt> each iteration. 
<item> The <tt>DO WHILE</tt> loop
<p> 
This loop has this structure:
<p>
<example>
DO WHILE (conditional)
      Block of code
ENDDO
</example>
<p> In this case the block of code is run until the <tt>conditional</tt> in the head of the block is false. E.g. see example <ref id="sec_p_7_4">.
    <item> The <tt>REPEAT UNTIL</tt> loop
<p> 
  This type of loop has the following structure:
  <p>
    <example>
      DO
         Block of code
         #
         IF (conditional) EXIT
      END DO
</example>
<p>
  The loop is executed until the conditional is
  evaluated <tt>True</tt>. This case differs from the previous two in
  that the code block is run at least once.

<p>
  In this case we make use of the  <tt>EXIT</tt> statement. When this statement is run into a loop the program leaves inmediately the loop and keeps running from the order following the corresponding <tt>ENDDO</tt>. Another interesting statement when working with loops is <tt>CYCLE</tt>. The execution of the  <tt>CYCLE</tt> statement makes the program to return to the beginning of the loop, without running the statements in the loop block between the <tt>CYCLE</tt> statement and the end of the loop.

  <p> As in the conditionals case, nested loops can be labeled. This greatly clarifies the source code and, in particular, allows to indicate to which loop level refers the statements  <tt>EXIT</tt> and <tt>CYCLE</tt>. By default, they address the inner loop.

<p>
There is a last statement, worth to mention, the  <tt>GOTO</tt> command, though its use is highly discouraged in the moder programming standards.
</enumlist>
</list>  
</sect>
<sect id="sec_73">  Example codes.

  <sect1 id="sec_p_7_1"> <tt>excode_5_1.f90</tt>
<p>
<example>
PROGRAM ex_5_1
  !
  IMPLICIT NONE
  !
  REAL :: Grade
  CHARACTER(LEN = 2), DIMENSION(1:5) :: List_Grades=(/'D ','C ','B ','A ','A+'/)
  INTEGER :: IN
  ! READ NOTE
  PRINT *, "Student mark??"
  READ *, Grade
  !
  IF (Grade>=0.0.AND.Grade<5.0) THEN 
     IN=1
  ELSE IF (Grade>=5.0.AND.Grade<7.0) THEN 
     IN=2
  ELSE IF (Grade>=7.0.AND.Grade<9.0) THEN 
     IN=3
  ELSE IF (Grade>=9.0.AND.Grade<10.0) THEN 
     IN=4
  ELSE IF (Grade==10.0) THEN 
     IN=5
  ELSE
     IN=0
  ENDIF
!
  IF (IN==0) THEN
     PRINT *, "The input : ", Grade," has a wrong value. Only [0,10]"
  ELSE
     PRINT *,  "The student grade is ", List_Grades(IN)
  ENDIF
!
END PROGRAM EX_5_1
</example>
</sect1>
<sect1 id="sec_p_7_2">  <tt>excode_5_2.f90</tt>
<p>
<example>
PROGRAM ex_5_2
  !
  IMPLICIT NONE
  !
  REAL :: Grade
  INTEGER :: Index, Integer_Grade
  CHARACTER(LEN=2), DIMENSION(1:5) ::  List_Grades=(/'D ','C ','B ','A ','A+'/)
  ! READ Grade
  PRINT *, "Nota del estudiante?"
  READ *, Grade
  !
  Integer_Grade = NINT(Grade)
  !
  SELECT CASE (Integer_Grade)
  CASE (0:4) 
     Index = 1
  CASE (5,6) 
     Index = 2
  CASE (7,8) 
     Index = 3
  CASE (9) 
     Index = 4   
  CASE (10) 
     Index = 5
  CASE DEFAULT 
     Index = 0
  END SELECT
  !
  IF (Index==0) THEN
     PRINT *, "The input grade : ", Grade," is out of bounds. Only  [0,10]."
  ELSE
     PRINT 100, Grade, List_Grades(Index)
  ENDIF
  !
100 FORMAT(1X,'Student grade is ',F4.1,' (',A3,')')
  !
END PROGRAM EX_5_2
</example>
</sect1>
<sect1 id="sec_p_7_3">  <tt>excode_5_3.f90</tt>
<p>
<example>
PROGRAM ex_5_3
  !
  IMPLICIT NONE
  !
  REAL :: PIover2 = ASIN(1.0)
  REAL :: ANGLE1 = 0.0, ANGLE2 = 0.0
  INTEGER :: I
  !
  DO I = 0, 16, 2
     ANGLE1 = I*PIO2/4.0
     !
     WRITE(*,*)
     WRITE(*,*) 'Cos(',I/2,'PI/4) = ',COS(ANGLE1),'; Cos(',I/2,'PI/4) = ',COS(ANGLE2)
     WRITE(*,*) 'Sin(',I/2,'PI/4) = ',SIN(ANGLE1),'; Sin(',I/2,'PI/4) = ',SIN(ANGLE2)
     WRITE(*,*) 
     !
     ANGLE2 = ANGLE2 + PIO2/2.0
     !
  ENDDO
END PROGRAM ex_5_3
</example>
</sect1>
<sect1 id="sec_p_7_4">  Programa ejemplo_5_4.f90
<p>
<example>
PROGRAM excode_5_4
  !
  IMPLICIT NONE
  !
  REAL :: X_val = 0.0 
  REAL :: X_app = 0.0, X_sum = 0.0
  INTEGER :: I_flag = 1, I_count = 0
  !
  ! Taylor Series:  SIN(X) = X - X^3/3! + X^5/5! - X^7/7! + ... 
  WRITE(*,*) "Introduce the angle X (RAD) :"
  READ(*,*) X_val
  !
  I_count = 1
  X_app = X_val
  X_sum = X_val
  !
  PRINT*, '         Order     Approx.    SIN(X)       Approx. - SIN(X)'
  !
  DO WHILE (I_flag == 1) 
     !
     PRINT*, I_count, X_app, SIN(X_val), X_app - SIN(X_val)
     !
     X_sum = X_sum*(-1)*X_val*X_val/((I_count*2+1)*(I_count*2))
     X_app = X_app + X_sum
     !
     I_count = I_count + 1
     !
     WRITE(*,*) "STOP? (0 yes, 1 no)"
     READ(*,*) I_flag
     IF (I_flag /= 1 .AND. I_flag /= 0) I_flag = 1
     !
  ENDDO
  !
END PROGRAM excode_5_4
</example>
</sect1>

</sect>

</chapt>

<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!--                         Clase 5 -> 6                    -->
<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<chapt id="clase_5"><heading><tt>INPUT/OUTPUT</tt> (I)</heading> 
<sect id="sec_51"> Objectivos

<p>
The main aims of this lesson are the following:


<enumlist>  
  <item> present how to make use of the standard <prgn>bash</prgn> redirection for reading and writing data in <prgn>Fortran</prgn>.

<item> present the <tt>FORMAT</tt> statement, as well as its differents descriptors and its use with the commands  <tt>PRINT</tt>
and <tt>WRITE</tt>.

<item> get a basic knowledge about file handling in <prgn>Fortran</prgn> with the commands <tt>OPEN</tt>, <tt>CLOSE</tt>, and <tt>WRITE</tt>.
</enumlist>  
</sect>

<sect id="sec_52"> Main Items.

<p>

<list>  
<item> <prgn>bash</prgn> shell redirection
<p>
The standard input and output (<tt>STDIN/STDOUT</tt>) redirection in 
<tt>bash</tt> with <tt>&lt;</tt> and <tt>&gt;</tt> allows
a <prgn>Fortran</prgn> program in a simple and direct way to read from
and write to a file.


<p>
  As an example, the following commands run from a terminal execute a program called <tt>a.out</tt>. Its output is sent to a file called <tt>output.dat</tt> in the first case. In the second case, the program reads its input from a file called <tt>input.dat</tt>, instead of the standard option, the keyboard. In the third case bot options are combined. 
<p>
<example>
a.out &gt; output.dat
a.out &lt; input.dat
a.out &lt;input.dat &gt; output.dat
</example>

<p> The assignment number 4 can be quite done quite easily making use of standard redirection.

<p> The error output (<tt>STDERR</tt>) can be redirected too as follows
<p>
<example>
a.out 2&gt; output.dat
a.out 2&gt;&amp;1 ouput.dat
</example>
<p>
  In the second case <tt>STDERR</tt> and <tt>STDOUT</tt> are merged together in file <tt>output.dat</tt>.

  <item>In order to gain a finer control of the format of input and output statementes the so called <em>format descriptors</em> are introduced.  We have make use of the default options or free format up to now, indicated with the symbol <tt>*</tt> as in <tt>READ(*,*)</tt>, <tt>READ*</tt>, and <tt>PRINT*</tt>.

    <p>To specify a particular format for the input and output in the above mentioned commands the syntax used is <tt>PRINT</tt> <var>nlin</var>, <var>output_list</var>, or <tt>READ</tt> <var>nlin</var>, <var>output_list</var>; where  <var>nlin</var> is a label driving to a <tt>FORMAT</tt> statement with the necessary descriptors and <var>output_list</var> are the constant and variables that will be read or written. It is possible to include directly the descriptors in the statement.

<p> The format descriptors in <prgn>FORTRAN</prgn>, due to historical reasons (line printers), treated the first character as a control character. If the first character is
<p>
<enumlist>
<item> <tt>0</tt> : double spacing.
<item> <tt>1</tt> : new page.
<item> <tt>+</tt> : no spacing. Print over the previous line.
<item> <tt>blank</tt> : simple spacing. 
</enumlist>
<p>
  But this is not anymore true unless you are using a line printer (quite bizarre situation in the XXI century).

  <p>The format descriptors can fix the vertical position in a line of text, alter the horizontal position of characters in a line, control the display of integers (<tt>I</tt>), floats (<tt>F</tt>
and <tt>E</tt>), strings <tt>A</tt> and logical variables (<tt>L</tt>).
<p>
The following symbols are used
<p>
<enumlist>
<item> <var>c</var> : column number
<item> <var>d</var> : number of digits after decimal point (real values)
<item> <var>m</var> : minimum number of digits displayed
<item> <var>n</var> : number of spaces
<item> <var>r</var> : times a descriptor is repeated
<item> <var>w</var> : number of characters affected by  a descriptor
</enumlist>

<p>
Descriptors in I/O operations
<enumlist>
<item> Integers: <tt>I</tt>: General form <var>r</var><tt>I</tt><var>w</var>
  <p>
    This descriptor indicates that <var>r</var> integer values will be read or written, and they occupy <var>w</var> characters or columns. The number is right justified and if the number of digits is less than the number of spacings the rest of the space is filled with space characters. The example
<p>
<example>
PRINT 100, I, I*I
100 FORMAT(' ',I3, ' squared is ', I6)
</example>
<p> outputs a space, a three-digit integer, the string '<tt> squared is </tt>' and finish with the square of the variable <tt>I</tt>, with a maximum number of six digits. More examples can be found in  <ref id="sec_p_5_1">, where the reader can see the effect of having a number with more digits than the allocated space in the format. In this example we also include the <tt>X</tt> descriptor, such that <var>n</var><tt>X</tt> includes <var>n</var> space characters in the output, or skip <var>n</var> characters from the input.

<p>
Format descriptors can be also included directly in the  <tt>PRINT</tt> statement, though the resulting code is generally less readable.
<p>
<example>
PRINT "(' ',I3, ' squared is ', I6)", I, I*I
</example>


<p> As can be seen in code example <ref id="sec_p_5_1"> we can have an arithmetic overflow in a variable and the solution is shown in example <ref id="sec_p_5_2">.  

      <item> Real values descriptor <tt>F</tt>: General form  <var>r</var><tt>F</tt><var>w.d</var>
	<p>
	  Where <var>w</var> is the total number of columns used to fit the number, <var>d</var> the number of figures after the decimal point, and <var>r</var> the number of times this descriptor is applied.

<p>
For example if the descriptor is <tt>F7.3</tt> the number will be
displayed with three figures after the decimal point and occupies
seven spaces. This implies that this format descriptor is valid for
numbers between <tt>-99.999</tt> and <tt>999.999</tt>. The truncated
decimal part of the number is properly rounded. It may happens that as
a result of the truncation the number has more digits than
expected. The output will be changed for <var>w</var> asterisk
characters (<tt>*</tt>). In source code <ref id="sec_p_5_3"> we face such kind of problems.
	      
<item>  Real descriptor <tt>E</tt>: General form <var>r</var><tt>E</tt><var>w.d</var>
      
<p> Introduces scientific notation.  The number that multiplies the
  power of ten takes values between 0.1 to 1.0. This case differs from
  the previous one that some space should be devoted to the
  exponent. In fact, apart from the multiplier, it is needed one
  character for the sign of the number if it is negative, another
  character for the decimal point, another one for the <tt>E</tt>
  symbol (stands for Exponent), and the magnitude and sign of the
  exponent.  Therefore the minimum size in this case is <var>w =
  d+7</var>. Example code <ref id="sec_p_5_4"> is identical to
  example <ref id="sec_p_5_3"> changing the <tt>F</tt> descriptors
  to <tt>E</tt>. This change facilitates to work with numbers whose
      value vary into a big range.
      
<item>  Real data descriptor  <tt>ES</tt>: general format <var>r</var><tt>ES</tt><var>w.d</var>
<p> It allows the use of the standard scientific notation, with the
  factor that multiplies the power of ten taking velues in the range
  1.0  to 10.0. Apart from this it is similar to the previous float
  descriptor. 

<item>  Logical data descriptor <tt>L</tt>: general format <var>r</var><tt>L</tt><var>w</var>
<p> 
Logical or boolean data only take the values <tt>TRUE</tt>
or <tt>FALSE</tt> and the output of this descriptor will be a right justified <tt>T</tt> or <tt>F</tt>.

<item>  Character descriptor <tt>A</tt>: general format <var>r</var><tt>A</tt>
or <var>r</var><tt>A</tt><var>w</var>
<p>
This format implies that there are <var>r</var> string
fields <var>w</var> character wide. If <var>w</var> is missing the
string is taken with the same length of the character variable. The
example <ref id="sec_p_5_5"> shows how this descriptor is used.

<item>  <tt>X</tt> descriptor: general format <var>n</var><tt>X</tt>
<p>
The <tt>X</tt> descriptor  controls horizontal displacement, and it
implies that  <var>n</var> spaces should be included in the
output. You can find an example of this descriptor in source code  <ref id="sec_p_5_5">.
<item>  Descriptor <tt>T</tt>:
<p>
El descriptor <tt>T</tt><var>c</var> controla el desplazamiento
horizontal e indica que se salte directamente a la
columna  <var>c</var>.

<item> <tt>/</tt>  descriptor:
<p>
The <tt>/</tt>descriptor flush the output buffered and feeds a new
line. It does not need to be included between commas. 

<item> The repetition of a set of descriptors can be easily indicated
  combining them between parentheses. For example 
  <p>
<example>
100 FORMAT(1X, I6, I6, F9.3, F9.3, F9.3)
</example>
can be simplified to
<p>
<example>
100 FORMAT(1X, 3(I6, F9.3))
</example>
</enumlist>

<item> <prgn>Fortran</prgn> allows file manipulation with the
  commands <tt>OPEN</tt>, <tt>WRITE</tt> and <tt>CLOSE</tt>. Other, more
  advanced, commands are  <tt>REWIND</tt> and <tt>BACKSPACE</tt>.

<p>
The <tt>OPEN</tt> command allows to initiate a file. The simplest
instance of this command is 
<p>
<example>
OPEN(UNIT=<var>unit_number</var>,FILE='<var>filename</var>')
</example> 
<p>
where the file name and the integer number of the associated unit are indicated. 
The file is therefore associated to this number for any Read/Write
operation. We can write something in this file as follows
<p>
<example>
OPEN(UNIT=33, FILE='program_OUT.dat')
WRITE(UNIT=33,FMT=100) <var>variable_lists</var>
</example> 

<p>which indicates that the data included in <var>variable_list</var>
  will be written in the file associated with unit number 33,
  following the  format specified in line labeled <tt>100</tt>. It is
  possible to abbreviate the command to <tt>WRITE(33,100)</tt>
  or <tt>WRITE(33,*)</tt> if free format is required. In order to send
  the data
  to  <tt>STDOUT</tt>,  <tt>WRITE(UNIT=6,<var>format</var>)</tt>, <tt>WRITE(6,*)</tt>, <tt>WRITE(*,*)</tt>,
  or <tt>PRINT*</tt>  are all valid and equivalent commands. Standard
  input <tt>STDIN</tt> is associated with unit
  number <tt>5</tt> or the  <tt>*</tt> symbol<footnote><tt>STDERR</tt> is associated with unit <tt>0</tt>.</footnote>. 

<p>
Once the write process takes place the unit should be closed using
the statement <tt>CLOSE(UNIT=<var>unit_number</var>)</tt>. In our case
<p>
<example>
CLOSE(UNIT=33)
</example> 
<p>
Example <ref id="sec_p_5_6"> shows how data are sent to a file and
    introduces the intrinsic function <tt>CPU_TIME</tt> that allows to
    estimate the cpu time spent in a program and its different
    sections. 
<p>
The <tt>OPEN</tt> command can be more specific, adding the following arguments:
<p>
<example>
OPEN(UNIT=<var>unit_number</var>,FILE=<var>file_name</var>,STATUS=<var>file_status</var>, ACTION=<var>action_var</var>, IOSTAT=<var>integer_var</var>)
</example> 
<p>
  These options control the following aspects:
<p>
<enumlist>
<item> <tt>STATUS=<var>file_status</var></tt>
  <p>
    The constant or variable <var>file_status</var> is of character
    type and can take the following values:
<list>
<item>  'OLD'
<item>  'NEW'
<item>  'REPLACE'
<item>  'SCRATCH'
<item>  'UNKNOWN'
</list>
<item> <tt>ACTION=<var>action_var</var></tt>
<p>
The constant or variable <var>action_var</var> is of character type
and can have the following forms:
<list>
<item>  'READ'
<item>  'WRITE'
<item>  'READWRITE'
</list>
<p>By default. archives are opened with both read and write
  permissions active. 
<item> <tt>IOSTAT=<var>integer_var</var></tt>
<p>
The variable <var>integer_stat</var> is of integer type and gives
feedback about the success of the opening of the file. If the final
value is <tt>0</tt> the file has been correctly opened. Any other
value indicates a problem.
</enumlist>
<p>
A complete example will be
<p>
<example>
INTEGER ierr
OPEN(UNIT=33, FILE='input_program.dat', STATUS='OLD', ACTION='READ', IOSTAT=ierr)
</example> 
<p>
If we want to create a file to store some data:
<p>
<example>
INTEGER ierr
OPEN(UNIT=33, FILE='output_program.dat', STATUS='NEW', ACTION='WRITE', IOSTAT=ierr)
</example> 
<item> It is possible some degree of  control on the access to the
  elements stored sequentially using the commands
<p>
<example>
BACKSPACE(UNIT = <var>unit_number</var>)
REWIND(UNIT = <var>unit_number</var>)
</example> 

<p> The <tt>BACKSPACE</tt> statement set the register one line back in
  the associated file while <tt>REWIND</tt> move back to the first
  register of the file. 

<item> The default is to open formatted files. Thus, the following two
  statements are equivalent
<p>
<example>
OPEN(UNIT=33,FILE='<var>file_name</var>')
OPEN(UNIT=33,FILE='<var>file_name</var>',FORM='FORMATTED')
</example> 
<p>
Formatted files can be edited and read by the user, but they have a
couple of cons. Data storage and reading in formatted files takes longer than in
unformatted files and there may be some precision loss in float
numbers. In order to write data without format files should be opened
including the  <tt>FORM='UNFORMATTED'</tt> option:
<p>
<example>
OPEN(UNIT=33,FILE='<var>file_name</var>',FORM='UNFORMATTED')
</example> 
<p>
To write in a file declared unformatted the <tt>WRITE</tt> command
takes the form
<p>
<example>
WRITE(UNIT=33) <var>variable_list</var>
</example> 

</list>

<p>
  The combination of fortran descriptors and different kinds of loop in a code can be found in the example <ref id="sec_p_5_7">. This program reads a data file (a template of this fila can be found under the program, and can be saved removing the trailing <tt>!</tt> symbols). When the program opens the datafile with <tt>OPEN</tt> it uses the <tt>STATUS =
    'OLD'</tt> and <tt>ACTION='READ'</tt> options. It reads the file, skipping some files making use of a   <tt>REPEAT UNTIL</tt> loop, until it arrives to a line that provides the number of data pairs in the file<footnote>This is achieved making use of the <tt>IERR = </tt> <var>label</var> option in the <tt>READ</tt> command. opción indica que si se ha producido un
    error de lectura el programa debe saltar a la línea marcada
    por <var>label</var>.</footnote>. Knowing the number of data pairs the appropriate matrices are allocated and the points are read and saved into vectors <tt>data_X</tt> and <tt>data_Y</tt>, and computes the maximum (minimum) value of <tt>data_X</tt> (<tt>data_Y</tt>) making use of the intrinsic functions <tt>MAXVAL</tt> and <tt>MINVAL</tt> (see <ref id="sec_81">).

</sect>
<sect id="sec_53">  Example Codes

  <sect1 id="sec_p_5_1"> <tt>excode_6_1.f90</tt>
<p>
<example>
PROGRAM ex_6_1
  !
  IMPLICIT NONE
  !
  ! Variables
  INTEGER :: i, big=10
  !
  DO i=1,20
     PRINT 100, i, big
     big=big*10
  END DO
  !
  ! Format Statements
100 FORMAT(1X, '10 to the ',I3,2X,'=',2X,I12)
  !
END PROGRAM ex_6_1
</example>
</sect1>
  <sect1 id="sec_p_5_2">  <tt>excode_6_2.f90</tt>

<p>
<example>
PROGRAM ex_6_2
  !
  IMPLICIT NONE
  !
  INTEGER, PARAMETER :: Long=SELECTED_INT_KIND(16) ! 64 bits integer
  INTEGER :: i
  INTEGER (KIND=Long) :: big=10 
  !
  DO i=1,18
     !
     PRINT 100, i, big
100  FORMAT(1X, '10 to the ', I3, 2X, '=', 2X, I16)
     !
     big=big*10
     !
  END DO
  !
END PROGRAM ex_6_2
</example>
  </sect1>
  <sect1 id="sec_p_5_3">  <tt>excode_6_3.f90</tt>
    
    <p>
      <example>
PROGRAM ex_6_3
  ! Program to produce numeric overflow and underflow
  IMPLICIT NONE
  INTEGER :: I
  REAL     :: small = 1.0
  REAL     :: big   = 1.0
!
  DO i=1,45
     PRINT 100, I, small, big
100  FORMAT(' ',I3,' ',F9.4,' ',F9.4)
     !
     small = small/10.0
     big = big*10.0
     !
  END DO
END PROGRAM ex_6_3
</example>
</sect1>
  <sect1 id="sec_p_5_4">  <tt>excode_6_4.f90</tt>

<p>
<example>
PROGRAM ex_6_4
  ! Program to produce numeric overflow and underflow
   IMPLICIT NONE
  INTEGER :: I
  REAL     :: small = 1.0
  REAL     :: big   = 1.0
!
  DO i=1,45
     PRINT 100, I, small, big
100  FORMAT(' ',I3,' ',E10.4,' ',E10.4)
     !
     small = small/10.0
     big = big*10.0
     !
  END DO
END PROGRAM ex_6_4
</example>
</sect1>
  <sect1 id="sec_p_5_5">  <tt>excode_6_5.f90</tt>

<p>
<example>
PROGRAM ex_6_5
  ! Program to compute the Body Mass Index (Quetelet Index) according to the formula:
  !    BMI = (weight (kg))/(height^2 (m^2)) 
  !
  IMPLICIT NONE
  CHARACTER (LEN=25) :: Name
  INTEGER :: height_cm = 0, weight_kg = 0 ! height in cm and weight in kg
  REAL     :: height_m = 0.0 ! height in m units
  REAL     :: BMI ! Body Mass Index
  !
  PRINT*,  'Full Name:'; READ*, Name
  !
  PRINT*, 'Weight (kg)?:'; READ*, weight_kg
  !
  PRINT*, 'Height (cm)?:'; READ*, height_cm
  !
  height_m = height_cm/100.0
  BMI = weight_kg/(height_m**2)
  !
  PRINT 100, Name, BMI, BMI 
100  FORMAT(1X,A ' BMI  is ', F10.4,' or ', E10.4)
!
END PROGRAM ex_6_5
</example>
</sect1>
  <sect1 id="sec_p_5_6">  <tt>excode_6_6.f90</tt>
<p>
<example>
PROGRAM ex_6_6
!
  IMPLICIT NONE
  INTEGER , PARAMETER :: N=1000000
  INTEGER , DIMENSION(1:N) :: X
  REAL    , DIMENSION(1:N) :: Y
  INTEGER :: I
  REAL :: T
  REAL    , DIMENSION(1:5) :: TP
  CHARACTER*10 :: COMMENT
!
  OPEN(UNIT=10,FILE='/tmp/ex_6_6.txt')
!
  CALL CPU_TIME(T)
!
  TP(1)=T
  COMMENT=' Initial Time : '
  PRINT 100, COMMENT, TP(1)
  !
  DO I=1,N
     X(I)=I
  END DO
  !
  CALL CPU_TIME(T)
  !
  TP(2)=T-TP(1)
  COMMENT = ' Integer vector. Time :  '
  PRINT 100,COMMENT,TP(2)
  !
  Y=REAL(X)
  !
  CALL CPU_TIME(T)
  !
  TP(3)=T-TP(1)-TP(2)
  COMMENT = ' Real vector. Time :  '
  !
  PRINT 100,COMMENT,TP(3)
  !
  DO I=1,N
     WRITE(10,200) X(I)
200  FORMAT(1X,I10)
  END DO
  !
  CALL CPU_TIME(T)
  TP(4)=T-TP(1)-TP(2)-TP(3)
  !
  COMMENT = ' Write Integer vector. Time :  '
  PRINT 100,COMMENT,TP(4)
  !
  DO I=1,N
     WRITE(10,300) Y(I)
300  FORMAT(1X,f10.0)
  END DO
  !
  CALL CPU_TIME(T)
  TP(5)=T-TP(1)-TP(2)-TP(3)-TP(4)
  !
  COMMENT = ' Write Real vector. Time :  '
  PRINT 100,COMMENT,TP(5)
  !
100 FORMAT(1X,A,2X,F7.3)
END PROGRAM ex_6_6
</example>
</sect1>
  <sect1 id="sec_p_5_7">  <tt>excode_6_7.f90</tt>
<p>
<example>
PROGRAM ex_6_7
  !
  IMPLICIT NONE
  !
  REAL , DIMENSION(:), ALLOCATABLE :: X_vec, Y_vec ! Data Vectors
  INTEGER :: Index, Ierr, Numpoints = 0
  REAL :: Max_x, Min_y
  CHARACTER(LEN=64) :: Filename
  !
  ! READ FILENAME
  READ(5,*) Filename
  ! OPEN FILE (READONLY)
  OPEN( UNIT=10, FILE=Filename, STATUS='OLD', ACTION='READ' )
  !
  DO
     READ(UNIT=10, FMT=100, ERR=10) Numpoints
     IF (Numpoints /= 0) EXIT
10   READ (UNIT=10, FMT=*) ! JUMP ONE LINE
     CYCLE
  ENDDO
  !
  PRINT*, 'NUMPOINTS = ', Numpoints
  !
  ! ALLOCATE X, Y VECTORS
  ALLOCATE(X_vec(1:NUMPOINTS), STAT = IERR)
  IF (Ierr /= 0) STOP 'X_vec MEM ALLOCATION FAILED'
  ALLOCATE(Y_vec(1:NUMPOINTS), STAT = IERR)
  IF (Ierr /= 0) STOP 'Y_vec MEM ALLOCATION FAILED'
  !
  DO I = 1, Numpoints
     !
     READ(UNIT=10, FMT=110) X_vec(I), Y_vec(I)
     !
  ENDDO
  !
  Max_x = MAXVAL(X_vec)
  Min_y = MINVAL(Y_vec)
  !
  PRINT*, "MAXIMUM X VALUE = ", Max_x
  PRINT*, "MINIMUM Y VALUE = ", Min_y
  ! DEALLOCATE AND CLOSE FILE
  DEALLOCATE(X_vec, STAT = IERR)
  IF (Ierr /= 0) STOP 'X_vec MEM DEALLOCATION FAILED'
  DEALLOCATE(Y_vec, STAT = IERR)
  IF (Ierr /= 0) STOP 'Y_vec MEM DEALLOCATION FAILED'
  !
  CLOSE(10)
  ! FORMAT STATEMENTS
100 FORMAT(19X,I3)
110 FORMAT(F6.3,1X,F6.3)
  !
END PROGRAM ex_6_7
!# Remark 1
!# Remark 2
!Useless line 1
!Useless line 2
!Number of points = 4
!+1.300;-2.443
!+1.265;-1.453
!+1.345;-8.437
!+1.566;+4.455
!+1.566;+4.455
!+3.566;+7.755
!+1.566;+4.457
!+2.366;+2.454
!+1.566;+4.405
!+0.566;+9.450
!+1.545;+4.465
!+9.566;+6.455
!+1.466;+8.405
!+0.566;+7.055


</example>
</sect1>

</sect>

</chapt>
<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!--                         Clase 6 -> 7                    -->
<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<chapt id="clase_6"><heading> <tt>Input/Output</tt> (II)</heading> 
<sect id="sec_61"> Objectives

<p>
The main aims of this session consist of:

<enumlist>  
<item> presenting the use of <tt>FORMAT</tt> in reading operations.
<item> considering basic techniques about the reading of files in  <prgn>Fortran</prgn>.
<item> presenting possible alternatives to the
  standard <tt>I/O</tt>: <em>here documents</em> and
  the <tt>NAMELIST</tt> type input.
<item> presenting internal files.
</enumlist>  
<p>
This chapter is very much linked with the previous one, having an
emphasis in reading data instead of writing them. We present
interesting options for providing input data to a program. Formatted
input is seldom used with the keyboard, though it is very important
when reading data stored in a file. 
</sect>

<sect id="sec_62"> Main items.

<p>

<list>  
<item> The <tt>FORMAT</tt> statement acts in a completely equivalent
  way to the one explained in  <ref id="clase_5">.

<item> A useful option of the <tt>READ</tt> command
  is <tt>IOSTAT</tt>. It allows to detect if the read process has
  reached the end-of-file:
<p>
<example>
READ(UNIT=<var>unit_number</var>, FMT=<var>format_label</var>, IOSTAT=<var>integer_var</var>) <var>variable_list</var>
</example>

<p> Thus, if if we read a set of data, e.g. coordinates in space
  as <tt>(var_X,var_Y,var_Z)</tt> from a file and we do not know the
  total number of coordinates included we can proceed as follows
<p>
<example>
num_data = 0
readloop: DO
   !
   READ(UNIT=33, FMT=100, IOSTAT=io_status) var_X, var_Y, var_Z
   !
   ! Check reading
   IF (io_status /= 0) THEN
     ! Error in the input or EOF
     EXIT
   ENDIF
   num_data = num_dat + 1
   !   work with the coordinates
   !
      ......
   !
   ! Format statement
100 FORMAT(1X, 3F25.10)
   ! 
ENDDO readloop
</example>

<p> The integer variable <tt>num_data</tt> is a counter that indicates
  the number of points read and the integer <tt>io_status</tt> check
  if the reading has been correct. 


<item> The example  <ref id="sec_p_6_1"> presents how to read array
    slices from a file were students' grades are indicated in rows (students) and
    columns (subjects). 

<item> A convenient way to convey the input to a <prgn>Fortran</prgn>
  program is making use of a <em>here  documents</em>  from
  the  <prgn>bash shell</prgn>.

  <p> A <em>here  document</em> is a brief script<footnote>From The Free On-line Dictionary of Computing (8 July 2008) [foldoc]:
  <em>script</em>: A program written in a scripting
  language.</footnote>, such that apart from compiling (if necessary)
  and running the program, the input is given in a way that comments
  can also be included. Example <ref id="sec_p_6_2"> is a program that
  computes the roots of a second order algebraic equation <tt>y =
  A*x**2 + B*x + C</tt> and <tt>ej_here_file</tt> included
  in  <ref id="sec_p_6_22">, is an application of a <em>here 
  document</em>. In order to run this program proceed as follows

<p>
<example>
. ej_here_file
</example>

<item> The <tt>namelist</tt> format is quite informative, consisting
  in a list of values assigned to variables labeled with their
  names. The command  <tt>NAMELIST</tt> syntax is
<p>
<example>
NAMELIST/<var>var_group_name</var>/ <var>var1 [var2 var3 ... ]</var>
</example>
<p>
This statement define a set of variables assigned to
the <var>var_group_name</var> and should appear in the program prior
to any executable statemnt. The reading of variables included in
a  <tt>NAMELIST</tt> is done with a  <tt>READ</tt> statement where,
instead of specifying a format with the  <tt>FMT</tt> option, is used
the option  <tt>NML</tt> as follows<footnote>The <tt>NAMELIST</tt>
    format could also be used with the  <tt>WRITE</tt> command to save
    labeled variables.</footnote>
<p>
<example>
READ(UNIT=<var>unit_number</var>, NML=<var>var_group_name</var>, [...])
</example>
<p>
The  <tt>NAMELIST</tt> file with the variable information must start
each line with the "&amp;" character, followed by the variable group
name, <var>var_group_name</var>, ending the line with the character
"/". The values in the file can be in different lines but always
between the two mentioned characters.
<p>
Program <ref id="sec_p_6_3"> is almost identical to
  program <ref id="sec_p_6_2"> but it has been modified to make use of
  a <tt>namelist</tt> file, called <tt>sec_order.inp</tt>, included as <ref id="sec_p_6_32">.

<item> In the example  <ref id="sec_p_6_4"> you can find
    an <em>internal file</em>, where the I/O takes place in an
    internal buffer instead than in a file. This is rather handy to
    treat data of unknowkn format, reading them first in a character
    variable and treating them later, or to handle data mixing
    variables of different types, like character and integer. This is
    the case in the example <ref id="sec_p_6_4"> where a series of
    different numbered files are defined and data saved in them. 
    sucesivamente. In this example the intrinsic
    function  <tt>TRIM</tt> is used to remove trailing spaces from the
    variable <tt>pref</tt>.
</list>  
</sect>
<sect id="sec_63">  Example Codes

<sect1 id="sec_p_6_1">  Programa ejemplo_7_1.f90
<p>
<example>
PROGRAM EJEMPLO_7_1
  IMPLICIT NONE
  !Definicion de variables
  INTEGER , PARAMETER :: NROW=5
  INTEGER , PARAMETER :: NCOL=6
  REAL , DIMENSION(1:NROW,1:NCOL)   :: RESULT_EXAMS = 0.0
  REAL , DIMENSION(1:NROW)          :: MEDIA_ESTUD = 0.0
  REAL , DIMENSION(1:NCOL)          :: MEDIA_ASIGN = 0.0
  INTEGER :: R,C
  !
  ! Abrir fichero para lectura
  OPEN(UNIT=20,FILE='notas.dat',STATUS='OLD') 
  !
  DO R=1,NROW
     READ(UNIT=20,FMT=100) RESULT_EXAMS(R,1:NCOL),MEDIA_ESTUD(R) ! Lectura de notas y luego de promedio
     100 FORMAT(6(2X,F4.1),2X,F5.2) ! Se leen 6 numeros seguidos y luego un septimo 
  ENDDO
  READ (20,*) ! Saltamos una linea con esta orden
  READ (20,110) MEDIA_ASIGN(1:NCOL) ! 
110 FORMAT(6(2X,F4.1))
!
! IMPRESION DE LAS NOTAS EN LA SALIDA ESTANDAR
  DO R=1,NROW
     PRINT 200, RESULT_EXAMS(R,1:NCOL), MEDIA_ESTUD(R)
200  FORMAT(1X,6(1X,F5.1),' = ',F6.2)
  END DO
  PRINT *,'  ====  ====  ====  ====  ====  ==== '
  PRINT 210, MEDIA_ASIGN(1:NCOL)
210 FORMAT(1X,6(1X,F5.1))
END PROGRAM EJEMPLO_7_1
</example>
</sect1>
<sect1 id="sec_p_6_2">  <tt>excode_7_2.f90</tt>
<p>
<example>
PROGRAM ex_7_2
! Second degree equation solver
! y = A*x**2 + B*x + C
  IMPLICIT NONE
  ! Variables
  REAL :: A = 0.0
  REAL :: B = 0.0
  REAL :: C = 0.0
  REAL, DIMENSION(2) :: SOL
  REAL :: TEMP
  INTEGER :: I
  !
  ! Input: A, B, C
  READ*, A 
  READ*, B
  READ*, C 
  !
  ! Calculations
  TEMP = SQRT(B*B-4.0*A*C)
  !
  SOL(1) = (-B+TEMP)/(2.0*A)
  SOL(2) = (-B-TEMP)/(2.0*A)
  !
  !
  ! 
  DO I=1, 2
     PRINT 200, I, SOL(I)
200  FORMAT(1X,'SOLUTION ', I2,' = ',F18.6)
  END DO
!
END PROGRAM EX_7_2
</example>
</sect1>
<sect1 id="sec_p_6_22">  Script <tt>ej_here_file</tt>
<p>
<example>
# Compile..
gfortran -o second_order  excode_7_2.f90
# And Run...
./second_order &lt;&lt;eof
2.0     # A
1.0     # B
-4.0    # C
eof
</example>
</sect1>
<sect1 id="sec_p_6_3">  <tt>excode_7_3.f90</tt>
<p>
<example>
PROGRAM ex_7_3
  ! Solving second order algebraic equation
  ! y = A*x**2 + B*x + C
  IMPLICIT NONE
  ! Variables
  REAL :: A = 0.0
  REAL :: B = 0.0
  REAL :: C = 0.0
  REAL, DIMENSION(2) :: SOL
  REAL :: TEMP
  INTEGER :: I
  !
  !     NAMELIST DEFINITION
  NAMELIST/INP0/ A, B, C
  !     NAMELIST FILE
  OPEN(UNIT=10,FILE='sec_order.inp',STATUS='OLD')
  !     Inpot of A, B, C
  READ(10,INP0)
  !
  ! Calculations
  TEMP = SQRT(B*B-4.0*A*C)
  !
  SOL(1) = (-B+TEMP)/(2.0*A)
  SOL(2) = (-B-TEMP)/(2.0*A)
  !
  !
  ! OUTOPUT 
  DO I=1, 2
     PRINT 200, I, SOL(I)
200  FORMAT(1X,'SOLUTION ', I2,' = ',F18.6)
  END DO
!
END PROGRAM EX_7_3
</example>
</sect1>
<sect1 id="sec_p_6_32">   <tt>namelist</tt> input file
<p>
<example>
#
#       INPUT FILE FOR excode_7_3.f90
#
 &amp;INP0 A=2.0, B=1.0, C=-4.0 /

</example>
</sect1>
<sect1 id="sec_p_6_4">  <tt>excode_7_4.f90</tt>
<p>
<example>
PROGRAM ex_7_4
  !
  ! Internal file example
  !
  IMPLICIT NONE
  ! Variables
  REAL :: x_var
  INTEGER :: unit_n, index_X
  CHARACTER(LEN=65) :: filename
  CHARACTER(LEN=56) :: pref
  !
  PRINT*, "Introduce file name preffix: "
  READ(*,*) pref
  !
  DO unit_n = 10, 20
     !
     WRITE(filename, '(A, "_", i2,".dat")') TRIM(pref), unit_n
     OPEN(UNIT = unit_n, FILE = filename, STATUS = "UNKNOWN", ACTION = "WRITE")
     !
     DO index_X = 0, 100
        x_var = REAL(index_X)*0.01
        WRITE(unit_n, '(1X,2ES14.6)') x_var, SIN(REAL(unit_n)*x_var)
     ENDDO
     !
     CLOSE(UNIT = unit_n)
     !
  ENDDO
!
END PROGRAM ex_7_4
</example>
</sect1>

</sect>
</chapt>

<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!--                         Clase 8                         -->
<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<chapt id="clase_8"><heading>Subprograms (I): FUNCTIONS</heading> 
<sect id="sec_81"> Objectives

<p>
The main aims of this lesson are the following:

<enumlist>  
<item> presenting the advantages of using functions, subroutines and modules.
<item> presenting the function concept in <prgn>Fortran</prgn>.
<item> showing the different types of functions:
  intrinsic, generic, elemental, transformational, and internal.
<item> making possible the definition of new functions by the user. 
<item> evinving the difference beyween external and internal
  functions. 
</enumlist>  
<p>
The use of subporgrams allows a more structured and efficient
programming owing to
<p>
<list>  
<item> the possibility of developing and testing different subtasks in
  an independent manner. 
<item> it makes possible to recycle subprograms in different programs,
  diminishing the necessary time for coding. 
<item> the isolation in different subtasks of possible errors and the
  minimization of unexpected side effects, due to variable encapsulation.
</list>  
</sect>

<sect id="sec_82"> Main items.

<p>
We first focus in functions and will follow with subroutines and
modules. 
<p>
<list>  
<item> General characteristics of functions.
<p>
The main characteristics of a function are:
<list>
<item> May require the input of one or several arguments. 
<item> Arguments can take the form of an expression.
<item> In general, a function produces a single output, which is a
  function of the arguments, and this output is of scalar type though
  in some cases it also can be of an array type. 
<item> The arguments can be of different types. 
</list>
<p> There are more than one hundred predefined functions
  in <prgn>Fortran</prgn>, highly tested, and of easy usage. E.g. we
  need trigonometric functions we can make use of the following:
<list>
<item> <tt>Y = SIN(X)</tt>
<item> <tt>Y = COS(X)</tt>
<item> <tt>Y = TAN(X)</tt>
</list>
<p> where <tt>X</tt> and <tt>Y</tt> are real variables<footnote>You
  should take into account that in <prgn>Fortran</prgn> angles are
  expressed in radian units.</footnote>
<p> This predefined functions are called <em>intrinsic
    functions</em>. In this link <url id="http://gcc.gnu.org/onlinedocs/gfortran/Intrinsic-Procedures.html#Intrinsic-Procedures"
name="URL"> you can find a complet list of the intrinsic functions at
    your disposal with the <prgn>gfortran</prgn> compiler.

    <p>In general intrinsic functions are also <em>generic</em>, which
    means that they can admit different argument types, with the
    exception of the functions <tt>LGE</tt>, <tt>LGT</tt>, <tt>LLE</tt>, and <tt>LLT</tt>.

<item> <em>Elemental</em> functions may have as an argument both
  scalars or vectors. The example source codes <ref id="sec_p_8_1">
  and <ref id="sec_p_8_2"> show the elemental and generic character of
  some intrinsic functions. When an elemental function is applied to
      an array the fucntions is applied to each array element.

<item> Other type of functions are of <em>inquiry</em> type, giving
  information about the characterictics of an array,
  e.g. the <tt>SIZE</tt> and <tt>ALLOCATED</tt> functions. Examples of
  the latter are found in <ref id="sec_p_5_7"> and <ref id="sec_p_9_3">. 

<p>
  <em>Transformational</em> functions transform between different
  data types, e.g.  <tt>REAL</tt> and <tt>TRANSPOSE</tt>, or functions
  that work with time data variables as <tt>SYSTEM_CLOCK</tt>
  and <tt>DATE_AND_TIME</tt>.

<item> Conversion between data types:
  <list>
    <item> <tt>REAL(i)</tt>: integer <tt>i</tt> is converted to a
  float. The argument <tt>i</tt> can be an integer, a double precision
  real or a complex number.
<item> <tt>INT(x)</tt>: transforms the real variable <tt>x</tt> to an
  integer, truncating the decimal part. No rounding is
  performed. The <tt>x</tt>  variable can be a real, double precision
  real, or a complex variable.
<item> The functions that follow allow to transform from real to
  integer values with an adequate control:
  <list>
    <item> <tt>CEILING(x)</tt>: real value <tt>x</tt> to the minimum
    integer     value larger than or equal than <tt>x</tt>.
    <item> <tt>FLOOR(x)</tt>: real value <tt>x</tt>  to the maximum
    integer value less than or equal than <tt>x</tt>.
    <item> <tt>NINT(x)</tt>: round the real value <tt>x</tt> to the
    nearest integer.
  </list>
<item> <tt>DBLE(a)</tt>: transforms <tt>a</tt> to double precision. The
  argument can be integer, real, or complex.
<item > <tt>CMPLX(x)</tt> or <tt>CMPLX(x,y)</tt>: transform to complex
  values, where the second argument is the imaginary part.
</list>

<item> Apart from the intrinsic functions, user defined functions can
  also be added. The definition of a function requires, apart from the
  function definition, the way the function is invoked from a
  program.

  <p>
    A user defined function is created according to the following
    scheme. 
<p>
<example>
FUNCTION <var>fun_name</var>(<var>argument_list</var>)
  IMPLICIT NONE
  Declaration section (including arguments and fun_name)
  ....
  Local variables declaration
  ....
  <var>fun_name</var> = expr
  RETURN ! Optional
END FUNCTION <var>fun_name</var>
</example>

<p>
The example <ref id="sec_p_8_3"> shows how to define and invoke a
  function computing the greatest common divisor of two integers. The
  following considerations should be taken into account:
<list>
<item> This example is built with two blocks, the main program and the
  function definition. 
  bloque con el programa principal y un segundo bloque donde se define
  la función. The function definition can be carried out in a separate
  file. In such case both filenames should be provided to the
  compiler. 
  <item> The variables defined in a function are <em>local</em> with
  respect to the main program variables.
<item> The  <tt>MCD</tt> function is of <tt>INTEGER</tt>
  type. Therefore, in principle, the function output should be of
  integer type.
<item> The <tt>INTENT(IN)</tt> attribute characterizing the <tt>A</tt> and <tt>B</tt> variables:
<p>
<example>
INTEGER , INTENT(IN) :: A,B 
</example>
<p>
marks these two as input variables, whose values cannot be modified in
the body of the function. 
</list>
<p> Every function argument needs to be difined with
  the <tt>INTENT(IN)</tt> attribute to avoid the modification of their
  values with unforeseen consequences.
<item> It is possible to define <em>internal</em> functions,
  restrained to certain code segment. Such functions cannot be called
  from any program unit but the one that defines them. This is
  achieved with the <tt>CONTAINS</tt> statement (e.g. <ref id="sec_p_8_4"> and <ref id="sec_p_8_5">). 
</list>
</sect>
<sect id="sec_83">   Example Codes
  <sect1 id="sec_p_8_1">  <tt>excode_8_1.f90</tt>
<p>
<example>
PROGRAM ex_8_1
  IMPLICIT NONE
  ! Variable Definition
  INTEGER, PARAMETER :: Long=SELECTED_REAL_KIND(18,310)
  !
  REAL (KIND=Long), PARAMETER :: DPI = ACOS(-1.0_Long) ! Pi number double precision
  REAL (KIND=Long) :: DANGLE, DANGLERAD
  !
  REAL, PARAMETER :: PI = ACOS(-1.0) ! Pi number single precision
  REAL :: ANGLERAD
  !
  PRINT*, 'ANGLE INPUT (Degrees)'
  READ*, DANGLE
  PRINT*
  ! Transform to  RAD
  DANGLERAD = DPI*DANGLE/180.0_Long
  ANGLERAD  = PI*DANGLE/180.0
  !
  PRINT 20, DANGLE, DANGLERAD
  PRINT 21, DANGLE, ANGLERAD
  PRINT*
  PRINT*
  !
  PRINT 22, DANGLERAD, SIN(DANGLERAD), COS(DANGLERAD), SIN(DANGLERAD)**2+COS(DANGLERAD)**2,&
       1.0_Long-(SIN(DANGLERAD)**2+COS(DANGLERAD)**2) 
  PRINT*
  PRINT 22, ANGLERAD, SIN(ANGLERAD), COS(ANGLERAD), SIN(ANGLERAD)**2+COS(ANGLERAD)**2,1.0 - (SIN(ANGLERAD)**2+COS(ANGLERAD)**2) 
  !
20 FORMAT (1X, 'An angle of ',F14.8,' degrees = ', F14.8, ' rad. (dp)')
21 FORMAT (1X, 'An angle of ',F14.8,' degrees = ', F14.8, ' rad. (sp)')
22 FORMAT (1X, 'ANGLE ',F14.8,', SIN = ', F13.9, ', COS =',F13.9,/'SIN**2+COS**2 = ', F18.14, ', 1 - SIN**2+COS**2 = ', F18.14)
END PROGRAM EX_8_1
</example>
</sect1>
  <sect1 id="sec_p_8_2">  <tt>excode_8_2.f90</tt>
<p>
<example>
PROGRAM ex_8_2
  IMPLICIT NONE
  ! VARIABLE DEFINITION
  INTEGER , PARAMETER :: NEL=5
  REAL, PARAMETER :: PI = ACOS(-1.0) ! Pi number
  REAL, DIMENSION(1:NEL)   :: XR = (/ 0.0, PI/2.0, PI, 3.0*PI/2.0, 2.0*PI/)
  INTEGER , DIMENSION(1:NEL):: XI = (/ 0, 1, 2, 3, 4/)
  !
  PRINT*, 'Sin  ', XR, ' = ', SIN(XR)
  PRINT*, 'LOG10  ', XR, ' = ', LOG10(XR)
  PRINT*, 'REAL ', XI, ' = ', REAL(XI)
END PROGRAM ex_8_2
</example>
</sect1>
<sect1 id="sec_p_8_3">  Programa ejemplo_8_3.f90
<p>
<example>
PROGRAM ex_8_3
  IMPLICIT NONE
  INTEGER :: I,J,Result
  INTEGER :: MCD
  EXTERNAL MCD
  PRINT *,' INTRODUCE TWO INTEGERS:'
  READ *,I,J
  RESULT = MCD(I,J)
  PRINT *,' THE GREATEST COMMON DIVISOR OF ',I,' AND ',J,' IS ',RESULT
END PROGRAM ex_8_3
!
INTEGER FUNCTION MCD(A,B)
IMPLICIT NONE
INTEGER , INTENT(IN) :: A,B
INTEGER :: Temp
  IF (A < B) THEN
     Temp=A
  ELSE
     Temp=B
  ENDIF
  DO WHILE ((MOD(A,Temp) /= 0) .OR. (MOD(B,Temp) /=0))
     Temp=Temp-1
  END DO
  MCD=Temp
END FUNCTION MCD
</example>
</sect1>
<sect1 id="sec_p_8_4">  Programa ejemplo_8_4.f90
<p>
<example>
PROGRAM ex_8_4
  IMPLICIT NONE
  ! Internal function example:
  ! E(v) = we (v+1/2) - wexe (v+1/2)**2.
  INTEGER :: V, VMAX
  REAL :: we, wexe, Energy
  PRINT *,' Vmax?:'
  READ *, VMAX
  PRINT *,' we and wexe?'
  READ *,we, wexe
  DO V = 0, VMAX
     Energy = FEN(V)
     PRINT 100, V, Energy
  ENDDO
100 FORMAT(1X,'E(',I3,') = ',F14.6)
CONTAINS 
!
  REAL FUNCTION FEN(V)
    IMPLICIT NONE
    INTEGER , INTENT(IN) :: V
    FEN = we*(V+0.5)-wexe*(V+0.5)**2
  END FUNCTION FEN
!
END PROGRAM EX_8_4
</example>
</sect1>
<sect1 id="sec_p_8_5">  <tt>excode_8_5.f90</tt>
<p>
<example>
PROGRAM ex_8_5
  !
  ! Simple program to compute the prime divisors of a given integer number.
  !
  IMPLICIT NONE
  INTEGER :: NUMVAL
  INTEGER :: NUM
  !
  READ*, NUMVAL ! input
  !
  DO
     NUM = QUOT(NUMVAL)
     IF (NUM == NUMVAL) THEN
        PRINT*, NUM
        EXIT
     ELSE
        PRINT*, NUMVAL/NUM, NUM
        NUMVAL = NUM
     ENDIF
  ENDDO
  !
CONTAINS
  ! 
  INTEGER FUNCTION QUOT(NUM1)
    !
    INTEGER, INTENT(IN) :: NUM1
    INTEGER :: I
    !
    QUOT = NUM1
    !
    DO I = 2, NUM1-1
       IF (MOD(NUM1,I) == 0) THEN
          QUOT = NUM1/I
          EXIT
       ENDIF
    ENDDO
    !
  END FUNCTION QUOT
  !
END PROGRAM ex_8_5
</example>
</sect1>
<sect1 id="sec_p_8_6">  <tt>excode_8_6.f90</tt>
<p>
<example>
PROGRAM ex_8_6
  !
  ! Program to evaluate a 1D potential function on grid points
  !
  IMPLICIT NONE
  !
  REAL, DIMENSION(:), ALLOCATABLE :: X_grid, Pot_grid
  !
  REAL :: X_min, X_max, Delta_X
  REAL :: V_0 = 10.0, a_val = 1.0
  INTEGER :: Index, X_dim
  INTEGER :: Ierr
  !
  !
  INTERFACE Potf
     ELEMENTAL FUNCTION Potf(Depth, Inv_length, X)
       !
       IMPLICIT NONE
       !
       REAL, INTENT(IN) :: Depth, Inv_length, X
       REAL :: Potf
       !
     END FUNCTION Potf
  END INTERFACE Potf
  !
  !
  READ(*,*), X_min, X_max, X_dim ! input minimum and maximum values of X and number of points
  !
  ALLOCATE(X_grid(1:X_dim), STAT = Ierr)
  IF (Ierr /= 0) THEN
     STOP 'X_grid allocation failed'
  ENDIF
  !
  ALLOCATE(Pot_grid(1:X_dim), STAT = Ierr)
  IF (Ierr /= 0) THEN
     STOP 'Pot_grid allocation failed'
  ENDIF
  !
  !
  Delta_X = (X_max - X_min)/REAL(X_dim - 1)
  !
  X_grid = (/ (Index, Index = 0 , X_dim - 1 ) /)
  X_grid = X_min + Delta_X*X_grid
  !
  Pot_grid = Potf(V_0, a_val, X_grid)
  !
  DO Index = 1, X_dim
     PRINT*, X_grid, Pot_grid
  ENDDO
  !
  DEALLOCATE(X_grid, STAT = Ierr)
  IF (Ierr /= 0) THEN
     STOP 'X_grid deallocation failed'
  ENDIF
  !
  DEALLOCATE(Pot_grid, STAT = Ierr)
  IF (Ierr /= 0) THEN
     STOP 'Pot_grid deallocation failed'
  ENDIF
  !
  !
END PROGRAM ex_8_6
!
ELEMENTAL FUNCTION Potf(Depth, Inv_length, X)
  !
  IMPLICIT NONE
  !
  REAL, INTENT(IN) :: Depth, Inv_length, X
  !
  REAL :: Potf
  !
  Potf = -Depth/(COSH(Inv_length*X)**2)
  !
END FUNCTION Potf
</example>
</sect1>
<sect1 id="sec_p_8_7">  <tt>excode_8_7.f90</tt>
<p>
<example>
PROGRAM ex_8_7
  !
  ! Program to characterize an array making use of inquiry functions
  !
  IMPLICIT NONE
  !
  REAL, DIMENSION(:,:), ALLOCATABLE :: X_grid
  INTEGER :: Ierr
  !
  ! 
  ALLOCATE(X_grid(-20:20,0:50), STAT = Ierr)
  IF (Ierr /= 0) THEN
     STOP 'X_grid allocation failed'
  ENDIF
  !
  WRITE(*, 100) SHAPE(X_grid)
100 FORMAT(1X, "Shape :        ", 7I7)
  !
  WRITE(*, 110) SIZE(X_grid)
110 FORMAT(1X, "Size :         ", I7)
  !
  WRITE(*, 120) LBOUND(X_grid)
120 FORMAT(1X, "Lower bounds : ", 7I6)
  !
  WRITE(*, 130) UBOUND(X_grid)
130 FORMAT(1X, "Upper bounds : ", 7I6)
  !
  DEALLOCATE(X_grid, STAT = Ierr)
  IF (Ierr /= 0) THEN
     STOP 'X_grid deallocation failed'
  ENDIF
  !
END PROGRAM ex_8_7
</example>
</sect1>
</sect>

</chapt>
<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!--                         Clase 9                         -->
<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<chapt id="clase_9"><heading>Subprograms (II): subroutines</heading> 
<sect id="sec_91"> Objectives

<p>
The main aims of this session consist of:

<enumlist> 
<item> considering the differences between functions and subroutines and
  in what cases are the latter useful. 
<item> introducing the user to the subroutine definition procedures.
<item> explaining subroutine arguments roles.
<item> defining the commands <tt>CALL</tt> and <tt>INTERFACE</tt>.
<item> explaining the <em>scope</em> of the variables of a subroutine
  and the role of local variables and of variables with
  the  <tt>SAVE</tt> attribute.
<item> presenting the different ways of passing an array as an
  argument to a subroutine. 
<item> defining the so called automatic arrays.
</enumlist>
</sect>

<sect id="sec_92"> Main items.
<p>
<enumlist> 
<item> The use of  subroutines favors a structured programming through
  the definition of subtasks and avoiding code duplication. Together
  with functions, they make
  possible to access to an extense collection of libraries for
  multiple applications.
<item> To better explain this point we will make use of a simple
  example: solving a second order equation. A possible way of dividing
  this task in simpler subtasks is as follows 
<enumlist>
  <item> Main program.
  <item> Equation coefficient input.
  <item> Solution of the algebraic equation.
  <item> Solution output.
</enumlist>
The program  <ref id="sec_p_9_1"> follows closely this scheme with two
  subroutines: <tt>Interact</tt> and <tt>Solve</tt>.
<item> The syntax to define a subroutine is as follows
<p>
<example>
  SUBROUTINE <var>subroutine_name</var>(arguments [optional])
         IMPLICIT NONE
         Arguments (dummy variables) definition (INTENT)
         ...
         Local variables definition
         ...
         Execution Section
         ...
         [RETURN]
 END SUBROUTINE  <var>subroutine_name</var>
</example>
<p>
Argumentos are called <em>dummy</em> because their definition is not
followed by a memory assignment, this assignment will take place once
the subroutine is called. 
<p>
Each subroutine is compiled in a separate way by the compiler, what
allows for the use of <em>local variables</em> that may have the same
name in different subroutines and the main program without clashing
due to the different scopes.
<p>
This scheme can be seen in program <ref id="sec_p_9_1">.
<item> A subroutine is invoked with the  <tt>CALL</tt> command as follows
<p>
<example>
CALL subroutine_name(arguments [optional])
</example>
<p> Once the subroutine is executed the program flow returns to the
  program unit where the subroutine was invoked, after the 
<tt>CALL</tt> statement. The  subroutine determines when to return to
the invoking unit once the <tt>RETURN</tt> statement is found or if
the subroutine execution ends.

<item> The subroutine and the main program data flow takes place
  through the arguments, also called subroutine parameters. Arguments
  in the subroutine definition are  <em>dummy</em> variables, with an
  associated type but no space reserved in memory. For example,
  the <tt>E</tt>, <tt>F</tt>, and <tt>G</tt> arguments in
  the <tt>Solve</tt> subroutine in the code <ref id="sec_p_9_1"> are
  of  <tt>REAL</tt> type, but without any memory allocation. Only when
  the subroutine is invoked with the <tt>CALL
Solve(P,Q,R,Root1,Root2,IFail)</tt> command the
  arguments <tt>E</tt>, <tt>F</tt>, and  <tt>G</tt> are replaced by
  pointers to the main program variables  <tt>P</tt>, <tt>Q</tt>,
and <tt>R</tt>. This is why it is of great importance that the data
  type of variables and arguments match correctly. 
<item> Some of the arguments provide the necessary input for the
  subroutine, while others are output arguments that send the
  subroutine results to the invoking program unit. Mixed character
  input/output arguments can also be used.

<p> Those parameters that are only input parameters should be defined
  using the  <tt>INTENT(IN)</tt> attribute that, as it is the case
  with functions, indicate that the argument values cannot be altered
  in the subroutine. 
  
<p> If the parameters are output, the arguments should be defined with
  the  <tt>INTENT(OUT)</tt> attribute, to avoid taking into account
  the input value of the argument.
<p> Mixed character arguments should be defined with
  the  <tt>INTENT(INOUT)</tt> attribute.
  
<p> The subroutine <tt>Solve</tt> in example <ref id="sec_p_9_1">
    provides examples for the three cases. It is advisable to label
    with the corresponding <tt>INTENT</tt> attribute every argument.

<item> In order to facilitate the accordance between variables in the
  invoking program unit and the subroutine the user can defined the so
  called <em>interface blocks</em>. The example <ref id="sec_p_9_2">
  is the same code than <ref id="sec_p_9_1"> to which interface blocks
  have been added for the <tt>Interact</tt> and <tt>Solve</tt> subroutines.

<item> As in the case of functions, those variables defined in a
  subroutine that are not arguments are considered as local
  variables. For example, the <tt>Interact</tt> subroutine
  in <ref id="sec_p_9_1"> has a local 
variable called <tt>IO_Status</tt>.

<p> 
In general the local variables are created once the subroutine is
called and the value is lost unless they possess the  <tt>SAVE</tt>
attribute, that makes possible to store the variable value from one
call to the next. For example

<p>
<example>
INTEGER, SAVE:: It = 0
</example>
<p>
The variable <tt>It</tt> value is kept among different calls to the subroutine.

<p> As it is the case for functions, it is possible that the
  subprogram has access to the main program variables making use of
  the <tt>CONTAINS</tt> statement. This solution can be hard to scale
  once programs acquire certain size and it is not very advisable.


<item> When the argument of a subroutine is of <em>array</em> type it
  is necessary to provide some extra information about the matrix to
  avoid the possible access of the subroutine to wrong memory
  areas. In order to achieve this there are three possible ways of
  specifying the dimensiones of an array included in a subroutine list of
  arguments. 

<enumlist>
<item> <em>explicit-shape approach</em>:

<p>
In this case the dimensions of the matrices are included as arguments
in the subroutine call and the matrices are declared making use of
these arguments. For example, if in a subroutine
called  <tt>test_pass</tt> an input vector (<tt>space_vec_in</tt>) and
an output vector (<tt>space_vec_out</tt>) with equal dimensions are
used, if we make use of the <em>explicit-shape approach</em> the
subroutine starts as follows

<p>
<example>
SUBROUTINE test_pass(space_vec_in, space_vec_out, dim_vec)
         IMPLICIT NONE
         INTEGER, INTENT(IN) :: dim_vec
         REAL, INTENT(IN), DIMENSION(1:dim_vec) :: space_vec_in
         REAL, INTENT(OUT), DIMENSION(1:dim_vec) :: space_vec_out
         ......
 END SUBROUTINE test_pass 
</example>

<item> <em>assumed-shape approach</em>:

<p> The main difference with the previous case is that either the
  corresponding <tt>INTERFACE</tt> block is added or, as explained
  in <ref id="clase_10">, the subroutine is embedded in a module.



<p>
The example code <ref id="sec_p_9_3"> calculates the mean, the
    median<footnote>The <em>median</em> value of a set of data is
    defined as the value of the list such that half the values of the
    set are less than it and the other half are greater than
    it. Median and mean are identical for symmetrical data
    distributions. The calculation of the median requires the sorting
    of the set of values.</footnote>, the variance and the standard
    deviation of a set of random numbers following a continuous
    uniform distribution. Several points of interest
    has been marked in the program.
    
<list>
<item> <em>(1-3)</em> Dynamic memory storage using
  the <tt>ALLOCATABLE</tt> attribute and the <tt>ALLOCATE</tt>
  statement. Notice that the array is a vector (<tt>DIMENSION(:)</tt>)
  and this piece of info needs to be also include in the <em>interface
    block</em>. The use of the <em>interface block</em> in cases like
  this one is mandatory. The statement  <em>(3)</em>, <tt>ALLOCATE(X(1:N), STAT =
IERR)</tt> defines the length of the <tt>X</tt> vector. We also use
  the optional field  <tt>STAT</tt> to check whether the array has
  been correctly dimensioned or not. Only if the output of this field,
  in the <tt>IERR</tt> variable, is zero the dynamic allocation has
  worked flawlessly.
<p>
<example>
  REAL , ALLOCATABLE , DIMENSION(:) :: X  !! (1)

  ...

  INTERFACE
     SUBROUTINE STATS(X,N,MEAN,STD_DEV,MEDIAN)
       IMPLICIT NONE

       ...

       REAL      , INTENT(IN) , DIMENSION(:)   ::    X  !!  (1)

       ...

     END SUBROUTINE STATS
  END INTERFACE
</example>
<p>
It is important to take into account that an argument of a subroutine
can have the <tt>ALLOCATABLE</tt> attribute, as well as local
subroutine variables, but not <em>dummy</em> variables.

<p> The  <em>assumed shape arguments</em> are nonexistent
  in  <prgn>FORTRAN 77</prgn>, and it is the recommended form of
  transmitting arguments between a main program and a subprogram. In
  this form there is no transmitted information about the dimension of
  the array, and the argument and the main program variable need to
  have equal type, range, and class (<tt>KIND</tt>).

  <item> <em>(4)</em> and <em>(6)</em>: these statements take
    advantage of the <prgn>Fortran 90</prgn> rules to work with vector
    and arrays.
    
<item> <em>(5)</em> In this statement the allocated memory is revoked
  and freed using the <tt>DEALLOCATE</tt> statement. This is not
  mandatory in programs like the present example, though it is
  necessary to do so when the allocatable array has been defined in a
  function of subroutine without the <tt>SAVE</tt> attribute.  

<item> <em>(7)</em> The  <tt>CONTAINS</tt> statement is used to make
  the sorting subroutine <tt>SELECTION</tt> have access to the
  variables of the <tt>STATS</tt> subroutine. This is why in
  the <tt>SELECTION</tt> subroutine with the sorting algorithm  only local variables need to be
  defined. </list>

<p>
The definition of <tt>INTERFACE</tt> blocks is a task simplified
making use of modules, that are introduced in the next chapter. 

<item> <em>assumed-size approach</em>
<p>This case is not advised due to the lack of info in the subroutine
  about the matrix dimensiones. This makes easy to make errors of
  difficult diagnose. Its use is not encouraged.

</enumlist>


<item> Multidimensional arrays. The source code <ref id="sec_p_9_5">
    is an example of how to pass multidimensional arrays as arguments
    of a subroutine as <em>assumed shape arrays</em>. The user defines
    two arrays , <tt>A</tt> and <tt>B</tt>, and the program computes
    the <tt>C</tt> array as the matrix product <tt>A</tt>
    times <tt>B</tt>. Then, the program computes the transpose matrix
    of  <tt>A</tt>. The program makes use of the <prgn>Fortran
    90</prgn> functions <tt>MATMUL</tt> and  <tt>TRANSPOSE</tt>.

<item> Subroutines can contain  <em>automatic
arrays</em>, that may depend on the subroutine argument values. These
  are local array that may not have the  <tt>SAVE</tt> attribute. They
  are created when the subroutine is invoked and destroyed when the
  execution flow leaves the subroutine. It is preferable to
  use  <tt>ALLOCATABLE</tt> arrays.

<item> An argument of <tt>CHARACTER</tt> type is also diffenrent in
  the sense that if such argument is declared with a length  <tt>LEN =
  *</tt>, once the subroutine is called the variable length is the
  legth of the variable in the call.
<p>
The code <ref id="sec_p_9_4">
is a program to which a file name is given and the number of data
pairs stored in the file. The program opens the file and reads the
two-column dataset.  Notice that, due to the variable size of the <tt>CHARACTER</tt>  variable, the
 <em>interface block</em> is required.


<p> The example <ref id="sec_p_9_6"> caluculate two pseudo random
    number vectors with a Gaussian or normal distribution with a
    dimension defined by the user. This is achieved with
    the  <em>Box-Mueller</em> method.

    <p>Two  <tt>ALLOCATABLE</tt> arrays, <tt>X</tt> and <tt>Y</tt> are
      difined and in the internal subroutine <tt>BOX_MULLER</tt> two
      vectors of automatic type are defined: <tt>RANDOM_u</tt> and <tt>RANDOM_v</tt>.

<p> The mean value, the median and the standard deviation are computed
  making use of the <tt>STATS</tt> subroutine in the  source
  code <ref id="sec_p_9_3">. The necessary  <tt>INTERFACE</tt> block
  is included in the main program and the subroutine should be
  compiled in a separate file.

<item> It is important to take into account that when array arguments
  are used as  <em>assumed shape arguments</em> the first index of the
  variable in the subroutine by default takes a value <tt>1</tt>,
  unless it is explicitly indicated. The example  <ref id="sec_p_9_7">
  is a simple case where this initial value is indicated. This program
  cmputes the factorial of the integers in the range
  between <tt>IMIN</tt> and <tt>IMAX</tt>, storing them in a real
  vector.  The program can be compiled making <tt>IMIN = 1</tt>
  or <tt>IMIN = 0</tt> with and without the definition of the initial
  index in the subroutine to check the different outputs. 
</enumlist>
</sect>

<sect id="sec_93"> Example Codes
  <sect1 id="sec_p_9_1">  <tt>excode_9_1.f90</tt>
<p>
<example>
PROGRAM ex_9_1
  !
  IMPLICIT NONE
  ! Simple program with two subroutines.
  ! subroutine (1):: Interact :: Data input.
  ! subroutine (2):: Solve :: Solve second order Eq.
  !
  ! Variables
  REAL :: P, Q, R, Root1, Root2
  INTEGER :: IFail=0
  LOGICAL :: OK=.TRUE.
  !
  CALL Interact(P,Q,R,OK) ! Subrutina (1)
  !
  IF (OK) THEN
     !
     CALL Solve(P,Q,R,Root1,Root2,IFail) ! Subrutina (2)
     !
     IF (IFail == 1) THEN
        PRINT *,' Complex roots'
        PRINT *,' calculation aborted'
     ELSE
        PRINT *,' Roots are ',Root1,' ',Root2
     ENDIF
     !
  ELSE
     !
     PRINT*,' Error in data input program ends'
     !
  ENDIF
  !
END PROGRAM ex_9_1
!
!
SUBROUTINE Interact(A,B,C,OK)
  IMPLICIT NONE
  REAL , INTENT(OUT) :: A
  REAL , INTENT(OUT) :: B
  REAL , INTENT(OUT) :: C
  LOGICAL , INTENT(OUT) :: OK
  INTEGER :: IO_Status=0
  PRINT*,' Type in the coefficients A, B AND C'
  READ(UNIT=*,FMT=*,IOSTAT=IO_Status) A,B,C
  IF (IO_Status == 0) THEN
     OK=.TRUE.
  ELSE
     OK=.FALSE.
  ENDIF
END SUBROUTINE Interact
!
!
SUBROUTINE Solve(E,F,G,Root1,Root2,IFail)
  IMPLICIT NONE
  REAL , INTENT(IN) :: E
  REAL , INTENT(IN) :: F
  REAL , INTENT(IN) :: G
  REAL , INTENT(OUT) :: Root1
  REAL , INTENT(OUT) :: Root2
  INTEGER , INTENT(INOUT) :: IFail
  ! Local variables
  REAL :: Term
  REAL :: A2
  Term = F*F - 4.*E*G
  A2 = E*2.0
  ! if term < 0, roots are complex
  IF(Term < 0.0)THEN
     IFail=1
  ELSE
     Term = SQRT(Term)
     Root1 = (-F+Term)/A2
     Root2 = (-F-Term)/A2
  ENDIF
END SUBROUTINE Solve
</example>
</sect1>
  <sect1 id="sec_p_9_2">  <tt>excode_9_2.f90</tt>
<p>
<example>
PROGRAM ex_9_2
  !
  IMPLICIT NONE
  ! Simple program with two subroutines.
  ! subroutine (1):: Interact :: Data input.
  ! subroutine (2):: Solve :: Solve second order Eq.
  !
  ! Interface blocks
  INTERFACE
     SUBROUTINE Interact(A,B,C,OK)
       IMPLICIT NONE
       REAL , INTENT(OUT) ::  A
       REAL , INTENT(OUT) ::  B
       REAL , INTENT(OUT) ::  C
       LOGICAL , INTENT(OUT) :: OK
     END SUBROUTINE Interact
     SUBROUTINE Solve(E,F,G,Root1,Root2,IFail)
       IMPLICIT NONE
       REAL , INTENT(IN) :: E
       REAL , INTENT(IN) :: F
       REAL , INTENT(IN) :: G
       REAL , INTENT(OUT) :: Root1
       REAL , INTENT(OUT) :: Root2
       INTEGER , INTENT(INOUT) :: IFail
     END SUBROUTINE Solve
  END INTERFACE
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !
  ! Variables
  REAL :: P, Q, R, Root1, Root2
  INTEGER :: IFail=0
  LOGICAL :: OK=.TRUE.
  !
  CALL Interact(P,Q,R,OK) ! Subrutina (1)
  !
  IF (OK) THEN
     !
     CALL Solve(P,Q,R,Root1,Root2,IFail) ! Subrutina (2)
     !
     IF (IFail == 1) THEN
        PRINT *,' Complex roots'
        PRINT *,' calculation aborted'
     ELSE
        PRINT *,' Roots are ',Root1,' ',Root2
     ENDIF
     !
  ELSE
     !
     PRINT*,' Error in data input program ends'
     !
  ENDIF
  !
END PROGRAM ex_9_2
!
!
SUBROUTINE Interact(A,B,C,OK)
  IMPLICIT NONE
  REAL , INTENT(OUT) :: A
  REAL , INTENT(OUT) :: B
  REAL , INTENT(OUT) :: C
  LOGICAL , INTENT(OUT) :: OK
  INTEGER :: IO_Status=0
  PRINT*,' Type in the coefficients A, B AND C'
  READ(UNIT=*,FMT=*,IOSTAT=IO_Status)A,B,C
  IF (IO_Status == 0) THEN
     OK=.TRUE.
  ELSE
     OK=.FALSE.
  ENDIF
END SUBROUTINE Interact
!
!
SUBROUTINE Solve(E,F,G,Root1,Root2,IFail)
  IMPLICIT NONE
  REAL , INTENT(IN) :: E
  REAL , INTENT(IN) :: F
  REAL , INTENT(IN) :: G
  REAL , INTENT(OUT) :: Root1
  REAL , INTENT(OUT) :: Root2
  INTEGER , INTENT(INOUT) :: IFail
  ! Local variables
  REAL :: Term
  REAL :: A2
  Term = F*F - 4.*E*G
  A2 = E*2.0
  ! if term < 0, roots are complex
  IF(Term < 0.0)THEN
     IFail=1
  ELSE
     Term = SQRT(Term)
     Root1 = (-F+Term)/A2
     Root2 = (-F-Term)/A2
  ENDIF
END SUBROUTINE Solve
</example>
</sect1>
  <sect1 id="sec_p_9_3">  <tt>excode_9_3.f90</tt>
<p>
<example>
PROGRAM ex_9_3
  !
  IMPLICIT NONE
  !
  ! Variables
  INTEGER :: N
  REAL , ALLOCATABLE , DIMENSION(:) :: X  !! (1)
  REAL :: M,SD,MEDIAN
  INTEGER :: IERR
  !
  ! interface block   !! (2)
  INTERFACE
     SUBROUTINE STATS(VECTOR,N,MEAN,STD_DEV,MEDIAN)
       IMPLICIT NONE
       INTEGER , INTENT(IN)                    ::  N
       REAL      , INTENT(IN) , DIMENSION(:)   :: VECTOR  !!  (1)
       REAL      , INTENT(OUT)                 :: MEAN
       REAL      , INTENT(OUT)                 :: STD_DEV
       REAL      , INTENT(OUT)                 :: MEDIAN
     END SUBROUTINE STATS
  END INTERFACE
  PRINT *,' Length of random values vector ?'
  READ *,N
  ALLOCATE(X(1:N), STAT = IERR)     !!  (3)
  IF (IERR /= 0) THEN
     PRINT*, "X allocation request denied."
     STOP
  ENDIF
  CALL RANDOM_NUMBER(X)
  X=X*1000             !!  (4)
  CALL STATS(X,N,M,SD,MEDIAN)
  !
  PRINT *,' MEAN = ',M
  PRINT *,' STANDARD DEVIATION = ',SD
  PRINT *,' MEDIAN IS = ',MEDIAN
  !
  IF (ALLOCATED(X)) DEALLOCATE(X, STAT = IERR)   !! (5)
  IF (IERR /= 0) THEN
     PRINT*, "X NON DEALLOCATED!"
     STOP
  ENDIF
END PROGRAM ex_9_3
!
SUBROUTINE STATS(VECTOR,N,MEAN,STD_DEV,MEDIAN)
  IMPLICIT NONE
  ! Defincion de variables
  INTEGER , INTENT(IN)                    ::  N
  REAL      , INTENT(IN) , DIMENSION(:)    ::  VECTOR    !! (1)
  REAL      , INTENT(OUT)                  ::  MEAN
  REAL      , INTENT(OUT)                  ::  STD_DEV
  REAL      , INTENT(OUT)                  ::  MEDIAN
  REAL      , DIMENSION(1:N)              ::  Y
  REAL :: VARIANCE = 0.0
  REAL      :: SUMXI = 0.0, SUMXI2 = 0.0
  !
  SUMXI=SUM(VECTOR)       !! (6)
  SUMXI2=SUM(VECTOR*VECTOR)    !! (6)
  MEAN=SUMXI/N       
  VARIANCE=(SUMXI2-SUMXI*SUMXI/N)/(N-1)
  STD_DEV = SQRT(VARIANCE)
  Y=VECTOR
  ! Ordena valores por proceso de seleccion
  CALL SELECTION
  IF (MOD(N,2) == 0) THEN
     MEDIAN=(Y(N/2)+Y((N/2)+1))/2
  ELSE
     MEDIAN=Y((N/2)+1)
  ENDIF
CONTAINS     !! (7)
  SUBROUTINE SELECTION
    IMPLICIT NONE
    INTEGER :: I,J,K
    REAL :: MINIMUM
    DO I=1,N-1
       K=I
       MINIMUM=Y(I)
       DO J=I+1,N
          IF (Y(J) < MINIMUM) THEN
             K=J
             MINIMUM=Y(K)
          END IF
       END DO
       Y(K)=Y(I)
       Y(I)=MINIMUM
    END DO
  END SUBROUTINE SELECTION
END SUBROUTINE STATS
</example>
</sect1>
  <sect1 id="sec_p_9_4">  <tt>excode_9_4.f90</tt>
<p>
<example>
PROGRAM ex_9_4
  IMPLICIT NONE
  REAL,DIMENSION(1:100)::A,B
  INTEGER :: Nos,I
  CHARACTER(LEN=32)::Filename
  INTERFACE
     SUBROUTINE Readin(Name,X,Y,N)
       IMPLICIT NONE
       INTEGER , INTENT(IN) :: N
       REAL,DIMENSION(1:N),INTENT(OUT)::X,Y
       CHARACTER (LEN=*),INTENT(IN)::Name
     END SUBROUTINE Readin
  END INTERFACE
  PRINT *,' Type in the name of the data file'
  READ '(A)' , Filename
  PRINT *,' Input the number of items in the file'
  READ * , Nos
  CALL Readin(Filename,A,B,Nos)
  PRINT * , ' Data read in was'
  DO I=1,Nos
     PRINT *,' ',A(I),' ',B(I)
  ENDDO
END PROGRAM ex_9_4
SUBROUTINE Readin(Name,X,Y,N)
  IMPLICIT NONE
  INTEGER , INTENT(IN) :: N
  REAL,DIMENSION(1:N),INTENT(OUT)::X,Y
  CHARACTER (LEN=*),INTENT(IN)::Name
  INTEGER::I
  OPEN(UNIT=10,STATUS='OLD',FILE=Name)
  DO I=1,N
     READ(10,*)X(I),Y(I)
  END DO
  CLOSE(UNIT=10)
END SUBROUTINE Readin
</example>
</sect1>
  <sect1 id="sec_p_9_5">  <tt>excode_9_5.f90</tt>
<p>
<example>
PROGRAM ex_9_5
  IMPLICIT NONE
  REAL , ALLOCATABLE , DIMENSION &
       (:,:)::One,Two,Three,One_T
  INTEGER :: I,N
  INTERFACE
     SUBROUTINE Matrix_bits(A,B,C,A_T)
       IMPLICIT NONE
       REAL, DIMENSION (:,:), INTENT(IN) :: A,B
       REAL, DIMENSION (:,:), INTENT(OUT) :: C,A_T
     END SUBROUTINE Matrix_bits
  END INTERFACE
  PRINT *,'Matrix Dimension?'
  READ*,N
  ALLOCATE(One(1:N,1:N))
  ALLOCATE(Two(1:N,1:N))
  ALLOCATE(Three(1:N,1:N))
  ALLOCATE(One_T(1:N,1:N))
  DO I=1,N
     PRINT*, 'Row ', I,'-th of the first array?'
     READ*,One(I,1:N)
  END DO
  DO I=1,N
     PRINT*, 'Row ', I,'-th of the second array?'
     READ*,Two(I,1:N)
  END DO
  CALL Matrix_bits(One,Two,Three,One_T)
  PRINT*,' Result: Matrix Product'
  DO I=1,N
     PRINT *,Three(I,1:N)
  END DO
  PRINT *,' Transpose A^T:'
  DO I=1,N
     PRINT *,One_T(I,1:N)
  END DO
END PROGRAM ex_9_5
!
SUBROUTINE Matrix_bits(A,B,C,A_T)
  IMPLICIT NONE
  REAL, DIMENSION (:,:), INTENT(IN) :: A,B
  REAL, DIMENSION (:,:), INTENT(OUT) :: C,A_T
  C=MATMUL(A,B)
  A_T=TRANSPOSE(A)
END SUBROUTINE Matrix_bits
</example>
</sect1>
  <sect1 id="sec_p_9_6">  <tt>excode_9_6.f90</tt>
<p>
<example>
PROGRAM ex_9_6
  !
  IMPLICIT NONE
  !
  INTEGER :: I, IERR
  REAL, DIMENSION(:), ALLOCATABLE :: X, Y
  REAL :: M, SD, MEDIAN
  ! interface block   
  INTERFACE
     SUBROUTINE STATS(VECTOR,N,MEAN,STD_DEV,MEDIAN)
       IMPLICIT NONE
       INTEGER , INTENT(IN)                    ::  N
       REAL      , INTENT(IN) , DIMENSION(:)   :: VECTOR  
       REAL      , INTENT(OUT)                 :: MEAN
       REAL      , INTENT(OUT)                 :: STD_DEV
       REAL      , INTENT(OUT)                 :: MEDIAN
     END SUBROUTINE STATS
  END INTERFACE
  !
  READ*, I  
  !
  ALLOCATE(X(1:I), STAT = IERR)    
  IF (IERR /= 0) THEN
     PRINT*, "X allocation request denied."
     STOP
  ENDIF
  !
  ALLOCATE(Y(1:I), STAT = IERR)    
  IF (IERR /= 0) THEN
     PRINT*, "Y allocation request denied."
     STOP
  ENDIF
  !
  CALL BOX_MULLER(I)
  !
  PRINT*, X
  CALL STATS(X,I,M,SD,MEDIAN)
  !
  PRINT *,' MEAN = ',M
  PRINT *,' STANDARD DEVIATION = ',SD
  PRINT *,' MEDIAN IS = ',MEDIAN
  !
  IF (ALLOCATED(X)) DEALLOCATE(X, STAT = IERR) 
  IF (IERR /= 0) THEN
     PRINT*, "X NON DEALLOCATED!"
     STOP
  ENDIF
  PRINT*, Y
  CALL STATS(Y,I,M,SD,MEDIAN)
  !
  PRINT *,' MEAN = ',M
  PRINT *,' STANDARD DEVIATION = ',SD
  PRINT *,' MEDIAN IS = ',MEDIAN
  !
  IF (ALLOCATED(Y)) DEALLOCATE(Y, STAT = IERR)   
  IF (IERR /= 0) THEN
     PRINT*, "Y NON DEALLOCATED!"
     STOP
  ENDIF
  !
CONTAINS
  !
  SUBROUTINE BOX_MULLER(dim)
    ! 
    ! Uses the Box-Muller method to create two normally distributed vectors
    !
    INTEGER, INTENT(IN) :: dim
    !
    REAL, PARAMETER :: PI = ACOS(-1.0)
    REAL, DIMENSION(dim) :: RANDOM_u, RANDOM_v ! Automatic arrays
    !
    CALL RANDOM_NUMBER(RANDOM_u)
    CALL RANDOM_NUMBER(RANDOM_v)
    !
    X = SQRT(-2.0*LOG(RANDOM_u))
    Y = X*SIN(2*PI*RANDOM_v)
    X = X*COS(2*PI*RANDOM_v)
    !
  END SUBROUTINE BOX_MULLER
  !
END PROGRAM ex_9_6
!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!
SUBROUTINE STATS(VECTOR,N,MEAN,STD_DEV,MEDIAN)
  IMPLICIT NONE
  ! Arguments
  INTEGER , INTENT(IN)                    ::  N
  REAL      , INTENT(IN) , DIMENSION(:)    ::  VECTOR    !! (1)
  REAL      , INTENT(OUT)                  ::  MEAN
  REAL      , INTENT(OUT)                  ::  STD_DEV
  REAL      , INTENT(OUT)                  ::  MEDIAN
  ! Local Variables
  REAL      , DIMENSION(1:N)              ::  Y
  REAL      :: VARIANCE = 0.0
  REAL      :: SUMXI = 0.0, SUMXI2 = 0.0
  !
  SUMXI=SUM(VECTOR)       !! (6)
  SUMXI2=SUM(VECTOR*VECTOR)    !! (6)
  MEAN=SUMXI/N       
  VARIANCE=(SUMXI2-SUMXI*SUMXI/N)/(N-1)
  STD_DEV = SQRT(VARIANCE)
  Y=VECTOR
  ! Sort values
  CALL SELECTION
  IF (MOD(N,2) == 0) THEN
     MEDIAN=(Y(N/2)+Y((N/2)+1))/2
  ELSE
     MEDIAN=Y((N/2)+1)
  ENDIF
CONTAINS     !! (7)
  SUBROUTINE SELECTION
    IMPLICIT NONE
    INTEGER :: I,J,K
    REAL :: MINIMUM
    DO I=1,N-1
       K=I
       MINIMUM=Y(I)
       DO J=I+1,N
          IF (Y(J) < MINIMUM) THEN
             K=J
             MINIMUM=Y(K)
          END IF
       END DO
       Y(K)=Y(I)
       Y(I)=MINIMUM
    END DO
  END SUBROUTINE SELECTION
END SUBROUTINE STATS
</example>
</sect1>
  <sect1 id="sec_p_9_7">  <tt>excode_9_7.f90</tt>
<p>
<example>
PROGRAM ex_9_7
  !
  IMPLICIT NONE
  !
  INTERFACE
     SUBROUTINE SUBEXAMPLE(IMIN, IMAX, FACT_MAT)
       INTEGER, intent(in) :: IMIN, IMAX
       REAL, DIMENSION(IMIN:), intent(out) :: FACT_MAT
     END SUBROUTINE SUBEXAMPLE
  END INTERFACE
  !
  ! Variables
  REAL, DIMENSION(:), ALLOCATABLE :: FACT_MAT
  INTEGER :: IMIN, IMAX, I
  !
  IMIN = 0
  IMAX = 5
  !
  ALLOCATE(FACT_MAT(IMIN:IMAX))
  !
  PRINT*, "MAIN", SIZE(FACT_MAT)
  !
  CALL SUBEXAMPLE(IMIN, IMAX, FACT_MAT)
  !
  DO I = IMIN, IMAX
     PRINT*, I, FACT_MAT(I)
  ENDDO
  !
END PROGRAM ex_9_7
!!!!!!!!!!
!!!!!!!!!!
SUBROUTINE SUBEXAMPLE(IMIN, IMAX, FACT_MAT)
  !
  IMPLICIT NONE
  INTEGER, intent(in) :: IMIN, IMAX
  REAL, DIMENSION(IMIN:), intent(out) :: FACT_MAT
  ! The subroutine with the next line only would work for IMIN = 1
  !  REAL, DIMENSION(:), intent(out) :: FACT_MAT
  !
  INTEGER :: j,k
  !
  PRINT*, "SUB", SIZE(FACT_MAT)
  !
  DO j = imin, imax
     fact_mat(j) = 1.0
     do k = 2, j
        fact_mat(j) = k*fact_mat(j)
     enddo
  ENDDO
  !
  !
END SUBROUTINE SUBEXAMPLE
</example>
</sect1>
</sect>
</chapt>
<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!--                         Clase 10                        -->
<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<chapt id="clase_10"><heading>Subprograms (III): modules</heading> 
<sect id="sec_101"> Objectives

<p>
The main aims of this session consist of:

<enumlist> 
<item> Presenting modules and their main pros.
<item> Use of modules for variable definition, replacing the
  deprecated <tt>COMMON</tt> block, a feature of <prgn>FORTRAN 77</prgn>.
<item> Use of modules to define and transmit functions and subroutines.
<item> Private and publice variables in a module: variable
  visibility. 
</enumlist>
</sect>

<sect id="sec_102"> Main items.
<p>
<enumlist> 
<item> Modules allow a clearer and more flexible code production. A
  module can encompass

<enumlist>
<item> Global variables declaration.

<p>
Modules in this regard replace the deprecated  <tt>COMMON</tt>
and <tt>INCLUDE</tt> <prgn>FORTRAN 77</prgn> features.

<item>  <tt>INTERFACE</tt> blocks declaration.

<item> Functions and subroutines declaration, avoiding the necessity
  of including <tt>INTERFACE</tt> blocks.

<item> Access control to the different variables, assigning public or
  private character.

<item> Modules allow to pack derived types, functions, subroutines and
  allow the development of an object oriented programming approach in <prgn>FORTRAN</prgn>.
</enumlist>

<p>
The syntax of a module declaration is as follows
<p>
<example>
MODULE <var>module_name</var>
   IMPLICIT NONE
   [SAVE]
     <var>Variable declarations</var>
   [ CONTAINS
     <var>Subprograms definition</var> ]
END MODULE  <var>module_name</var>
</example>
<p> The modules is loaded with the statement <tt>USE
    MODULE <var>module_name</var></tt> that has to preceed the rest of
    the program statements. From a module another module can be
    called. 

<item> Modules allow the transmission of variables between subprogram
  units without arguments. The other main role of modules is, making
  use of the  <tt>CONTAINS</tt> statement, to define functions,
  subroutines and <tt>INTERFACE</tt> blocks.

<p>
The subprograms inclusion in a module informs the compiler about all
the details of them, allowing a fast error detection. Subroutines and
functions in a module and accessed with <tt>USE MODULE</tt> it is said
to be an <em>explicit interface</em>, whereas in other case it is said
to have an <em>implicit interface</em>.

<item> The definition of modules favors the encapsulation of code,
  defining easily reusable code, which is the basis of object oriented
  programming.

  <item> Modules are loaded from other programs or subprograms via the
    <tt>USE</tt> command.


<item> In order to define common variables for several program units
  the deprecated  <tt>COMMON</tt> feature should be avoided. Instead
  the following steps are necessary

<enumlist>
<item> Declare variables in a  <tt>MODULE</tt>.
<item> Give the  variables the  <tt>SAVE</tt> attribute.
<item> Load the modue with the
  statement <tt>USE</tt> <var>module_name</var>) from those program
  units that should access the variables. 
</enumlist>

<p>
As an example, if there are several physical constants that are used
in severla programs we can define a module as follows
<p>
<example>
MODULE PHYS_CONST
  !
  IMPLICIT NONE
  !
  SAVE
  !
  REAL, PARAMETER :: Light_Speed = 2.99792458E08  ! m/s
  REAL, PARAMETER :: Newton_Ctnt = 6.67428E-11    ! m3 kg-1 s-2
  REAL, PARAMETER :: Planck_Ctnt = 4.13566733E-15 ! eV s
  !
  REAL :: Other_variable
  !
END MODULE PHYS_CONST
</example>


<p>
In this module three physical constants are defined (with
the <tt>PARAMETER</tt> attribute) and a fourth variable that is not
kept constant. Any program unit that needs access to these variables
only needs to load the module as follows

<p>
<example>
PROGRAM CALCULUS
  !
  USE PHYS_CONST 
  !
  IMPLICIT NONE
  !
  REAL DISTANCE, TIME
  !
  ...
  DISTANCE = Light_Speed*TIME
  ...
  !
END PROGRAM CALCULUS
</example>




<item> The use of modules allows a safe, portable, and flexible way of
  controlling the precision of the integer and real numbers in the
  program. A possible way to define in a protable way the precision of
  a given code is with a module like  <tt>NUMERIC_KINDS</tt> included
  in  <ref id="sec_p_10_1_mod"> and we can define the precision using
  this module
<p>
<example>
PROGRAM TEST_MINUIT
  !
  USE NUMERIC_KINDS
  !
  IMPLICIT NONE
  !
  ! Variable Definition     
  REAL(KIND=dp), PARAMETER :: PI = 4.0_dp*ATAN(1.0_dp)
  REAL(KIND=dp) :: ENERF
   ....
   .... 
</example>

<p>
This solution enhances the portability of the code and is less error
prone than individually defining the precision for each program
unit. The example code <ref id="sec_p_10_1"> is the same
    than <ref id="sec_p_9_6"> apart from this improvement.



    
  <item> In the source code  <ref id="sec_p_10_2_mod"> we present a
      module, defined with the <tt>MODULE</tt> heading instead
      of <tt>PROGRAM</tt>, for the definition of an
      integers <em>stack</em>. In this case it is worth to notice the
      way the variables <tt>STACK_POS</tt> and <tt>STORE</tt> are
      defined, as <tt>PRIVATE</tt> variables and with
      the <tt>SAVE</tt> attribute.
      

<p> 
<example>
PROGRAM Use_Stack
!
USE Stack     ! Load the module 
!
IMPLICIT NONE
....
....
CALL POP(23); CAL PUSH(20)
....
....
END PROGRAM Use_Stack
</example>

<item> As shown in <ref id="sec_p_10_2_mod">,  variables in a module
    can have either a private or a public character, using
    the <tt>PRIVATE/PUBLIC</tt> attributes. A private variable can not
    be accessed from the calling program unit. The program loading the
    module in the proposed example only can access the <tt>POP</tt>
    and <tt>PUSH</tt> subroutines. The default option
    is  <tt>PUBLIC</tt> ant it's possible to define the attribute in
    the same line of the variable definition.

<p>
<example>
  INTEGER, PRIVATE, PARAMETER :: STACK_SIZE = 500
  INTEGER, PRIVATE, SAVE :: STORE(STACK_SIZE) = 0, STACK_POS = 0
</example>

<item> Sometimes it is possible that there are conflicts between a
  variable or a subprogram defined in a module are in conflict with
  variables or subprograms defined in the calling program unit. In
  order to avoid this problem there exists the possibility of renaming
  the module variables, though this is a last minute solution for
  desperate situations. 

<p>
If, for example, we call the module  <tt>Stack</tt> from a main
program that already has a variable called <tt>PUSH</tt>, we can
rename the module  <tt>PUSH</tt> object to <tt>STACK_PUSH</tt> when
invoking the module.

<p>
<example>
USE Stack, STACK_PUSH => PUSH
</example>

<p> 
Several objects can be simultaneously renamed, separating the list
with commas. 

<item> Es posible hacer que solo algunos elementos del módulo sean accesibles desde el programa que lo invoca con la cláusula <tt>ONLY</tt>, donde también es posible renombrar los objetos si es necesario. Por ejemplo,  con la llamada

<p>
<example>
USE Stack, ONLY: POP, STACK_PUSH => PUSH
</example>

Solamente se accede a <tt>POP</tt> y <tt>PUSH</tt>, y este último se renombra a <tt>STACK_PUSH</tt>.



<item> Source code <ref id="sec_p_10_2"> is a simple program where
    module <ref id="sec_p_10_2_mod"> is used to handle a stack to
    perform integer sums and substraction in reversed Polish notation (RPN).

<p> The RPN does not require the use of parentheses and is faster than
  the usual algebraic notation. If the stack contains, from first to
  last, the numbers <tt>(23, 10, 33)</tt> and we take into account the
  principle 
tenemos en cuenta que un stack se rige por el principio <em>last in,
first out</em>, tendremos que si introducimos un número más
(p.e. <tt>5</tt>) y realizamos las operaciones de suma (<tt>plus</tt>)
y substracción (<tt>minus</tt>) tendremos lo siguiente

<p>
<example>
-       -         -              -
-       23        -              -
23      10        23             -
10      33        10             23
33   ->  5   ->   38 (=33+5) -> -28 (=10-38)

5      plus      minus
</example>

<p>
Para llevar a cabo esta tarea se carga el módulo <tt>Stack</tt>
en <em>(1)</em>. Una vez cargado el módulo podemos acceder a las
subrutinas <tt>POP</tt> y <tt>PUSH</tt> que nos permiten manejar el
stack. En <em>(2)</em> comienza el bucle principal, con la
etiqueta <tt>inloop</tt>, que termina cuando el usuario da como
input <tt>Q</tt>, <tt>q</tt> o <tt>quit</tt>.

<p>
Para controlar este bucle se utiliza una estructura <tt>SELECT CASE</tt>
que comienza en <em>(3)</em>. Esta estructura analiza cuatro casos posibles:
<list>
<item> <em>(4)</em>: salir del programa
<item> <em>(5)</em>: suma
<item> <em>(6)</em>: resta
<item> <em>(7)</em>: introduce número en el stack (<tt>DEFAULT</tt>)
</list>

<p>
En el último caso se transforma la variable de carácter leída en una
variable entera para almacenarla en el stack. 

<p>
Para compilar y correr este programa podemos hacerlo compilando previamente el módulo, si lo hemos salvado en el fichero <file>ejemplo_10_1_Stack.f90</file>
<p>
<example>
$ gfortran -c ejemplo_10_1_Stack.f90
$ gfortran -o ejemplo_10_2 ejemplo_10_2.f90 ejemplo_10_1_Stack.o
</example>

<p>
En un ejercicio se plantean al alumnos diferentes maneras de mejorar
el programa simple  <ref id="sec_p_10_2">.

</enumlist>


</sect>

<sect id="sec_103">  Example codes.
  <sect1 id="sec_p_10_1">  <tt>excode_10_1.f90</tt>
<p>
<example>
PROGRAM ex_10_1
  !
  USE NUMERIC_KINDS
  !
  IMPLICIT NONE
  !
  INTEGER :: I, IERR
  REAL(KIND=dp), DIMENSION(:), ALLOCATABLE :: X, Y
  REAL(KIND=dp) :: M, SD, MEDIAN
  ! interface block   
  INTERFACE
     SUBROUTINE STATS(VECTOR,N,MEAN,STD_DEV,MEDIAN)
       !
       USE NUMERIC_KINDS
       !
       IMPLICIT NONE
       INTEGER , INTENT(IN)                    ::  N
       REAL(KIND=dp)      , INTENT(IN) , DIMENSION(:)   :: VECTOR  
       REAL(KIND=dp)      , INTENT(OUT)                 :: MEAN
       REAL(KIND=dp)      , INTENT(OUT)                 :: STD_DEV
       REAL(KIND=dp)      , INTENT(OUT)                 :: MEDIAN
     END SUBROUTINE STATS
  END INTERFACE
  !
  READ*, I  
  !
  ALLOCATE(X(1:I), STAT = IERR)    
  IF (IERR /= 0) THEN
     PRINT*, "X allocation request denied."
     STOP
  ENDIF
  !
  ALLOCATE(Y(1:I), STAT = IERR)    
  IF (IERR /= 0) THEN
     PRINT*, "Y allocation request denied."
     STOP
  ENDIF
  !
  CALL BOX_MULLER(I)
  !
  PRINT*, X
  CALL STATS(X,I,M,SD,MEDIAN)
  !
  PRINT *,' MEAN = ',M
  PRINT *,' STANDARD DEVIATION = ',SD
  PRINT *,' MEDIAN IS = ',MEDIAN
  !
  IF (ALLOCATED(X)) DEALLOCATE(X, STAT = IERR) 
  IF (IERR /= 0) THEN
     PRINT*, "X NON DEALLOCATED!"
     STOP
  ENDIF
  PRINT*, Y
  CALL STATS(Y,I,M,SD,MEDIAN)
  !
  PRINT *,' MEAN = ',M
  PRINT *,' STANDARD DEVIATION = ',SD
  PRINT *,' MEDIAN IS = ',MEDIAN
  !
  IF (ALLOCATED(Y)) DEALLOCATE(Y, STAT = IERR)   
  IF (IERR /= 0) THEN
     PRINT*, "Y NON DEALLOCATED!"
     STOP
  ENDIF
  !
CONTAINS
  !
  SUBROUTINE BOX_MULLER(dim)
    ! 
    ! Uses the Box-Muller method to create two normally distributed vectors
    !
    INTEGER, INTENT(IN) :: dim
    !
    REAL(KIND=dp), PARAMETER :: PI = ACOS(-1.0_dp)
    REAL(KIND=dp), DIMENSION(dim) :: RANDOM_u, RANDOM_v ! Automatic arrays
    !
    CALL RANDOM_NUMBER(RANDOM_u)
    CALL RANDOM_NUMBER(RANDOM_v)
    !
    X = SQRT(-2.0_dp*LOG(RANDOM_u))
    Y = X*SIN(2.0_dp*PI*RANDOM_v)
    X = X*COS(2.0_dp*PI*RANDOM_v)
    !
  END SUBROUTINE BOX_MULLER
  !
END PROGRAM ex_10_1
SUBROUTINE STATS(VECTOR,N,MEAN,STD_DEV,MEDIAN)
  USE NUMERIC_KINDS
  IMPLICIT NONE
  ! Defincion de variables
  INTEGER , INTENT(IN)                    ::  N
  REAL(KIND=dp)      , INTENT(IN) , DIMENSION(:)    ::  VECTOR    !! (1)
  REAL(KIND=dp)      , INTENT(OUT)                  ::  MEAN
  REAL(KIND=dp)      , INTENT(OUT)                  ::  STD_DEV
  REAL(KIND=dp)      , INTENT(OUT)                  ::  MEDIAN
  REAL(KIND=dp)      , DIMENSION(1:N)              ::  Y
  REAL(KIND=dp)      :: VARIANCE = 0.0_dp
  REAL(KIND=dp)      :: SUMXI = 0.0_dp, SUMXI2 = 0.0_dp
  !
  SUMXI=SUM(VECTOR)       !! (6)
  SUMXI2=SUM(VECTOR*VECTOR)    !! (6)
  MEAN=SUMXI/N       
  VARIANCE=(SUMXI2-SUMXI*SUMXI/N)/(N-1)
  STD_DEV = SQRT(VARIANCE)
  Y=VECTOR
  ! Ordena valores por proceso de seleccion
  CALL SELECTION
  IF (MOD(N,2) == 0) THEN
     MEDIAN=(Y(N/2)+Y((N/2)+1))/2
  ELSE
     MEDIAN=Y((N/2)+1)
  ENDIF
CONTAINS     !! (7)
  SUBROUTINE SELECTION
    IMPLICIT NONE
    INTEGER :: I,J,K
    REAL :: MINIMUM
    DO I=1,N-1
       K=I
       MINIMUM=Y(I)
       DO J=I+1,N
          IF (Y(J) < MINIMUM) THEN
             K=J
             MINIMUM=Y(K)
          END IF
       END DO
       Y(K)=Y(I)
       Y(I)=MINIMUM
    END DO
  END SUBROUTINE SELECTION
END SUBROUTINE STATS
</example>
</sect1>
  <sect1 id="sec_p_10_1_mod">  <tt>excode_10_1_mod.f90</tt>
<p>
<example>
MODULE NUMERIC_KINDS
  ! 4, 2, AND 1 BYTE INTEGERS
  INTEGER, PARAMETER :: &
       i4b = SELECTED_INT_KIND(9), &
       i2b = SELECTED_INT_KIND(4), &
       i1b = SELECTED_INT_KIND(2)
  ! SINGLE, DOUBLE, AND QUADRUPLE PRECISION
  INTEGER, PARAMETER :: &
       sp = KIND(1.0), &
       dp = KIND(1.0D0), &
       qp = SELECTED_REAL_KIND(2*PRECISION(1.0_dp))
END MODULE NUMERIC_KINDS
</example>
</sect1>
  <sect1 id="sec_p_10_2">  <tt>excode_10_2.f90</tt>
<p>
<example>
PROGRAM RPN_CALC
  !
  ! SIMPLE INTEGER RPN CALCULATOR (ONLY SUM AND SUBSTRACT)
  !
  USE Stack                 !!        (1)
  !
  IMPLICIT NONE
  !
  INTEGER :: KEYB_DATA
  CHARACTER(LEN=10) :: INPDAT
  !
  INTEGER :: I, J, K, DATL, NUM, RES
  !
  !
  inloop: DO      !! MAIN LOOP        (2)
     !
     READ 100, INPDAT
     !
     SELECT CASE (INPDAT)   !!        (3)
        !
     CASE ('Q','q','quit')  !! EXIT          (4)
        PRINT*, "End of program"
        EXIT inloop
     CASE ('plus','Plus','PLUS','+')   !! SUM              (5)        
        CALL POP(J)
        CALL POP(K)
        RES = K + J
        PRINT 120, K, J, RES
        CALL PUSH(RES)
     CASE ('minus','Minus','MINUS','-')   !! SUBSTRACT        (6)
        CALL POP(J)
        CALL POP(K)
        RES = K - J
        PRINT 130, K, J, RES
        CALL PUSH(RES)
     CASE DEFAULT !! NUMBER TO STACK  (7)
        !
        DATL = LEN_TRIM(INPDAT)
        !
        RES = 0
        DO I = DATL, 1, -1
           NUM = IACHAR(INPDAT(I:I)) - 48
           RES = RES + NUM*10**(DATL-I)
        ENDDO
        !
        PRINT 110, RES
        CALL PUSH(RES)
     END SELECT
     !
  ENDDO inloop
  !
100 FORMAT(A10)
110 FORMAT(1X, I10)
120 FORMAT(1X, I10,' + ', I10,' = ', I20)
130 FORMAT(1X, I10,' - ', I10,' = ', I20)
END PROGRAM RPN_CALC
</example>
</sect1>
  <sect1 id="sec_p_10_2_mod">  <tt>excode_10_2_mod.f90</tt>
<p>
<example>
MODULE Stack
  ! 
  ! MODULE THAT DEFINES A BASIC STACK
  !
  IMPLICIT NONE
  !
  SAVE
  !
  INTEGER, PARAMETER :: STACK_SIZE = 500
  INTEGER, DIMENSION(STACK_SIZE) :: STORE = 0
  INTEGER :: STACK_POS = 0
  !
  PRIVATE :: STORE, STACK_POS, STACK_SIZE
  PUBLIC :: POP, PUSH
  !
  CONTAINS
    !
    SUBROUTINE PUSH(I)
      !
      INTEGER, INTENT(IN) :: I
      !
      IF (STACK_POS < STACK_SIZE) THEN
         !
         STACK_POS = STACK_POS + 1; STORE(STACK_POS) = I
         !
      ELSE
         !
         STOP "FULL STACK ERROR"
         !
      ENDIF
      !
    END SUBROUTINE PUSH
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    SUBROUTINE POP(I)
      !
      INTEGER, INTENT(OUT) :: I
      !
      IF (STACK_POS > 0) THEN
         !
         I = STORE(STACK_POS); STACK_POS = STACK_POS - 1
         !
      ELSE
         !
         STOP "EMPTY STACK ERROR"
         !
      ENDIF
      !
    END SUBROUTINE POP
    !
END MODULE Stack
</example>
</sect1>
</sect>
</chapt>
<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!--                         Clase 11                        -->
<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<chapt id="clase_11"><heading>Subprogramas (IV)</heading> 
<sect id="sec_111"> Objetivos

<p>
Los objetivos de esta clase son los siguientes:

<enumlist> 
<item> Explicar como se deben gestionar los errores en la invocación de funciones y subrutinas.
<item> Explicar como se pasa el nombre de una función o subrutina como argumento declarando las funciones o subrutinas implicadas con el atributo <tt>EXTERNAL</tt>.
<item> Explicar como se pasa el nombre de una función o subrutina como argumento declarando las funciones o subrutinas en un módulo.
</enumlist>
</sect>
<sect id="sec_112"> Puntos destacables.
<p>
<enumlist> 
<item> Se debe evitar que un programa termine sin que una subprograma
(función o subrutina) devuelva el control al programa que lo ha
invocado. Por ello se debe no usar la orden <tt>STOP</tt> en el
interior de subprogramas. La mejor forma de gestionar errores en una
subrutina, sobre todo aquellos debidos a una incorrecta definición de
los argumentos de entrada de la subrutina, es mediante el uso de
varibles <em>flag</em> (bandera) que marquen que ha tenido lugar un
error. En el siguiente ejemplo se calcula la raíz cuadrada de la
diferencia entre dos números, y la variable <tt>sta_flag</tt> es cero
si la subrutina se ejecuta sin problemas o uno si se trata de calcular
la raíz cuadrada de un número negativo.

<p>
<example>
SUBROUTINE calc(a_1, a_2, result, sta_flag)
   IMPLICIT NONE
   REAL, INTENT(IN) :: a_1, a_2
   REAL, INTENT(OUT) :: result
   INTEGER, INTENT(OUT) :: sta_flag
   !
   REAL :: temp
   !
   temp = a_1 - a_2
   IF (temp >= 0) THEN
      result = SQRT(temp)
      sta_flag = 0
   ELSE
      result = 0.0
      sta_flag = 1
   ENDIF
END SUBROUTINE calc
</example>
<p>
Una vez ejecutada la subrutina se debe comprobar el valor de la variable <tt>sta_flag</tt> para informar si ha existido algún problema.

<item> Al invocar una subrutina los argumentos pasan como una serie de punteros a ciertas posiciones de memoria. Eso permite que como argumento figure una función o subrutina.

<item> En el caso de funciones, cuando se incluye el nombre de una
función en la lista de argumentos se transforma en un puntero a dicha
función. Para ello las funciones han de ser declaradas con el
atributo <tt>EXTERNAL</tt>. Si, por ejemplo, desde un programa
llamamos a una subrutina llamada <tt>evaluate_func</tt> para evaluar
las funciones <tt>fun_1</tt> y <tt>fun_2</tt> podemos hacer algo como
<p>
<example>
PROGRAM test
  IMPLICIT NONE
  REAL :: fun_1, fun_2
  EXTERNAL fun_1, fun_2
  REAL :: x, y, output

  ......

  CALL evaluate_func(fun_1, x, y, output)
  CALL evaluate_func(fun_2, x, y, output)

  ......

END PROGRAM test

SUBROUTINE evaluate_func(fun, a, b, out)
   REAL, EXTERNAL :: fun
   REAL, INTENT(IN) :: a, b
   REAL, INTENT(OUT) :: out
   !
   out = fun(a,b)
END SUBROUTINE evaluate_func
</example>
<p>
En el <ref id="sec_p_11_1"> se muestra un ejemplo en el que se evalua,
dependiendo de la elección del usuario, el producto o el cociente
entre dos números. Dependiendo de la elección se utiliza la
subrutina <tt>Eval_Func</tt>, que acepta como uno de sus argumentos el
nombre de la función que se va a evaluar, <tt>prod_func</tt>
o <tt>quot_func</tt>. Debe indicarse el tipo de variable asociado a la función, pero no se puede especificar el atributo <tt>INTENT</tt>.

<item> También pueden usarse nombres de subrutinas como
argumentos. Para pasar el nombre de una subrutina como argumento dicha
subrutina debe ser declarada con el atributo EXTERNAL. En el siguiente
ejemplo una subrutina llamada <tt>launch_sub</tt> acepta como
argumentos de entrada las variables <tt>x_1</tt> y <tt>x_2</tt> y el
nombre de una subrutina a la que invoca con las variables anteriores
como argumentos y tiene como argumento de salida la
variable <tt>result</tt>.
<p>
<example>
SUBROUTINE launch_sub(x_1, x_2, sub_name, result)
  IMPLICIT NONE
  REAL, INTENT(IN) :: x_1, x_2
  EXTERNAL sub_name
  REAL, INTENT(OUT) :: result


  ......

  CALL sub_name(x_1, x_2, result)

  ......

END SUBROUTINE launch_sub
</example>
<p>
Como puede verse en este ejemplo, el argumento que indica la subrutina
(<tt>sub_name</tt>) no lleva asociado el atributo <tt>INTENT</tt>.  En
el <ref id="sec_p_11_2"> se muestra un ejemplo similar al anterior, en
el que se evalua dependiendo de la elección del usuario el producto o
el cociente entre dos números. Dependiendo de la elección se utiliza
la subrutina <tt>Eval_Sub</tt>, que acepta como uno de sus argumentos
el nombre de la subrutina que se va a evaluar, <tt>prod_sub</tt>
o <tt>quot_sub</tt>.

<item> En el <ref id="sec_p_11_3"> se muestra un ejemplo algo más
complejo en el que se evalua, dependiendo de la elección del usuario,
una función entre tres posibles para un intervalo de la variable
independiente. En este caso las funciones se declaran
como <tt>EXTERNAL</tt> y se utiliza una subrutina interna para la
definición del vector de la variable independiente, de acuerdo con la
dimensión que proporciona el usuario, y la
subrutina <tt>Eval_Func</tt> que acepta como uno de sus argumentos el
nombre de la función que se evalue mostrando los resultados en
pantalla.

<item> Es posible también comunicar a un subprograma el nombre de una función o una subrutina mediante el uso de módulos. En el  <ref id="sec_p_11_4"> se muestra un programa similar al  <ref id="sec_p_11_3"> utilizando módulos. El módulo <tt>Functions_11_4</tt> debe compilarse en un fichero separado al del programa principal. Si, por ejemplo el módulo se llama <file>ejemplo_11_4_mod.f90</file> y el programa principal <file>ejemplo_11_4.f90</file> el procedimiento sería el siguiente
<p>
<example>
$ gfortran -c ejemplo_11_4_mod.f90 
$ gfortran ejemplo_11_4.f90 ejemplo_11_4_mod.o
</example>
<p>
Como ocurría en el caso anterior, el o los argumentos que indican funciones o subrutinas no llevan el atributo <tt>INTENT</tt>.
</enumlist> 
</sect>
<sect id="sec_113">  Programas usados como ejemplo.
<sect1 id="sec_p_11_1">  Programa ejemplo_11_1.f90
<p>
<example>
PROGRAM func_option
  !
  ! Select between funs to compute the product of the quotient of two quantities
  !
  IMPLICIT NONE
  !
  !
  REAL :: X_1, X_2
  INTEGER :: I_fun
  INTEGER :: I_exit
  !
  REAL, EXTERNAL :: prod_fun, quot_fun
  !
  I_exit = 1
  !
  DO WHILE (I_exit /= 0)
     !
     PRINT*, "X_1, X_2?" 
     READ(UNIT = *, FMT = *) X_1, X_2
     !
     PRINT*, "function 1 = X_1 * X_2, 2 = X_1/X_2 ? (0 = exit)" 
     READ(UNIT = *, FMT = *) I_fun
     !
     SELECT CASE (I_fun)
        !
     CASE (0)
        I_exit = 1
     CASE (1) 
        CALL Eval_func(prod_fun, X_1, X_2)
     CASE (2) 
        CALL Eval_func(quot_fun, X_1, X_2)
     CASE DEFAULT
        PRINT*, "Valid options : 0, 1, 2"
        !
     END SELECT
     !
     PRINT*, "Continue? (0 = exit)" 
     READ(UNIT=*, FMT = *) I_exit
     !
     !
  ENDDO
  !
END PROGRAM func_option
!
SUBROUTINE Eval_Func(fun, X_1, X_2)
  !
  IMPLICIT NONE
  !
  REAL, INTENT(IN) :: X_1, X_2
  REAL, EXTERNAL :: fun
  !
  PRINT 10, fun(X_1, X_2)
  !
  10 FORMAT(1X, ES16.8)
  !
END SUBROUTINE Eval_Func
!
!
FUNCTION prod_fun(x1, x2)
  !
  IMPLICIT  NONE
  !
  REAL, INTENT(IN) :: x1, x2
  ! 
  REAL prod_fun
  !
  prod_fun = x1*x2
  !
END FUNCTION prod_fun
!
FUNCTION quot_fun(x1, x2)
  !
  IMPLICIT  NONE
  !
  REAL, INTENT(IN) :: x1, x2
  ! 
  REAL quot_fun
  !
  quot_fun = x1/x2
  !
END FUNCTION quot_fun
</example>
</sect1>
<sect1 id="sec_p_11_2">  Programa ejemplo_11_2.f90
<p>
<example>
PROGRAM sub_option
  !
  ! Select between subs to compute the product or the quotient of two quantities
  !
  IMPLICIT NONE
  !
  !
  REAL :: X_1, X_2
  INTEGER :: I_sub
  INTEGER :: I_exit
  !
  EXTERNAL :: prod_sub, quot_sub
  !
  I_exit = 1
  !
  DO WHILE (I_exit /= 0)
     !
     PRINT*, "X_1, X_2?" 
     READ(UNIT = *, FMT = *) X_1, X_2
     !
     PRINT*, "function 1 = X_1 * X_2, 2 = X_1/X_2 ? (0 = exit)" 
     READ(UNIT = *, FMT = *) I_sub
     !
     SELECT CASE (I_sub)
        !
     CASE (0)
        I_exit = 0
     CASE (1) 
        CALL Eval_Sub(prod_sub, X_1, X_2)
     CASE (2) 
        CALL Eval_Sub(quot_sub, X_1, X_2)
     CASE DEFAULT
        PRINT*, "Valid options : 0, 1, 2"
        !
     END SELECT
     !
     PRINT*, "Continue? (0 = exit)" 
     READ(UNIT=*, FMT = *) I_exit
     !
  ENDDO
  !
END PROGRAM sub_option
!
SUBROUTINE Eval_Sub(sub, X_1, X_2)
  !
  IMPLICIT NONE
  !
  EXTERNAL :: sub
  REAL, INTENT(IN) :: X_1, X_2
  !
  REAL :: res_sub
  !
  CALL sub(X_1, X_2, res_sub)
  PRINT 10, res_sub
  !
10 FORMAT(1X, ES16.8)
  !
END SUBROUTINE Eval_Sub
!
!
SUBROUTINE prod_sub(x1, x2, y)
  !
  IMPLICIT  NONE
  !
  REAL, INTENT(IN) :: x1, x2
  REAL, INTENT(OUT) :: y
  ! 
  y = x1*x2
  !
END SUBROUTINE prod_sub
!
!
SUBROUTINE quot_sub(x1, x2, y)
  !
  IMPLICIT  NONE
  !
  REAL, INTENT(IN) :: x1, x2
  REAL, INTENT(OUT) :: y
  ! 
  y = x1/x2
  !
END SUBROUTINE quot_sub
</example>
</sect1>
<sect1 id="sec_p_11_3">  Programa ejemplo_11_3.f90
<p>
<example>
PROGRAM call_func
  !
  ! Select which curve is computed and saved in a given interval e.g. (-2 Pi, 2 Pi)
  ! 
  ! 1 ---> 10 x^2 cos(2x) exp(-x)
  ! 2 ---> 10 (-x^2 + x^4)exp(-x^2)
  ! 3 ---> 10 (-x^2 + cos(x)*x^4)exp(-x^2)
  !
  IMPLICIT NONE
  !
  !
  REAL, DIMENSION(:), ALLOCATABLE :: X_grid
  !
  REAL, PARAMETER :: pi = ACOS(-1.0)
  !
  REAL :: X_min, X_max, Delta_X
  INTEGER :: X_dim, I_fun
  INTEGER :: I_exit, Ierr
  !
  REAL, EXTERNAL :: fun1, fun2, fun3
  !
  X_min = -2*pi
  X_max = 2*pi
  !
  I_exit = 0
  !
  DO WHILE (I_exit /= 1)
     !
     PRINT*, "number of points? (0 = exit)" 
     READ(UNIT=*, FMT = *) X_dim
     !
     IF (X_dim == 0) THEN
        !
        I_exit = 1
        !
     ELSE
        ALLOCATE(X_grid(1:X_dim), STAT = Ierr)
        IF (Ierr /= 0) THEN
           STOP 'X_grid allocation failed'
        ENDIF
        !
        CALL make_Grid(X_min, X_max, X_dim)
        !
        PRINT*, "function 1, 2, or 3? (0 = exit)" 
        READ(UNIT = *, FMT = *) I_fun
        !
        SELECT CASE (I_fun)
           !
        CASE (0)
           I_exit = 1
        CASE (1) 
           CALL Eval_func(fun1, X_dim, X_grid)
        CASE (2) 
           CALL Eval_func(fun2, X_dim, X_grid)
        CASE (3) 
           CALL Eval_func(fun3, X_dim, X_grid)
        CASE DEFAULT
           PRINT*, "Valid options : 0, 1, 2, 3"
           !
        END SELECT
        !
        DEALLOCATE(X_grid, STAT = Ierr)
        IF (Ierr /= 0) THEN
           STOP 'X_grid deallocation failed'
        ENDIF
        !
     ENDIF
     !
  ENDDO
  ! 
CONTAINS
  !
  SUBROUTINE make_Grid(X_min, X_max, X_dim)
    !
    REAL, INTENT(IN) :: X_min, X_max
    INTEGER, INTENT(IN) :: X_dim
    !
    INTEGER :: Index
    REAL :: Delta_X
    !
    !
    Delta_X = (X_max - X_min)/REAL(X_dim - 1)
    !
    X_grid = (/ (Index, Index = 0 , X_dim - 1 ) /)
    X_grid = X_min + Delta_X*X_grid
    !
  END SUBROUTINE make_Grid
  !
END PROGRAM call_func
!
SUBROUTINE Eval_Func(fun, dim, X_grid)
  !
  IMPLICIT NONE
  !
  INTEGER, INTENT(IN) :: dim
  REAL, DIMENSION(dim), INTENT(IN) :: X_grid
  REAL, EXTERNAL :: fun
  !
  INTEGER :: Index
  !
  DO Index = 1, dim
     PRINT 10, X_grid(Index), fun(X_grid(Index))
  ENDDO
  !
  10 FORMAT(1X, ES16.8,2X, ES16.8)
  !
END SUBROUTINE Eval_Func
!
!
FUNCTION fun1(x)
  !
  IMPLICIT  NONE
  !
  REAL, INTENT(IN) :: x
  ! 
  REAL fun1
  !
  fun1 = 10.0*x**2*cos(2.0*x)*exp(-x)
  !
END FUNCTION fun1
!
FUNCTION fun2(x)
  !
  IMPLICIT  NONE
  !
  REAL, INTENT(IN) :: x
  ! 
  REAL fun2
  !
  fun2 = 10.0*(-x**2 + x**4)*exp(-x**2)
  !
END FUNCTION fun2
!
FUNCTION fun3(x)
  !
  IMPLICIT  NONE
  !
  REAL, INTENT(IN) :: x
  ! 
  REAL fun3
  !
  fun3 = 10.0*(-x**2 + cos(x)*x**4)*exp(-x**2)
  !
END FUNCTION fun3
</example>
</sect1>
<sect1 id="sec_p_11_4">  Programa ejemplo_11_4.f90
<p>
<example>
PROGRAM call_func
  !
  ! Select which curve is computed and saved in a given interval e.g. (-2 Pi, 2 Pi)
  ! 
  ! 1 ---> 10 x^2 cos(2x) exp(-x)
  ! 2 ---> 10 (-x^2 + x^4)exp(-x^2)
  ! 3 ---> 10 (-x^2 + cos(x)*x^4)exp(-x^2)
  !
  USE Functions_11_4
  !
  IMPLICIT NONE
  !
  !
  REAL, DIMENSION(:), ALLOCATABLE :: X_grid
  !
  REAL, PARAMETER :: pi = ACOS(-1.0)
  !
  REAL :: X_min, X_max, Delta_X
  INTEGER :: X_dim, I_fun
  INTEGER :: I_exit, Ierr
  !
  X_min = -2*pi
  X_max = 2*pi
  !
  I_exit = 0
  !
  DO WHILE (I_exit /= 1)
     !
     PRINT*, "number of points? (0 = exit)" 
     READ(UNIT=*, FMT = *) X_dim
     !
     IF (X_dim == 0) THEN
        !
        I_exit = 1
        !
     ELSE
        ALLOCATE(X_grid(1:X_dim), STAT = Ierr)
        IF (Ierr /= 0) THEN
           STOP 'X_grid allocation failed'
        ENDIF
        !
        CALL make_Grid(X_min, X_max, X_dim)
        !
        PRINT*, "function 1, 2, or 3? (0 = exit)" 
        READ(UNIT = *, FMT = *) I_fun
        !
        SELECT CASE (I_fun)
           !
        CASE (0)
           I_exit = 1
        CASE (1) 
           CALL Eval_func(fun1, X_dim, X_grid)
        CASE (2) 
           CALL Eval_func(fun2, X_dim, X_grid)
        CASE (3) 
           CALL Eval_func(fun3, X_dim, X_grid)
        CASE DEFAULT
           PRINT*, "Valid options : 0, 1, 2, 3"
           !
        END SELECT
        !
        DEALLOCATE(X_grid, STAT = Ierr)
        IF (Ierr /= 0) THEN
           STOP 'X_grid deallocation failed'
        ENDIF
        !
     ENDIF
     !
  ENDDO
  ! 
CONTAINS
  !
  SUBROUTINE make_Grid(X_min, X_max, X_dim)
    !
    REAL, INTENT(IN) :: X_min, X_max
    INTEGER, INTENT(IN) :: X_dim
    !
    INTEGER :: Index
    REAL :: Delta_X
    !
    !
    Delta_X = (X_max - X_min)/REAL(X_dim - 1)
    !
    X_grid = (/ (Index, Index = 0 , X_dim - 1 ) /)
    X_grid = X_min + Delta_X*X_grid
    !
  END SUBROUTINE make_Grid
  !
END PROGRAM call_func
!
SUBROUTINE Eval_Func(fun, dim, X_grid)
  !
  USE Functions_11_4
  !
  IMPLICIT NONE
  !
  REAL :: fun
  INTEGER, INTENT(IN) :: dim
  REAL, DIMENSION(dim), INTENT(IN) :: X_grid
  !
  INTEGER :: Index
  !
  DO Index = 1, dim
     PRINT 10, X_grid(Index), fun(X_grid(Index))
  ENDDO
  !
  10 FORMAT(1X, ES16.8,2X, ES16.8)
  !
END SUBROUTINE Eval_Func
!
MODULE Functions_11_4
  IMPLICIT NONE
  !
CONTAINS
  !
  !
  FUNCTION fun1(x)
    !
    IMPLICIT  NONE
    !
    REAL, INTENT(IN) :: x
    ! 
    REAL fun1
    !
    fun1 = 10.0*x**2*cos(2.0*x)*exp(-x)
    !
  END FUNCTION fun1
  !
  FUNCTION fun2(x)
    !
    IMPLICIT  NONE
    !
    REAL, INTENT(IN) :: x
    ! 
    REAL fun2
    !
    fun2 = 10.0*(-x**2 + x**4)*exp(-x**2)
    !
  END FUNCTION fun2
  !
  FUNCTION fun3(x)
    !
    IMPLICIT  NONE
    !
    REAL, INTENT(IN) :: x
    ! 
    REAL fun3
    !
    fun3 = 10.0*(-x**2 + cos(x)*x**4)*exp(-x**2)
    !
  END FUNCTION fun3
END MODULE Functions_11_4

</example>
</sect1>
</sect>
</chapt>
<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->
<!--                         Clase BLAS - LAPACK             -->
<!-- +++++++++++++++++++++++++++++++++++++++++++++++++++++++ -->

<chapt id="clase_blaslap"><heading>Instalación y uso de las
    bibliotecas <prgn>BLAS</prgn> y <prgn>LAPACK</prgn></heading> 
<sect id="sec_bl1"> Objetivos

<p>
Los objetivos de esta clase son los siguientes:

<enumlist>  
<item> familiarizar el alumno con la compilación de programas y la
  instalación de librerias o biliotecas usando el compilador <prgn>gfortran</prgn>.
<item> Instalar las bibliotecas de interés
  científico  <prgn>BLAS</prgn> y <prgn>LAPACK</prgn>.
<item> Aprender a hacer uso de dichas bibliotecas.
</enumlist>  
<p>
Existe una gran cantidad de código <prgn>Fortran</prgn> accesible de
forma abierta, ya sea como código fuente o en forma de biblioteca. En
la presente clase el alumno se familiariza con la obtención,
compilación, instalación y uso de dos bibliotecas de subrutinas de
interés algebraico, <prgn>BLAS</prgn> y <prgn>LAPACK</prgn>.
</sect>

<sect id="sec_bl2"> Puntos destacables.

<p>
Indicaremos de forma escalonada los diferentes pasos que hay que
seguir para la instalación de estas bibliotecas.
<p>
El código fuente de las bibliotecas <prgn>BLAS</prgn>
y <prgn>LAPACK</prgn> puede descargarse de diferentes lugares, o
instalarse a partir de paquetes de la distribución <prgn>Debian</prgn>
o <prgn>Ubuntu</prgn> que se esté utilizando. En vez de ello las
instalaremos compilándolas en nuestro ordenador.
<p>
<list>  
<item> Descarga de código fuente de la biblioteca <prgn>BLAS</prgn>.
<p>
Se puede descargar de la web de <tt>NETLIB</tt><footnote>El
    repositorio de <tt>Netlib</tt> contiene software gratuito,
    documentación y bases de datos de interés para la comunidad
    científica en general y para aquellos interesados en la
    computación científica en particular. El repositorio es mantenido
    por los Laboratorios AT&amp;T-Bell, la Universidad de Tennessee y
    el laboratorio nacional de Oak Ridge, con la ayuda de un gran
    número de colaboradores en todo el mundo. La web
    de  <tt>Netlib</tt> es <url id="http://www.netlib.org"
name="http://www.netlib.org">.</footnote>,
usando este enlace <url id="http://www.netlib.org/blas/blas.tgz"
name="BLAS tgz (Netlib)">.
<item> Una vez descargado el código fuente, se descomprime, se compila
  y se crea finalmente la libreria.
<p>
<example>
tar xzf blas.tgz
cd BLAS
gfortran -O2 -c *.f
ar cr libblas.a *.o
</example>
<p>
Con lo que se debe haber creado la librería
estática <tt>libblas.a</tt>.
<item> A continuación se sitúa dicha libreria en un lugar apropiado,
  por ejemplo con
<p>
<example>
sudo cp libblas.a /usr/local/lib
</example>
<p> y se comprueba que tiene los permisos adecuados.
<item> Descarga del código fuente de la biblioteca <prgn>LAPACK</prgn>.
<p>
Se puede descargar también de la web de <tt>NETLIB</tt>
usando este enlace <url id="http://www.netlib.org/lapack/lapack.tgz"
name="LAPACK tgz (Netlib)">. Tras su descarga se desempaquetan los
    ficheros.
<p>
<example>
tar xzf lapack.tgz
cd lapack-3.2.1
</example>
<item> Esta biblioteca si tiene una serie de
  ficheros <tt>makefile</tt> para su compilación. Hemos de preparar un
  fichero <tt>make.inc</tt> adecuado, como el que hemos incluido
  en <ref id="sec_p_bl_1"> y que está disponible
  en <prgn>Moodle</prgn> en un fichero llamado <url id="http://moodle.uhu.es/contenidos/file.php/245/src_fortran_clase/make.inc.lapack.ubuntu"
name="make.inc.lapack.ubuntu">.

<p>
Usando este fichero compilamos la librería haciendo
<p>
<example>
make
</example>
<item> Por último, instalamos la librería copiando los ficheros
  creados al lugar que creamos más adecuado para su ubicación.
<p>
<example>
sudo cp lapack_LINUX.a /usr/local/lib
sudo cp tmglib_LINUX.a /usr/local/lib
</example>
<item> Para terminar descargamos el código fuente de la biblioteca <prgn>LAPACK95</prgn>.
<p>
Se puede descargar también de la web de <tt>NETLIB</tt>
usando el enlace <url id="http://www.netlib.org/lapack95/lapack95.tgz"
name="LAPACK95 tgz (Netlib)">. Tras su descarga se desempaquetan los
    ficheros.
<p>
<example>
tar xzf lapack95.tgz
cd LAPACK95
</example>
<item> Esta biblioteca también tiene una serie de
  ficheros <tt>makefile</tt> para su compilación. Hemos de preparar de
  nuevo un fichero <tt>make.inc</tt> adecuado, como el que hemos
  incluido en <ref id="sec_p_bl_2"> y que está disponible
  en <prgn>Moodle</prgn> en un fichero
  llamado <url id="http://moodle.uhu.es/contenidos/file.php/245/src_fortran_clase/make.inc.lapack95.ubuntu"
  name="make.inc.lapack95.ubuntu">.

<p>
Usando este fichero compilamos la librería haciendo
<p>
<example>
cd SRC
make single_double_complex_dcomplex
</example>
<p>
La opción escogida es la más general, pues general la librería para
precisión simple, doble, compleja simple y compleja doble.
<item> Por último, instalamos la librería copiando los ficheros
  creados al lugar que creamos más adecuado para su ubicación.
<p>
<example>
sudo cp lapack95.a /usr/local/lib
sudo cp -r lapack95_modules /usr/local/lib
</example>
<item> En los directorios de ejemplos (<tt>LAPACK95/EXAMPLES1</tt>
  y <tt>LAPACK95/EXAMPLES2</tt>) encontramos un gran número de
  ejemplos que podemos correr y comprobar las salidas obtenidas con
  las que se encuentran en  <url id="http://www.netlib.org/lapack95/lug95/node1.html"
  name="Lapack95 User's guide">. Las instrucciones para compilar y
  correr los ejemplos proporcionados pueden verse en el
  fichero <tt>README</tt> del directorio donde se encuentra el código
  fuente de los ejemplos.
<item> En el ejemplo <ref id="sec_p_bl_3"> se encuentra el código de
un programa donde se recurre a la subrutina <tt>la_spsv</tt> para
hallar la solución de un sistema lineal de ecuaciones, <em>Ax =
B</em>, donde la matriz del sistema, <em>A</em>, es simétrica y se
almacena de forma compacta y <em>x</em>, <em>B</em> son vectores. Es
importante que comprenda como funciona este programa, así como que se
sepa extraer de la documentación de <prgn>LAPACK95</prgn> el
significado de los argumentos de entrada y salida de la subrutina.
<item> Para correr este programa es necesario descargar el
código <tt>ejemplo_la_spsv.f90</tt> y los ficheros de
datos <tt>spsv.ma</tt> y <tt>spsv.mb</tt> de la web del curso. Para compilar el programa se ejecuta la orden
<p>
<example>
gfortran -o ejemplo_la_spsv -I/usr/local/lib/lapack95_modules ejemplo_la_spsv.f90  /usr/local/lib/lapack95.a /usr/local/lib/tmglib_LINUX.a /usr/local/lib/lapack_LINUX.a /usr/local/lib/libblas.a
</example>
<p>
En esta orden de compilación se incluyen todas las librerías y módulos necesarios para que pueda crearse el ejecutable, haciendo uso de las librerías <prgn>BLAS</prgn>, <prgn>LAPACK</prgn> y <prgn>LAPACK95</prgn> que hemos instalado.
<item> Para proyectos más complejos y evitar tener que escribir comandos de compilación tan complejos como el anterior es posible usar un fichero <tt>makefile</tt> como el que se proporciona en el ejemplo <ref id="sec_p_bl_4">. Para usar este fichero en la compilación del ejemplo  <ref id="sec_p_bl_3"> es preciso copiar el fichero proporcionado o descargar el fichero <tt>makefile_lapack95</tt> y ejecutar la orden 
<p>
<example>
 make -f makefile_lapack95 ejemplo_la_spsv
</example>
</list>  
</sect>
<sect id="sec_bl3">  Programas usados como ejemplo.

<sect1 id="sec_p_bl_1">  Ejemplo de fichero <tt>make.inc</tt> para <prgn>LAPACK</prgn>
<p>
<example>
####################################################################
#  LAPACK make include file.                                       #
#  LAPACK, Version 3.2.1                                           #
#  MAY 2009                                                        #
#  Modified by Currix                                              #
####################################################################
#
SHELL = /bin/sh
#
#  The machine (platform) identifier to append to the library names
#
PLAT = _LINUX
#  
#  Modify the FORTRAN and OPTS definitions to refer to the
#  compiler and desired compiler options for your machine.  NOOPT
#  refers to the compiler options desired when NO OPTIMIZATION is
#  selected.  Define LOADER and LOADOPTS to refer to the loader and 
#  desired load options for your machine.
#
FORTRAN  = gfortran 
OPTS     = -O2
DRVOPTS  = $(OPTS)
NOOPT    = -O0
LOADER   = gfortran
LOADOPTS =
#
# Timer for the SECOND and DSECND routines
#
# Default : SECOND and DSECND will use a call to the EXTERNAL FUNCTION ETIME
#TIMER    = EXT_ETIME
# For RS6K : SECOND and DSECND will use a call to the EXTERNAL FUNCTION ETIME_
# TIMER    = EXT_ETIME_
# For gfortran compiler: SECOND and DSECND will use a call to the INTERNAL FUNCTION ETIME
TIMER    = INT_ETIME
# If your Fortran compiler does not provide etime (like Nag Fortran Compiler, etc...)
# SECOND and DSECND will use a call to the INTERNAL FUNCTION CPU_TIME
# TIMER    = INT_CPU_TIME
# If neither of this works...you can use the NONE value... In that case, SECOND and DSECND will always return 0
# TIMER     = NONE
#
#  The archiver and the flag(s) to use when building archive (library)
#  If you system has no ranlib, set RANLIB = echo.
#
ARCH     = ar
ARCHFLAGS= cr
RANLIB   = ranlib
#
#  Location of the extended-precision BLAS (XBLAS) Fortran library
#  used for building and testing extended-precision routines.  The
#  relevant routines will be compiled and XBLAS will be linked only if
#  USEXBLAS is defined.
#
# USEXBLAS    = Yes
XBLASLIB     =
# XBLASLIB    = -lxblas
#
#  The location of the libraries to which you will link.  (The 
#  machine-specific, optimized BLAS library should be used whenever
#  possible.)
#
#BLASLIB      = ../../blas$(PLAT).a
BLASLIB      = /usr/local/lib/libblas.a
LAPACKLIB    = lapack$(PLAT).a
TMGLIB       = tmglib$(PLAT).a
EIGSRCLIB    = eigsrc$(PLAT).a
LINSRCLIB    = linsrc$(PLAT).a
</example>
</sect1>
<sect1 id="sec_p_bl_2">  Ejemplo de fichero <tt>make.inc</tt> para <prgn>LAPACK95</prgn>
<p>
<example>
#
#  -- LAPACK95 interface driver routine (version 2.0) --
#     UNI-C, Denmark; Univ. of Tennessee, USA; NAG Ltd., UK
#     August 5, 2000
#
FC	 = gfortran
FC1      = gfortran
# -dcfuns  Enable recognition of non-standard double
#          precision  complex intrinsic functions
# -dusty   Allows the compilation and execution of "legacy"
#          software by downgrading the category  of  common
#          errors  found  in  such software from "Error" to
# -ieee=full enables all IEEE arithmetic facilities
#          including non-stop arithmetic.

OPTS0    = -u -V -dcfuns -dusty -ieee=full
MODLIB   = -I./../lapack95_modules
OPTS1    = -c $(OPTS0)
OPTS3    = $(OPTS1) $(MODLIB)
OPTL     = -o 
OPTLIB   =

LAPACK_PATH = /usr/local/lib/

LAPACK95 = ../lapack95.a
LAPACK77 = $(LAPACK_PATH)/lapack_LINUX.a
TMG77    = $(LAPACK_PATH)/tmglib_LINUX.a
BLAS     = $(LAPACK_PATH)/libblas.a

LIBS     = $(LAPACK95) $(TMG77) $(LAPACK77) $(BLAS)
SUF      = f90

XX = 'rm' -f $@; \
        'rm' -f $@.res; \
	$(FC) $(OPTS0) -o $@ $(MODLIB) $@.$(SUF) $(OPTLIB) $(LIBS); \
        $@ < $@.dat > $@.res; \
        'rm' -f $@

YY = $(FC) $(OPTS0) -o $@ $(MODLIB) $@.$(SUF) $(OPTLIB) $(LIBS)

.SUFFIXES: .f90 .f .o

.$(SUF).o: 
	$(FC) $(OPTS3) $<

.f.o:
	$(FC1) $(OPTS3) $<
</example>
</sect1>
<sect1 id="sec_p_bl_3">  Ejemplo de programa que invoca <prgn>LAPACK95</prgn>
<p>
<example>
PROGRAM LA_SSPSV_EXAMPLE
  
  !  -- LAPACK95 EXAMPLE DRIVER ROUTINE (VERSION 1.0) --
  !     UNI-C, DENMARK
  !     DECEMBER, 1999
  !
  !  .. "Use Statements"
  USE LA_PRECISION, ONLY: WP => SP
  USE F95_LAPACK, ONLY: LA_SPSV
  !  .. "Implicit Statement" ..
  IMPLICIT NONE
  !  .. "Local Scalars" ..
  INTEGER :: I, N, NN, NRHS
  !  .. "Local Arrays" ..
  INTEGER, ALLOCATABLE :: IPIV(:)
  REAL(WP), ALLOCATABLE :: B(:,:), AP(:)
  !  .. "Executable Statements" ..
  WRITE (*,*) 'SSPSV Example Program Results.'
  N = 5; NRHS = 1
  WRITE(*,'(5H N = , I4, 9H; NRHS = , I4)') N, NRHS
  NN = N*(N+1)/2
  ALLOCATE ( AP(NN), B(N,NRHS), IPIV(N) )
  !
  OPEN(UNIT=21,FILE='spsv.ma',STATUS='UNKNOWN')
  DO I=1,NN 
     READ(21,'(F3.0)') AP(I)
  ENDDO
  CLOSE(21)
  !
  WRITE(*,*)'Matrix AP :'
  DO I=1,NN; WRITE(*,"(15(I3,1X,1X),I3,1X))") INT(AP(I));
  ENDDO
  !
  OPEN(UNIT=21,FILE='spsv.mb',STATUS='UNKNOWN')
  DO I=1,N 
     READ(21,'(F3.0)') B(I,1)
  ENDDO
  CLOSE(21)
  !
  WRITE(*,*)'Matrix B :'
  DO I=1,N; WRITE(*,"(10(I3,1X,1X),I3,1X)')") INT(B(I,1));
  ENDDO
  !
  WRITE(*,*)" CALL LA_SPSV( AP, B, 'L', IPIV )"
  !
  CALL LA_SPSV( AP, B, 'L', IPIV )
  !
  WRITE(*,*)'AP on exit: '
  DO I=1,NN; WRITE(*,"(15(E13.5))") AP(I); 
  ENDDO
  !
  WRITE(*,*)'Matrix B on exit :'
  DO I=1,N; WRITE(*,"(F9.5)") B(I,1);
  ENDDO
  WRITE(*,*)'IPIV = ', IPIV
  !
END PROGRAM LA_SSPSV_EXAMPLE


</example>
</sect1>
<sect1 id="sec_p_bl_4">  Ejemplo de <tt>makefile</tt> para compilar programas que invocan <prgn>LAPACK95</prgn>
<p>
<example>
#
#  -- LAPACK95 makefile (version 1.0) --
#
FC	 = gfortran
#
MODLIB   = -I/usr/local/lib/lapack95_modules
OPTS1    = -c
OPTS3    = $(OPTS1) $(MODLIB)
OPTL     = -o 
OPTLIB   =

LAPACK_PATH = /usr/local/lib
LAPACK95_PATH = /usr/local/lib

LAPACK95 = $(LAPACK95_PATH)/lapack95.a
LAPACK77 = $(LAPACK_PATH)/lapack_LINUX.a
TMG77    = $(LAPACK_PATH)/tmglib_LINUX.a
BLAS     = $(LAPACK_PATH)/libblas.a

LIBS     = $(LAPACK95) $(TMG77) $(LAPACK77) $(BLAS)
SUF      = f90

YY = $(FC) -o $@ $(MODLIB) $@.$(SUF) $(OPTLIB) $(LIBS)

.SUFFIXES: .f90 .f .o

.$(SUF).o: 
	$(FC) $(OPTS3) $<

ejemplo_la_spsv: 
	$(YY)

clean:
	'rm' -f *.o *.mod core 
</example>
</sect1>
</sect>

</chapt>

<chapt id="cap_ref"><heading>Referencias</heading> 

<p>
<enumlist>
<item> Stephen J. Chapman; <em>Fortran 95/2003 for Scientists and Engineers</em>, 3a Ed. Mc Graw Hill 2008.
<item> Michael Metcalf, John Reid, and Malcolm Cohen; <em>Modern Fortran Explained</em>, Oxford University Press 2011.
<item> Jeanne C. Adams <em>et al.</em>; <em>Fortran 95 Handbook</em>,
  MIT Press 1997.
<item> Ian D. Chivers and Jane Sleightholme; <em>Introduction to
Programming with Fortran</em>, Springer 2006.
<item><url id="http://www.liv.ac.uk/HPC/HTMLFrontPageF90.html"
name="An Interactive Fortran 90 Programming Course">
<item><url id="http://gcc.gnu.org/onlinedocs/gfortran"
name="gfortran: The GNU Fortran compiler ">
<item><url id="http://gcc.gnu.org/wiki/GFortran"
name="Gfortran - GCC Wiki">
<item><url id="http://sunsite.informatik.rwth-aachen.de/fortran/"
name="USER NOTES ON FORTRAN PROGRAMMING (UNFP) ">
<item><url id="http://wwwasdoc.web.cern.ch/wwwasdoc/WWW/f90/f90.html"
name="Fortran 90 Tutoria by Michael Metcalf"
</enumlist>
</book>
