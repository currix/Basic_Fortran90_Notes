<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">

<html>

<head>

<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">

<title>Fortran 90 Lessons for Computational Chemistry - Subprograms (II): subroutines</title>

<link href="index.html" rel="start">
<link href="ch-clase_8.html" rel="prev">
<link href="ch-clase_10.html" rel="next">
<link href="index.html#contents" rel="contents">
<link href="index.html#copyright" rel="copyright">
<link href="ch-clase_1.html" rel="chapter" title="1 Introduction">
<link href="ch-clase_2.html" rel="chapter" title="2 Basic Operations">
<link href="ch-clase_3.html" rel="chapter" title="3 Introduction to Fortran Arrays">
<link href="ch-clase_4.html" rel="chapter" title="4 More on Arrays">
<link href="ch-clase_7.html" rel="chapter" title="5 Control Structures">
<link href="ch-clase_5.html" rel="chapter" title="6 INPUT/OUTPUT (I)">
<link href="ch-clase_6.html" rel="chapter" title="7 Input/Output (II)">
<link href="ch-clase_8.html" rel="chapter" title="8 Subprograms (I): FUNCTIONS">
<link href="ch-clase_9.html" rel="chapter" title="9 Subprograms (II): subroutines">
<link href="ch-clase_10.html" rel="chapter" title="10 Subprograms (III): modules">
<link href="ch-clase_11.html" rel="chapter" title="11 Subprogramas (IV)">
<link href="ch-clase_blaslap.html" rel="chapter" title="12 Instalación y uso de las bibliotecas BLAS y LAPACK">
<link href="ch-cap_ref.html" rel="chapter" title="13 Referencias">
<link href="ch-clase_1.html#s-sec_11" rel="section" title="1.1 Objectives">
<link href="ch-clase_1.html#s-sec_12" rel="section" title="1.2 Main items.">
<link href="ch-clase_1.html#s-sec_13" rel="section" title="1.3 Example Codes.">
<link href="ch-clase_2.html#s-sec_21" rel="section" title="2.1 Objectives">
<link href="ch-clase_2.html#s-sec_22" rel="section" title="2.2 Main items.">
<link href="ch-clase_2.html#s-sec_23" rel="section" title="2.3 Example Codes.">
<link href="ch-clase_3.html#s-sec_31" rel="section" title="3.1 Objectivos">
<link href="ch-clase_3.html#s-sec_32" rel="section" title="3.2 Main items.">
<link href="ch-clase_3.html#s-sec_33" rel="section" title="3.3 Example Codes.">
<link href="ch-clase_4.html#s-sec_41" rel="section" title="4.1 Objectives">
<link href="ch-clase_4.html#s-sec_42" rel="section" title="4.2 Main items.">
<link href="ch-clase_4.html#s-sec_43" rel="section" title="4.3 Example Codes.">
<link href="ch-clase_7.html#s-sec_71" rel="section" title="5.1 Objectives">
<link href="ch-clase_7.html#s-sec_72" rel="section" title="5.2 Main items.">
<link href="ch-clase_7.html#s-sec_73" rel="section" title="5.3 Example codes.">
<link href="ch-clase_5.html#s-sec_51" rel="section" title="6.1 Objectivos">
<link href="ch-clase_5.html#s-sec_52" rel="section" title="6.2 Main Items.">
<link href="ch-clase_5.html#s-sec_53" rel="section" title="6.3 Example Codes">
<link href="ch-clase_6.html#s-sec_61" rel="section" title="7.1 Objectives">
<link href="ch-clase_6.html#s-sec_62" rel="section" title="7.2 Main items.">
<link href="ch-clase_6.html#s-sec_63" rel="section" title="7.3 Example Codes">
<link href="ch-clase_8.html#s-sec_81" rel="section" title="8.1 Objectives">
<link href="ch-clase_8.html#s-sec_82" rel="section" title="8.2 Main items.">
<link href="ch-clase_8.html#s-sec_83" rel="section" title="8.3 Example Codes">
<link href="ch-clase_9.html#s-sec_91" rel="section" title="9.1 Objectives">
<link href="ch-clase_9.html#s-sec_92" rel="section" title="9.2 Main items.">
<link href="ch-clase_9.html#s-sec_93" rel="section" title="9.3 Example Codes">
<link href="ch-clase_10.html#s-sec_101" rel="section" title="10.1 Objectives">
<link href="ch-clase_10.html#s-sec_102" rel="section" title="10.2 Puntos destacables.">
<link href="ch-clase_10.html#s-sec_103" rel="section" title="10.3 Programas usados como ejemplo.">
<link href="ch-clase_11.html#s-sec_111" rel="section" title="11.1 Objetivos">
<link href="ch-clase_11.html#s-sec_112" rel="section" title="11.2 Puntos destacables.">
<link href="ch-clase_11.html#s-sec_113" rel="section" title="11.3 Programas usados como ejemplo.">
<link href="ch-clase_blaslap.html#s-sec_bl1" rel="section" title="12.1 Objetivos">
<link href="ch-clase_blaslap.html#s-sec_bl2" rel="section" title="12.2 Puntos destacables.">
<link href="ch-clase_blaslap.html#s-sec_bl3" rel="section" title="12.3 Programas usados como ejemplo.">
<link href="ch-clase_1.html#s-sec_p_1_1" rel="subsection" title="1.3.1 excode_1_1.f90">
<link href="ch-clase_1.html#s-sec_p_1_2" rel="subsection" title="1.3.2 excode_1_2.f90">
<link href="ch-clase_2.html#s-sec_p_2_1" rel="subsection" title="2.3.1 excode_2_1.f90">
<link href="ch-clase_2.html#s-sec_p_2_2" rel="subsection" title="2.3.2 excode_2_2.f90">
<link href="ch-clase_2.html#s-sec_p_2_3" rel="subsection" title="2.3.3 excode_2_3.f90">
<link href="ch-clase_2.html#s-sec_p_2_4" rel="subsection" title="2.3.4 excode_2_4.f90">
<link href="ch-clase_2.html#s-sec_p_2_5" rel="subsection" title="2.3.5 excode_2_5.f90">
<link href="ch-clase_2.html#s-sec_p_2_6" rel="subsection" title="2.3.6 excode_2_6.f90">
<link href="ch-clase_3.html#s-sec_p_3_1" rel="subsection" title="3.3.1 excode_3_1.f90">
<link href="ch-clase_3.html#s-sec_p_3_2" rel="subsection" title="3.3.2 excode_3_2.f90">
<link href="ch-clase_3.html#s-sec_p_3_3" rel="subsection" title="3.3.3 excode_3_3.f90">
<link href="ch-clase_3.html#s-sec_p_3_4" rel="subsection" title="3.3.4 excode_3_4.f90">
<link href="ch-clase_4.html#s-sec_p_4_1" rel="subsection" title="4.3.1 excode_4_1.f90">
<link href="ch-clase_4.html#s-sec_p_4_2" rel="subsection" title="4.3.2 excode_4_2.f90">
<link href="ch-clase_4.html#s-sec_p_4_3" rel="subsection" title="4.3.3 excode_4_3.f90">
<link href="ch-clase_4.html#s-sec_p_4_4" rel="subsection" title="4.3.4 excode_4_4.f90">
<link href="ch-clase_4.html#s-sec_p_4_5" rel="subsection" title="4.3.5 excode_4_5.f90">
<link href="ch-clase_4.html#s-sec_p_4_6" rel="subsection" title="4.3.6 excode_4_6.f90">
<link href="ch-clase_7.html#s-sec_p_7_1" rel="subsection" title="5.3.1 excode_5_1.f90">
<link href="ch-clase_7.html#s-sec_p_7_2" rel="subsection" title="5.3.2 excode_5_2.f90">
<link href="ch-clase_7.html#s-sec_p_7_3" rel="subsection" title="5.3.3 excode_5_3.f90">
<link href="ch-clase_7.html#s-sec_p_7_4" rel="subsection" title="5.3.4 Programa ejemplo_5_4.f90">
<link href="ch-clase_5.html#s-sec_p_5_1" rel="subsection" title="6.3.1 excode_6_1.f90">
<link href="ch-clase_5.html#s-sec_p_5_2" rel="subsection" title="6.3.2 excode_6_2.f90">
<link href="ch-clase_5.html#s-sec_p_5_3" rel="subsection" title="6.3.3 excode_6_3.f90">
<link href="ch-clase_5.html#s-sec_p_5_4" rel="subsection" title="6.3.4 excode_6_4.f90">
<link href="ch-clase_5.html#s-sec_p_5_5" rel="subsection" title="6.3.5 excode_6_5.f90">
<link href="ch-clase_5.html#s-sec_p_5_6" rel="subsection" title="6.3.6 excode_6_6.f90">
<link href="ch-clase_5.html#s-sec_p_5_7" rel="subsection" title="6.3.7 excode_6_7.f90">
<link href="ch-clase_6.html#s-sec_p_6_1" rel="subsection" title="7.3.1 Programa ejemplo_7_1.f90">
<link href="ch-clase_6.html#s-sec_p_6_2" rel="subsection" title="7.3.2 excode_7_2.f90">
<link href="ch-clase_6.html#s-sec_p_6_22" rel="subsection" title="7.3.3 Script ej_here_file">
<link href="ch-clase_6.html#s-sec_p_6_3" rel="subsection" title="7.3.4 excode_7_3.f90">
<link href="ch-clase_6.html#s-sec_p_6_32" rel="subsection" title="7.3.5 namelist input file">
<link href="ch-clase_6.html#s-sec_p_6_4" rel="subsection" title="7.3.6 excode_7_4.f90">
<link href="ch-clase_8.html#s-sec_p_8_1" rel="subsection" title="8.3.1 excode_8_1.f90">
<link href="ch-clase_8.html#s-sec_p_8_2" rel="subsection" title="8.3.2 excode_8_2.f90">
<link href="ch-clase_8.html#s-sec_p_8_3" rel="subsection" title="8.3.3 Programa ejemplo_8_3.f90">
<link href="ch-clase_8.html#s-sec_p_8_4" rel="subsection" title="8.3.4 Programa ejemplo_8_4.f90">
<link href="ch-clase_8.html#s-sec_p_8_5" rel="subsection" title="8.3.5 excode_8_5.f90">
<link href="ch-clase_8.html#s-sec_p_8_6" rel="subsection" title="8.3.6 excode_8_6.f90">
<link href="ch-clase_8.html#s-sec_p_8_7" rel="subsection" title="8.3.7 excode_8_7.f90">
<link href="ch-clase_9.html#s-sec_p_9_1" rel="subsection" title="9.3.1 excode_9_1.f90">
<link href="ch-clase_9.html#s-sec_p_9_2" rel="subsection" title="9.3.2 excode_9_2.f90">
<link href="ch-clase_9.html#s-sec_p_9_3" rel="subsection" title="9.3.3 excode_9_3.f90">
<link href="ch-clase_9.html#s-sec_p_9_4" rel="subsection" title="9.3.4 excode_9_4.f90">
<link href="ch-clase_9.html#s-sec_p_9_5" rel="subsection" title="9.3.5 excode_9_5.f90">
<link href="ch-clase_9.html#s-sec_p_9_6" rel="subsection" title="9.3.6 excode_9_6.f90">
<link href="ch-clase_9.html#s-sec_p_9_7" rel="subsection" title="9.3.7 excode_9_7.f90">
<link href="ch-clase_10.html#s-sec_p_10_1" rel="subsection" title="10.3.1 Programa ejemplo_10_1.f90">
<link href="ch-clase_10.html#s-sec_p_10_2" rel="subsection" title="10.3.2 Programa ejemplo_10_2.f90">
<link href="ch-clase_10.html#s-sec_p_10_3" rel="subsection" title="10.3.3 Programa ejemplo_10_3.f90">
<link href="ch-clase_10.html#s-sec_p_10_4" rel="subsection" title="10.3.4 Programa ejemplo_10_4.f90">
<link href="ch-clase_11.html#s-sec_p_11_1" rel="subsection" title="11.3.1 Programa ejemplo_11_1.f90">
<link href="ch-clase_11.html#s-sec_p_11_2" rel="subsection" title="11.3.2 Programa ejemplo_11_2.f90">
<link href="ch-clase_11.html#s-sec_p_11_3" rel="subsection" title="11.3.3 Programa ejemplo_11_3.f90">
<link href="ch-clase_11.html#s-sec_p_11_4" rel="subsection" title="11.3.4 Programa ejemplo_11_4.f90">
<link href="ch-clase_blaslap.html#s-sec_p_bl_1" rel="subsection" title="12.3.1 Ejemplo de fichero make.inc para LAPACK">
<link href="ch-clase_blaslap.html#s-sec_p_bl_2" rel="subsection" title="12.3.2 Ejemplo de fichero make.inc para LAPACK95">
<link href="ch-clase_blaslap.html#s-sec_p_bl_3" rel="subsection" title="12.3.3 Ejemplo de programa que invoca LAPACK95">
<link href="ch-clase_blaslap.html#s-sec_p_bl_4" rel="subsection" title="12.3.4 Ejemplo de makefile para compilar programas que invocan LAPACK95">

</head>

<body>

<p><a name="ch-clase_9"></a></p>
<hr>

<p>
[ <a href="ch-clase_8.html">previous</a> ]
[ <a href="index.html#contents">Contents</a> ]
[ <a href="ch-clase_1.html">1</a> ]
[ <a href="ch-clase_2.html">2</a> ]
[ <a href="ch-clase_3.html">3</a> ]
[ <a href="ch-clase_4.html">4</a> ]
[ <a href="ch-clase_7.html">5</a> ]
[ <a href="ch-clase_5.html">6</a> ]
[ <a href="ch-clase_6.html">7</a> ]
[ <a href="ch-clase_8.html">8</a> ]
[ 9 ]
[ <a href="ch-clase_10.html">10</a> ]
[ <a href="ch-clase_11.html">11</a> ]
[ <a href="ch-clase_blaslap.html">12</a> ]
[ <a href="ch-cap_ref.html">13</a> ]
[ <a href="ch-clase_10.html">next</a> ]
</p>

<hr>

<h1>
<code>Fortran 90</code> Lessons for Computational Chemistry
<br>Chapter 9 - Subprograms (II): subroutines
</h1>

<hr>

<h2 id="s-sec_91">9.1 Objectives</h2>

<p>
The main aims of this session consist of:
</p>
<ol type="1" start="1" >
<li>
<p>
considering the differences between functions and subroutines and in what cases
are the latter useful.
</p>
</li>
</ol>
<ol type="1" start="2" >
<li>
<p>
introducing the user to the subroutine definition procedures.
</p>
</li>
</ol>
<ol type="1" start="3" >
<li>
<p>
explaining subroutine arguments roles.
</p>
</li>
</ol>
<ol type="1" start="4" >
<li>
<p>
defining the commands <samp>CALL</samp> and <samp>INTERFACE</samp>.
</p>
</li>
</ol>
<ol type="1" start="5" >
<li>
<p>
explaining the <em>scope</em> of the variables of a subroutine and the role of
local variables and of variables with the <samp>SAVE</samp> attribute.
</p>
</li>
</ol>
<ol type="1" start="6" >
<li>
<p>
presenting the different ways of passing an array as an argument to a
subroutine.
</p>
</li>
</ol>
<ol type="1" start="7" >
<li>
<p>
defining the so called automatic arrays.
</p>
</li>
</ol>

<hr>

<h2 id="s-sec_92">9.2 Main items.</h2>
<ol type="1" start="1" >
<li>
<p>
The use of subroutines favors a structured programming through the definition
of subtasks and avoiding code duplication.  Together with functions, they make
possible to access to an extense collection of libraries for multiple
applications.
</p>
</li>
</ol>
<ol type="1" start="2" >
<li>
<p>
To better explain this point we will make use of a simple example: solving a
second order equation.  A possible way of dividing this task in simpler
subtasks is as follows
</p>
<ol type="1" start="1" >
<li>
<p>
Main program.
</p>
</li>
</ol>
<ol type="1" start="2" >
<li>
<p>
Equation coefficient input.
</p>
</li>
</ol>
<ol type="1" start="3" >
<li>
<p>
Solution of the algebraic equation.
</p>
</li>
</ol>
<ol type="1" start="4" >
<li>
<p>
Solution output.
</p>
</li>
</ol>

<p>
The program <a href="#s-sec_p_9_1"><samp>excode_9_1.f90</samp>, Section
9.3.1</a> follows closely this scheme with two subroutines:
<samp>Interact</samp> and <samp>Solve</samp>.
</p>
</li>
</ol>
<ol type="1" start="3" >
<li>
<p>
The syntax to define a subroutine is as follows
</p>

<pre>
       SUBROUTINE <var>subroutine_name</var>(arguments [optional])
              IMPLICIT NONE
              Arguments (dummy variables) definition (INTENT)
              ...
              Local variables definition
              ...
              Execution Section
              ...
              [RETURN]
      END SUBROUTINE  <var>subroutine_name</var>
</pre>

<p>
Argumentos are called <em>dummy</em> because their definition is not followed
by a memory assignment, this assignment will take place once the subroutine is
called.
</p>

<p>
Each subroutine is compiled in a separate way by the compiler, what allows for
the use of <em>local variables</em> that may have the same name in different
subroutines and the main program without clashing due to the different scopes.
</p>

<p>
This scheme can be seen in program <a
href="#s-sec_p_9_1"><samp>excode_9_1.f90</samp>, Section 9.3.1</a>.
</p>
</li>
</ol>
<ol type="1" start="4" >
<li>
<p>
A subroutine is invoked with the <samp>CALL</samp> command as follows
</p>

<pre>
     CALL subroutine_name(arguments [optional])
</pre>

<p>
Once the subroutine is executed the program flow returns to the program unit
where the subroutine was invoked, after the <samp>CALL</samp> statement.  The
subroutine determines when to return to the invoking unit once the
<samp>RETURN</samp> statement is found or if the subroutine execution ends.
</p>
</li>
</ol>
<ol type="1" start="5" >
<li>
<p>
The subroutine and the main program data flow takes place through the
arguments, also called subroutine parameters.  Arguments in the subroutine
definition are <em>dummy</em> variables, with an associated type but no space
reserved in memory.  For example, the <samp>E</samp>, <samp>F</samp>, and
<samp>G</samp> arguments in the <samp>Solve</samp> subroutine in the code <a
href="#s-sec_p_9_1"><samp>excode_9_1.f90</samp>, Section 9.3.1</a> are of
<samp>REAL</samp> type, but without any memory allocation.  Only when the
subroutine is invoked with the <samp>CALL Solve(P,Q,R,Root1,Root2,IFail)</samp>
command the arguments <samp>E</samp>, <samp>F</samp>, and <samp>G</samp> are
replaced by pointers to the main program variables <samp>P</samp>,
<samp>Q</samp>, and <samp>R</samp>.  This is why it is of great importance that
the data type of variables and arguments match correctly.
</p>
</li>
</ol>
<ol type="1" start="6" >
<li>
<p>
Some of the arguments provide the necessary input for the subroutine, while
others are output arguments that send the subroutine results to the invoking
program unit.  Mixed character input/output arguments can also be used.
</p>

<p>
Those parameters that are only input parameters should be defined using the
<samp>INTENT(IN)</samp> attribute that, as it is the case with functions,
indicate that the argument values cannot be altered in the subroutine.
</p>

<p>
If the parameters are output, the arguments should be defined with the
<samp>INTENT(OUT)</samp> attribute, to avoid taking into account the input
value of the argument.
</p>

<p>
Mixed character arguments should be defined with the <samp>INTENT(INOUT)</samp>
attribute.
</p>

<p>
The subroutine <samp>Solve</samp> in example <a
href="#s-sec_p_9_1"><samp>excode_9_1.f90</samp>, Section 9.3.1</a> provides
examples for the three cases.  It is advisable to label with the corresponding
<samp>INTENT</samp> attribute every argument.
</p>
</li>
</ol>
<ol type="1" start="7" >
<li>
<p>
In order to facilitate the accordance between variables in the invoking program
unit and the subroutine the user can defined the so called <em>interface
blocks</em>.  The example <a href="#s-sec_p_9_2"><samp>excode_9_2.f90</samp>,
Section 9.3.2</a> is the same code than <a
href="#s-sec_p_9_1"><samp>excode_9_1.f90</samp>, Section 9.3.1</a> to which
interface blocks have been added for the <samp>Interact</samp> and
<samp>Solve</samp> subroutines.
</p>
</li>
</ol>
<ol type="1" start="8" >
<li>
<p>
As in the case of functions, those variables defined in a subroutine that are
not arguments are considered as local variables.  For example, the
<samp>Interact</samp> subroutine in <a
href="#s-sec_p_9_1"><samp>excode_9_1.f90</samp>, Section 9.3.1</a> has a local
variable called <samp>IO_Status</samp>.
</p>

<p>
In general the local variables are created once the subroutine is called and
the value is lost unless they possess the <samp>SAVE</samp> attribute, that
makes possible to store the variable value from one call to the next.  For
example
</p>

<pre>
     INTEGER, SAVE:: It = 0
</pre>

<p>
The variable <samp>It</samp> value is kept among different calls to the
subroutine.
</p>

<p>
As it is the case for functions, it is possible that the subprogram has access
to the main program variables making use of the <samp>CONTAINS</samp>
statement.  This solution can be hard to scale once programs acquire certain
size and it is not very advisable.
</p>
</li>
</ol>
<ol type="1" start="9" >
<li>
<p>
When the argument of a subroutine is of <em>array</em> type it is necessary to
provide some extra information about the matrix to avoid the possible access of
the subroutine to wrong memory areas.  In order to achieve this there are three
possible ways of specifying the dimensiones of an array included in a
subroutine list of arguments.
</p>
<ol type="1" start="1" >
<li>
<p>
<em>explicit-shape approach</em>:
</p>

<p>
En este caso se incluyen como argumentos en la llamada a la subrutina las
dimensiones de las matrices implicadas, declarando posteriormente las matrices
haciendo uso de dichas dimensiones.  Por ejemplo, si en una subrutina llamada
<samp>test_pass</samp> se incluye un vector de entrada llamado
<samp>space_vec_in</samp> y uno de salida<samp>space_vec_out</samp> con la
misma dimensión, si hacemos uso del <em>explicit-shape approach</em> la
subrutina comenzaría como
</p>

<pre>
     SUBROUTINE test_pass(space_vec_in, space_vec_out, dim_vec)
              IMPLICIT NONE
              INTEGER, INTENT(IN) :: dim_vec
              REAL, INTENT(IN), DIMENSION(1:dim_vec) :: space_vec_in
              REAL, INTENT(OUT), DIMENSION(1:dim_vec) :: space_vec_out
              ......
      END SUBROUTINE test_pass
</pre>
</li>
</ol>
<ol type="1" start="2" >
<li>
<p>
<em>assumed-shape approach</em>:
</p>

<p>
En este caso es necesario incluir el correspondiente bloque
<samp>INTERFACE</samp> en el subprograma que invoca la subrutina.  Como veremos
en el <a href="ch-clase_10.html">Subprograms (III): modules, Chapter 10</a>
esto se puede evitar incluyendo la subrutina en un módulo.
</p>

<p>
En el <a href="#s-sec_p_9_3"><samp>excode_9_3.f90</samp>, Section 9.3.3</a>
puede verse un programa en el que se calcula la media, la mediana[<a
href="footnotes.html#f11" name="fr11">11</a>], la varianza y la desviación
estándar de un conjunto de números generados aleatoriamente.  En el programa
hemos marcado algunos de los puntos de interés que queremos explicar con
detalle.
</p>
<ul>
<li>
<p>
<em>(1-3)</em> Hemos definido la matriz con dimensión variable, de forma que se
dimensione mediante una orden <samp>ALLOCATE</samp>.  En la orden que
dimensiona a la matriz se indica que es un vector (<samp>DIMENSION(:)</samp>) y
del mismo modo se hace en el <em>interface block</em>.  El uso del
<em>interface block</em> es recomendable, y en casos como este, con matrices
definidas de este modo, resulta obligatorio.  La orden <em>(3)</em>,
<samp>ALLOCATE(X(1:N), STAT = IERR)</samp> hace que <samp>X</samp> pase a ser
un vector N-dimensional.  Usamos también el campo opcional <samp>STAT</samp>
que nos permita saber si se ha podido dimensionar el arreglo solicitado.  Solo
si la salida (<samp>IERR</samp>) es cero la matriz se ha creado sin problemas.
El uso de esta opción debe generalizarse.
</p>

<pre>
       REAL , ALLOCATABLE , DIMENSION(:) :: X  !! (1)
     
       ...
     
       INTERFACE
          SUBROUTINE STATS(X,N,MEAN,STD_DEV,MEDIAN)
            IMPLICIT NONE
     
            ...
     
            REAL      , INTENT(IN) , DIMENSION(:)   ::    X  !!  (1)
     
            ...
     
          END SUBROUTINE STATS
       END INTERFACE
</pre>

<p>
Es importante tener en cuenta que se puede definir como
<samp>ALLOCATABLE</samp> el argumento con el que se llama a una subrutina, así
como a variables internas o locales de la subrutina, pero una variable
<em>dummy</em> no puede tener este atributo.
</p>

<p>
A diferencia de en <code>FORTRAN77</code>, la forma recomendada de transmitir
arreglos de datos entre un programa y una subrutina es como en el ejemplo,
usando <em>assumed shape arguments</em> en los que no se da ninguna información
acerca del tamaño del arreglo.  Sí deben coincidir ambas variables en tipo,
rango y clase (<samp>KIND</samp>).
</p>
</li>
</ul>
<ul>
<li>
<p>
<em>(4)</em> y <em>(6)</em>: En estas órdenes se aprovecha la capacidad de
<code>Fortran90</code> para trabajar con arreglos de variables, ya sean estos
vectores o matrices.  Por ejemplo, el comando <samp>X=X*1000</samp> multiplica
todas las componentes del vector <samp>X</samp> por un escalar y el comando
<samp>SUMXI=SUM(X)</samp> aprovecha la función <samp>SUM</samp> para sumar las
componentes del vector.  En estilo <code>Fortran 77</code> estas operaciones
conllevarían un bucle <samp>DO</samp>, por ejemplo
</p>

<pre>
     SUMXI = 0.0
     DO I = 1, N
        SUMXI = SUMXI + X(I)
     ENDDO
</pre>
</li>
</ul>
<ul>
<li>
<p>
<em>(5)</em> En esta parte del programa se libera la memoria reservada para el
vector <samp>X</samp> usando el comando <samp>DEALLOCATE</samp>.  Este paso no
es obligatorio en este programa, pero sí cuando la matriz del tipo
<samp>ALLOCATE</samp> se ha definido en una función o subrutina y no tiene el
atributo <samp>SAVE</samp>.
</p>
</li>
</ul>
<ul>
<li>
<p>
<em>(7)</em> Aquí se aprovecha el comando <samp>CONTAINS</samp> para hacer que
la subrutina de ordenamiento <samp>SELECTION</samp>, que como puede verse no
posee argumentos, <em>conozca</em> las misma variables que la subrutina
<samp>STATS</samp>, en la que está contenida.  Por ello, en la subrutina
<samp>SELECTION</samp> solo es preciso definir las variables locales.  Esta
subrutina se encarga de ordenar la lista de números según un algoritmo que
consiste en buscar el número más pequeño de la lista y hacerlo el primer
miembro.  Se busca a continuación el más pequeño de los restantes que pasa a
ser segundo, y así prosigue hasta tener ordenada la lista de números.
</p>
</li>
</ul>

<p>
La definición de bloques <samp>INTERFACE</samp> se facilita con el uso de
módulos, que describimos en la siguiente unidad.
</p>
</li>
</ol>
<ol type="1" start="3" >
<li>
<p>
<em>assumed-size approach</em>
</p>

<p>
En este caso no se da información a la subrutina acerca de las dimensiones de
la matriz, es fácil caer en errores de difícil diagnóstico y se desaconseja su
uso.
</p>
</li>
</ol>
</li>
</ol>
<ol type="1" start="10" >
<li>
<p>
Arreglos multidimensionales.  El <a
href="#s-sec_p_9_5"><samp>excode_9_5.f90</samp>, Section 9.3.5</a> es un
ejemplo de como pasar como argumentos arreglos multidimensionales como
<em>assumed shape arrays</em>.  En él, tras que el usuario defina dos matrices,
<samp>A</samp> y <samp>B</samp>, el programa calcula la matriz <samp>C</samp>
solución del producto <samp>AB</samp> y tras ello calcula la matriz traspuesta
de <samp>A</samp>.  Se hace uso de las funciones de <code>Fortran 90</code>
<samp>MATMUL</samp> y <samp>TRANSPOSE</samp>.
</p>
</li>
</ol>
<ol type="1" start="11" >
<li>
<p>
En las subrutinas pueden dimensionarse <em>automatic arrays</em>, que pueden
depender de los argumentos de la subrutina.  Estos arreglos son locales a la
subrutina, no pueden tener el argumento <samp>SAVE</samp> y se crean cada vez
que se invoca la subrutina, siendo destruidos al salir de ella.  Esto hace que
si no hay memoria suficiente para dimensionar el arreglo el programa no
funcione.  Para evitar esto deben definirse arreglos no automáticos, del tipo
<samp>ALLOCATABLE</samp>.
</p>
</li>
</ol>
<ol type="1" start="12" >
<li>
<p>
Al pasar como argumento una variable de tipo <samp>CHARACTER</samp> dicho
argumento se declar con una longitud <samp>LEN = *</samp> y cuando se llame a
la subrutina la longitud de la variable pasa a ser la longitud de la variable
en la llamada.
</p>

<p>
El <a href="#s-sec_p_9_4"><samp>excode_9_4.f90</samp>, Section 9.3.4</a>
muestra un programa en el que, al darle el nombre de un fichero y el número de
datos almacenados en dicho fichero; el programa abre el fichero y lee dos
columnas de valores que almacena en los vectores <samp>X</samp> e
<samp>Y</samp>.  En estos casos, dado que el tamaño de la variable
<samp>CHARACTER</samp> es variable, es preciso usar un <em>interface
block</em>.
</p>

<p>
El <a href="#s-sec_p_9_6"><samp>excode_9_6.f90</samp>, Section 9.3.6</a> es un
ejemplo donde se construyen dos vectores de números aleatorios de dimensión
definida por el usuario usando el método <em>Box-Mueller</em>.  Para ello se
definen dos matrices de tipo <samp>ALLOCATABLE</samp>, <samp>X</samp> e
<samp>Y</samp>, y en la subrutina interna <samp>BOX_MULLER</samp> se definen
dos vectores de tipo automático: <samp>RANDOM_u</samp> y <samp>RANDOM_v</samp>.
</p>

<p>
Para calcular el valor medio, la desviación estándar y la mediana de los
vectores <samp>X</samp> e <samp>Y</samp> se hace uso de la subrutina
<samp>STATS</samp> del <a href="#s-sec_p_9_3"><samp>excode_9_3.f90</samp>,
Section 9.3.3</a>.  Se incluye el necesario <samp>INTERFACE</samp> en el
programa principal y la subrutina se debe compilar en un fichero por separado.
<a href="#s-sec_p_9_6"><samp>excode_9_6.f90</samp>, Section 9.3.6</a>
</p>
</li>
</ol>
<ol type="1" start="13" >
<li>
<p>
Sí es importante tener en cuenta que en el caso que se transfiera un
<em>array</em> usando <em>assumed shape arguments</em> como en los ejemplos, el
primer índice de la variable en la subrutina <em>se supone que comienza con el
valor <samp>1</samp>, a menos que explícitamente se indique lo contrario</em>.
En el ejemplo <a href="#s-sec_p_9_7"><samp>excode_9_7.f90</samp>, Section
9.3.7</a> se muestra un caso simple donde es necesario indicar el índice
inicial del vector cuando este no es cero.  En este programa se calcula el
factorial de los enteros entre <samp>IMIN</samp> e <samp>IMAX</samp> y se
almacenan en un vector real.  Se puede compilar y correr el programa haciendo
<samp>IMIN = 1</samp> e <samp>IMIN = 0</samp> con y sin la definición del
índice inicial en la subrutina, para ver la diferencia en las salidas.
</p>
</li>
</ol>

<hr>

<h2 id="s-sec_93">9.3 Example Codes</h2>

<hr>

<h3 id="s-sec_p_9_1">9.3.1 <samp>excode_9_1.f90</samp></h3>

<pre>
     PROGRAM ex_9_1
       !
       IMPLICIT NONE
       ! Simple program with two subroutines.
       ! subroutine (1):: Interact :: Data input.
       ! subroutine (2):: Solve :: Solve second order Eq.
       !
       ! Variables
       REAL :: P, Q, R, Root1, Root2
       INTEGER :: IFail=0
       LOGICAL :: OK=.TRUE.
       !
       CALL Interact(P,Q,R,OK) ! Subrutina (1)
       !
       IF (OK) THEN
          !
          CALL Solve(P,Q,R,Root1,Root2,IFail) ! Subrutina (2)
          !
          IF (IFail == 1) THEN
             PRINT *,' Complex roots'
             PRINT *,' calculation aborted'
          ELSE
             PRINT *,' Roots are ',Root1,' ',Root2
          ENDIF
          !
       ELSE
          !
          PRINT*,' Error in data input program ends'
          !
       ENDIF
       !
     END PROGRAM ex_9_1
     !
     !
     SUBROUTINE Interact(A,B,C,OK)
       IMPLICIT NONE
       REAL , INTENT(OUT) :: A
       REAL , INTENT(OUT) :: B
       REAL , INTENT(OUT) :: C
       LOGICAL , INTENT(OUT) :: OK
       INTEGER :: IO_Status=0
       PRINT*,' Type in the coefficients A, B AND C'
       READ(UNIT=*,FMT=*,IOSTAT=IO_Status) A,B,C
       IF (IO_Status == 0) THEN
          OK=.TRUE.
       ELSE
          OK=.FALSE.
       ENDIF
     END SUBROUTINE Interact
     !
     !
     SUBROUTINE Solve(E,F,G,Root1,Root2,IFail)
       IMPLICIT NONE
       REAL , INTENT(IN) :: E
       REAL , INTENT(IN) :: F
       REAL , INTENT(IN) :: G
       REAL , INTENT(OUT) :: Root1
       REAL , INTENT(OUT) :: Root2
       INTEGER , INTENT(INOUT) :: IFail
       ! Local variables
       REAL :: Term
       REAL :: A2
       Term = F*F - 4.*E*G
       A2 = E*2.0
       ! if term &lt; 0, roots are complex
       IF(Term &lt; 0.0)THEN
          IFail=1
       ELSE
          Term = SQRT(Term)
          Root1 = (-F+Term)/A2
          Root2 = (-F-Term)/A2
       ENDIF
     END SUBROUTINE Solve
</pre>

<hr>

<h3 id="s-sec_p_9_2">9.3.2 <samp>excode_9_2.f90</samp></h3>

<pre>
     PROGRAM ex_9_2
       !
       IMPLICIT NONE
       ! Simple program with two subroutines.
       ! subroutine (1):: Interact :: Data input.
       ! subroutine (2):: Solve :: Solve second order Eq.
       !
       ! Interface blocks
       INTERFACE
          SUBROUTINE Interact(A,B,C,OK)
            IMPLICIT NONE
            REAL , INTENT(OUT) ::  A
            REAL , INTENT(OUT) ::  B
            REAL , INTENT(OUT) ::  C
            LOGICAL , INTENT(OUT) :: OK
          END SUBROUTINE Interact
          SUBROUTINE Solve(E,F,G,Root1,Root2,IFail)
            IMPLICIT NONE
            REAL , INTENT(IN) :: E
            REAL , INTENT(IN) :: F
            REAL , INTENT(IN) :: G
            REAL , INTENT(OUT) :: Root1
            REAL , INTENT(OUT) :: Root2
            INTEGER , INTENT(INOUT) :: IFail
          END SUBROUTINE Solve
       END INTERFACE
       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       !
       ! Variables
       REAL :: P, Q, R, Root1, Root2
       INTEGER :: IFail=0
       LOGICAL :: OK=.TRUE.
       !
       CALL Interact(P,Q,R,OK) ! Subrutina (1)
       !
       IF (OK) THEN
          !
          CALL Solve(P,Q,R,Root1,Root2,IFail) ! Subrutina (2)
          !
          IF (IFail == 1) THEN
             PRINT *,' Complex roots'
             PRINT *,' calculation aborted'
          ELSE
             PRINT *,' Roots are ',Root1,' ',Root2
          ENDIF
          !
       ELSE
          !
          PRINT*,' Error in data input program ends'
          !
       ENDIF
       !
     END PROGRAM ex_9_2
     !
     !
     SUBROUTINE Interact(A,B,C,OK)
       IMPLICIT NONE
       REAL , INTENT(OUT) :: A
       REAL , INTENT(OUT) :: B
       REAL , INTENT(OUT) :: C
       LOGICAL , INTENT(OUT) :: OK
       INTEGER :: IO_Status=0
       PRINT*,' Type in the coefficients A, B AND C'
       READ(UNIT=*,FMT=*,IOSTAT=IO_Status)A,B,C
       IF (IO_Status == 0) THEN
          OK=.TRUE.
       ELSE
          OK=.FALSE.
       ENDIF
     END SUBROUTINE Interact
     !
     !
     SUBROUTINE Solve(E,F,G,Root1,Root2,IFail)
       IMPLICIT NONE
       REAL , INTENT(IN) :: E
       REAL , INTENT(IN) :: F
       REAL , INTENT(IN) :: G
       REAL , INTENT(OUT) :: Root1
       REAL , INTENT(OUT) :: Root2
       INTEGER , INTENT(INOUT) :: IFail
       ! Local variables
       REAL :: Term
       REAL :: A2
       Term = F*F - 4.*E*G
       A2 = E*2.0
       ! if term &lt; 0, roots are complex
       IF(Term &lt; 0.0)THEN
          IFail=1
       ELSE
          Term = SQRT(Term)
          Root1 = (-F+Term)/A2
          Root2 = (-F-Term)/A2
       ENDIF
     END SUBROUTINE Solve
</pre>

<hr>

<h3 id="s-sec_p_9_3">9.3.3 <samp>excode_9_3.f90</samp></h3>

<pre>
     PROGRAM ex_9_3
       !
       IMPLICIT NONE
       !
       ! Variables
       INTEGER :: N
       REAL , ALLOCATABLE , DIMENSION(:) :: X  !! (1)
       REAL :: M,SD,MEDIAN
       INTEGER :: IERR
       !
       ! interface block   !! (2)
       INTERFACE
          SUBROUTINE STATS(VECTOR,N,MEAN,STD_DEV,MEDIAN)
            IMPLICIT NONE
            INTEGER , INTENT(IN)                    ::  N
            REAL      , INTENT(IN) , DIMENSION(:)   :: VECTOR  !!  (1)
            REAL      , INTENT(OUT)                 :: MEAN
            REAL      , INTENT(OUT)                 :: STD_DEV
            REAL      , INTENT(OUT)                 :: MEDIAN
          END SUBROUTINE STATS
       END INTERFACE
       PRINT *,' Length of random values vector ?'
       READ *,N
       ALLOCATE(X(1:N), STAT = IERR)     !!  (3)
       IF (IERR /= 0) THEN
          PRINT*, &quot;X allocation request denied.&quot;
          STOP
       ENDIF
       CALL RANDOM_NUMBER(X)
       X=X*1000             !!  (4)
       CALL STATS(X,N,M,SD,MEDIAN)
       !
       PRINT *,' MEAN = ',M
       PRINT *,' STANDARD DEVIATION = ',SD
       PRINT *,' MEDIAN IS = ',MEDIAN
       !
       IF (ALLOCATED(X)) DEALLOCATE(X, STAT = IERR)   !! (5)
       IF (IERR /= 0) THEN
          PRINT*, &quot;X NON DEALLOCATED!&quot;
          STOP
       ENDIF
     END PROGRAM ex_9_3
     !
     SUBROUTINE STATS(VECTOR,N,MEAN,STD_DEV,MEDIAN)
       IMPLICIT NONE
       ! Defincion de variables
       INTEGER , INTENT(IN)                    ::  N
       REAL      , INTENT(IN) , DIMENSION(:)    ::  VECTOR    !! (1)
       REAL      , INTENT(OUT)                  ::  MEAN
       REAL      , INTENT(OUT)                  ::  STD_DEV
       REAL      , INTENT(OUT)                  ::  MEDIAN
       REAL      , DIMENSION(1:N)              ::  Y
       REAL :: VARIANCE = 0.0
       REAL      :: SUMXI = 0.0, SUMXI2 = 0.0
       !
       SUMXI=SUM(VECTOR)       !! (6)
       SUMXI2=SUM(VECTOR*VECTOR)    !! (6)
       MEAN=SUMXI/N       
       VARIANCE=(SUMXI2-SUMXI*SUMXI/N)/(N-1)
       STD_DEV = SQRT(VARIANCE)
       Y=VECTOR
       ! Ordena valores por proceso de seleccion
       CALL SELECTION
       IF (MOD(N,2) == 0) THEN
          MEDIAN=(Y(N/2)+Y((N/2)+1))/2
       ELSE
          MEDIAN=Y((N/2)+1)
       ENDIF
     CONTAINS     !! (7)
       SUBROUTINE SELECTION
         IMPLICIT NONE
         INTEGER :: I,J,K
         REAL :: MINIMUM
         DO I=1,N-1
            K=I
            MINIMUM=Y(I)
            DO J=I+1,N
               IF (Y(J) &lt; MINIMUM) THEN
                  K=J
                  MINIMUM=Y(K)
               END IF
            END DO
            Y(K)=Y(I)
            Y(I)=MINIMUM
         END DO
       END SUBROUTINE SELECTION
     END SUBROUTINE STATS
</pre>

<hr>

<h3 id="s-sec_p_9_4">9.3.4 <samp>excode_9_4.f90</samp></h3>

<pre>
     PROGRAM ex_9_4
       IMPLICIT NONE
       REAL,DIMENSION(1:100)::A,B
       INTEGER :: Nos,I
       CHARACTER(LEN=32)::Filename
       INTERFACE
          SUBROUTINE Readin(Name,X,Y,N)
            IMPLICIT NONE
            INTEGER , INTENT(IN) :: N
            REAL,DIMENSION(1:N),INTENT(OUT)::X,Y
            CHARACTER (LEN=*),INTENT(IN)::Name
          END SUBROUTINE Readin
       END INTERFACE
       PRINT *,' Type in the name of the data file'
       READ '(A)' , Filename
       PRINT *,' Input the number of items in the file'
       READ * , Nos
       CALL Readin(Filename,A,B,Nos)
       PRINT * , ' Data read in was'
       DO I=1,Nos
          PRINT *,' ',A(I),' ',B(I)
       ENDDO
     END PROGRAM ex_9_4
     SUBROUTINE Readin(Name,X,Y,N)
       IMPLICIT NONE
       INTEGER , INTENT(IN) :: N
       REAL,DIMENSION(1:N),INTENT(OUT)::X,Y
       CHARACTER (LEN=*),INTENT(IN)::Name
       INTEGER::I
       OPEN(UNIT=10,STATUS='OLD',FILE=Name)
       DO I=1,N
          READ(10,*)X(I),Y(I)
       END DO
       CLOSE(UNIT=10)
     END SUBROUTINE Readin
</pre>

<hr>

<h3 id="s-sec_p_9_5">9.3.5 <samp>excode_9_5.f90</samp></h3>

<pre>
     PROGRAM ex_9_5
       IMPLICIT NONE
       REAL , ALLOCATABLE , DIMENSION &amp;
            (:,:)::One,Two,Three,One_T
       INTEGER :: I,N
       INTERFACE
          SUBROUTINE Matrix_bits(A,B,C,A_T)
            IMPLICIT NONE
            REAL, DIMENSION (:,:), INTENT(IN) :: A,B
            REAL, DIMENSION (:,:), INTENT(OUT) :: C,A_T
          END SUBROUTINE Matrix_bits
       END INTERFACE
       PRINT *,'Matrix Dimension?'
       READ*,N
       ALLOCATE(One(1:N,1:N))
       ALLOCATE(Two(1:N,1:N))
       ALLOCATE(Three(1:N,1:N))
       ALLOCATE(One_T(1:N,1:N))
       DO I=1,N
          PRINT*, 'Row ', I,'-th of the first array?'
          READ*,One(I,1:N)
       END DO
       DO I=1,N
          PRINT*, 'Row ', I,'-th of the second array?'
          READ*,Two(I,1:N)
       END DO
       CALL Matrix_bits(One,Two,Three,One_T)
       PRINT*,' Result: Matrix Product'
       DO I=1,N
          PRINT *,Three(I,1:N)
       END DO
       PRINT *,' Transpose A^T:'
       DO I=1,N
          PRINT *,One_T(I,1:N)
       END DO
     END PROGRAM ex_9_5
     !
     SUBROUTINE Matrix_bits(A,B,C,A_T)
       IMPLICIT NONE
       REAL, DIMENSION (:,:), INTENT(IN) :: A,B
       REAL, DIMENSION (:,:), INTENT(OUT) :: C,A_T
       C=MATMUL(A,B)
       A_T=TRANSPOSE(A)
     END SUBROUTINE Matrix_bits
</pre>

<hr>

<h3 id="s-sec_p_9_6">9.3.6 <samp>excode_9_6.f90</samp></h3>

<pre>
     PROGRAM ex_9_6
       !
       IMPLICIT NONE
       !
       INTEGER :: I, IERR
       REAL, DIMENSION(:), ALLOCATABLE :: X, Y
       REAL :: M, SD, MEDIAN
       ! interface block   
       INTERFACE
          SUBROUTINE STATS(VECTOR,N,MEAN,STD_DEV,MEDIAN)
            IMPLICIT NONE
            INTEGER , INTENT(IN)                    ::  N
            REAL      , INTENT(IN) , DIMENSION(:)   :: VECTOR  
            REAL      , INTENT(OUT)                 :: MEAN
            REAL      , INTENT(OUT)                 :: STD_DEV
            REAL      , INTENT(OUT)                 :: MEDIAN
          END SUBROUTINE STATS
       END INTERFACE
       !
       READ*, I  
       !
       ALLOCATE(X(1:I), STAT = IERR)    
       IF (IERR /= 0) THEN
          PRINT*, &quot;X allocation request denied.&quot;
          STOP
       ENDIF
       !
       ALLOCATE(Y(1:I), STAT = IERR)    
       IF (IERR /= 0) THEN
          PRINT*, &quot;Y allocation request denied.&quot;
          STOP
       ENDIF
       !
       CALL BOX_MULLER(I)
       !
       PRINT*, X
       CALL STATS(X,I,M,SD,MEDIAN)
       !
       PRINT *,' MEAN = ',M
       PRINT *,' STANDARD DEVIATION = ',SD
       PRINT *,' MEDIAN IS = ',MEDIAN
       !
       IF (ALLOCATED(X)) DEALLOCATE(X, STAT = IERR) 
       IF (IERR /= 0) THEN
          PRINT*, &quot;X NON DEALLOCATED!&quot;
          STOP
       ENDIF
       PRINT*, Y
       CALL STATS(Y,I,M,SD,MEDIAN)
       !
       PRINT *,' MEAN = ',M
       PRINT *,' STANDARD DEVIATION = ',SD
       PRINT *,' MEDIAN IS = ',MEDIAN
       !
       IF (ALLOCATED(Y)) DEALLOCATE(Y, STAT = IERR)   
       IF (IERR /= 0) THEN
          PRINT*, &quot;Y NON DEALLOCATED!&quot;
          STOP
       ENDIF
       !
     CONTAINS
       !
       SUBROUTINE BOX_MULLER(dim)
         ! 
         ! Uses the Box-Muller method to create two normally distributed vectors
         !
         INTEGER, INTENT(IN) :: dim
         !
         REAL, PARAMETER :: PI = ACOS(-1.0)
         REAL, DIMENSION(dim) :: RANDOM_u, RANDOM_v ! Automatic arrays
         !
         CALL RANDOM_NUMBER(RANDOM_u)
         CALL RANDOM_NUMBER(RANDOM_v)
         !
         X = SQRT(-2.0*LOG(RANDOM_u))
         Y = X*SIN(2*PI*RANDOM_v)
         X = X*COS(2*PI*RANDOM_v)
         !
       END SUBROUTINE BOX_MULLER
       !
     END PROGRAM ex_9_6
     !!!!!!!!!!!!!!!!!!!!!!!!!
     !!!!!!!!!!!!!!!!!!!!!!!!!
     SUBROUTINE STATS(VECTOR,N,MEAN,STD_DEV,MEDIAN)
       IMPLICIT NONE
       ! Arguments
       INTEGER , INTENT(IN)                    ::  N
       REAL      , INTENT(IN) , DIMENSION(:)    ::  VECTOR    !! (1)
       REAL      , INTENT(OUT)                  ::  MEAN
       REAL      , INTENT(OUT)                  ::  STD_DEV
       REAL      , INTENT(OUT)                  ::  MEDIAN
       ! Local Variables
       REAL      , DIMENSION(1:N)              ::  Y
       REAL      :: VARIANCE = 0.0
       REAL      :: SUMXI = 0.0, SUMXI2 = 0.0
       !
       SUMXI=SUM(VECTOR)       !! (6)
       SUMXI2=SUM(VECTOR*VECTOR)    !! (6)
       MEAN=SUMXI/N       
       VARIANCE=(SUMXI2-SUMXI*SUMXI/N)/(N-1)
       STD_DEV = SQRT(VARIANCE)
       Y=VECTOR
       ! Sort values
       CALL SELECTION
       IF (MOD(N,2) == 0) THEN
          MEDIAN=(Y(N/2)+Y((N/2)+1))/2
       ELSE
          MEDIAN=Y((N/2)+1)
       ENDIF
     CONTAINS     !! (7)
       SUBROUTINE SELECTION
         IMPLICIT NONE
         INTEGER :: I,J,K
         REAL :: MINIMUM
         DO I=1,N-1
            K=I
            MINIMUM=Y(I)
            DO J=I+1,N
               IF (Y(J) &lt; MINIMUM) THEN
                  K=J
                  MINIMUM=Y(K)
               END IF
            END DO
            Y(K)=Y(I)
            Y(I)=MINIMUM
         END DO
       END SUBROUTINE SELECTION
     END SUBROUTINE STATS
</pre>

<hr>

<h3 id="s-sec_p_9_7">9.3.7 <samp>excode_9_7.f90</samp></h3>

<pre>
     PROGRAM ex_9_7
       !
       IMPLICIT NONE
       !
       INTERFACE
          SUBROUTINE SUBEXAMPLE(IMIN, IMAX, FACT_MAT)
            INTEGER, intent(in) :: IMIN, IMAX
            REAL, DIMENSION(IMIN:), intent(out) :: FACT_MAT
          END SUBROUTINE SUBEXAMPLE
       END INTERFACE
       !
       ! Variables
       REAL, DIMENSION(:), ALLOCATABLE :: FACT_MAT
       INTEGER :: IMIN, IMAX, I
       !
       IMIN = 0
       IMAX = 5
       !
       ALLOCATE(FACT_MAT(IMIN:IMAX))
       !
       PRINT*, &quot;MAIN&quot;, SIZE(FACT_MAT)
       !
       CALL SUBEXAMPLE(IMIN, IMAX, FACT_MAT)
       !
       DO I = IMIN, IMAX
          PRINT*, I, FACT_MAT(I)
       ENDDO
       !
     END PROGRAM ex_9_7
     !!!!!!!!!!
     !!!!!!!!!!
     SUBROUTINE SUBEXAMPLE(IMIN, IMAX, FACT_MAT)
       !
       IMPLICIT NONE
       INTEGER, intent(in) :: IMIN, IMAX
       REAL, DIMENSION(IMIN:), intent(out) :: FACT_MAT
       ! The subroutine with the next line only would work for IMIN = 1
       !  REAL, DIMENSION(:), intent(out) :: FACT_MAT
       !
       INTEGER :: j,k
       !
       PRINT*, &quot;SUB&quot;, SIZE(FACT_MAT)
       !
       DO j = imin, imax
          fact_mat(j) = 1.0
          do k = 2, j
             fact_mat(j) = k*fact_mat(j)
          enddo
       ENDDO
       !
       !
     END SUBROUTINE SUBEXAMPLE
</pre>

<hr>

<p>
[ <a href="ch-clase_8.html">previous</a> ]
[ <a href="index.html#contents">Contents</a> ]
[ <a href="ch-clase_1.html">1</a> ]
[ <a href="ch-clase_2.html">2</a> ]
[ <a href="ch-clase_3.html">3</a> ]
[ <a href="ch-clase_4.html">4</a> ]
[ <a href="ch-clase_7.html">5</a> ]
[ <a href="ch-clase_5.html">6</a> ]
[ <a href="ch-clase_6.html">7</a> ]
[ <a href="ch-clase_8.html">8</a> ]
[ 9 ]
[ <a href="ch-clase_10.html">10</a> ]
[ <a href="ch-clase_11.html">11</a> ]
[ <a href="ch-clase_blaslap.html">12</a> ]
[ <a href="ch-cap_ref.html">13</a> ]
[ <a href="ch-clase_10.html">next</a> ]
</p>

<hr>

<p>
<code>Fortran 90</code> Lessons for Computational Chemistry
</p>

<address>
0.0<br>
<br>
Curro Pérez-Bernal <code><a href="mailto:francisco.perez@dfaie.uhu.es">mailto:francisco.perez@dfaie.uhu.es</a></code><br>
<br>
</address>
<hr>

</body>

</html>

