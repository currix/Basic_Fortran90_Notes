<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">

<html>

<head>

<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">

<title>Fortran 90 Lessons for Computational Chemistry - Subprograms (II): subroutines</title>

<link href="index.html" rel="start">
<link href="ch-clase_8.html" rel="prev">
<link href="ch-clase_10.html" rel="next">
<link href="index.html#contents" rel="contents">
<link href="index.html#copyright" rel="copyright">
<link href="ch-clase_1.html" rel="chapter" title="1 Introduction">
<link href="ch-clase_2.html" rel="chapter" title="2 Basic Operations">
<link href="ch-clase_3.html" rel="chapter" title="3 Introduction to Fortran Arrays">
<link href="ch-clase_4.html" rel="chapter" title="4 More on Arrays">
<link href="ch-clase_7.html" rel="chapter" title="5 Control Structures">
<link href="ch-clase_5.html" rel="chapter" title="6 INPUT/OUTPUT (I)">
<link href="ch-clase_6.html" rel="chapter" title="7 Input/Output (II)">
<link href="ch-clase_8.html" rel="chapter" title="8 Subprograms (I): FUNCTIONS">
<link href="ch-clase_9.html" rel="chapter" title="9 Subprograms (II): subroutines">
<link href="ch-clase_10.html" rel="chapter" title="10 Subprograms (III): modules">
<link href="ch-clase_11.html" rel="chapter" title="11 Subprogramas (IV)">
<link href="ch-clase_blaslap.html" rel="chapter" title="12 Instalación y uso de las bibliotecas BLAS y LAPACK">
<link href="ch-cap_ref.html" rel="chapter" title="13 Referencias">
<link href="ch-clase_1.html#s-sec_11" rel="section" title="1.1 Objectives">
<link href="ch-clase_1.html#s-sec_12" rel="section" title="1.2 Main items.">
<link href="ch-clase_1.html#s-sec_13" rel="section" title="1.3 Example Codes.">
<link href="ch-clase_2.html#s-sec_21" rel="section" title="2.1 Objectives">
<link href="ch-clase_2.html#s-sec_22" rel="section" title="2.2 Main items.">
<link href="ch-clase_2.html#s-sec_23" rel="section" title="2.3 Example Codes.">
<link href="ch-clase_3.html#s-sec_31" rel="section" title="3.1 Objectivos">
<link href="ch-clase_3.html#s-sec_32" rel="section" title="3.2 Main items.">
<link href="ch-clase_3.html#s-sec_33" rel="section" title="3.3 Example Codes.">
<link href="ch-clase_4.html#s-sec_41" rel="section" title="4.1 Objectives">
<link href="ch-clase_4.html#s-sec_42" rel="section" title="4.2 Main items.">
<link href="ch-clase_4.html#s-sec_43" rel="section" title="4.3 Example Codes.">
<link href="ch-clase_7.html#s-sec_71" rel="section" title="5.1 Objectives">
<link href="ch-clase_7.html#s-sec_72" rel="section" title="5.2 Main items.">
<link href="ch-clase_7.html#s-sec_73" rel="section" title="5.3 Example codes.">
<link href="ch-clase_5.html#s-sec_51" rel="section" title="6.1 Objectivos">
<link href="ch-clase_5.html#s-sec_52" rel="section" title="6.2 Main Items.">
<link href="ch-clase_5.html#s-sec_53" rel="section" title="6.3 Example Codes">
<link href="ch-clase_6.html#s-sec_61" rel="section" title="7.1 Objectives">
<link href="ch-clase_6.html#s-sec_62" rel="section" title="7.2 Main items.">
<link href="ch-clase_6.html#s-sec_63" rel="section" title="7.3 Example Codes">
<link href="ch-clase_8.html#s-sec_81" rel="section" title="8.1 Objectives">
<link href="ch-clase_8.html#s-sec_82" rel="section" title="8.2 Main items.">
<link href="ch-clase_8.html#s-sec_83" rel="section" title="8.3 Example Codes">
<link href="ch-clase_9.html#s-sec_91" rel="section" title="9.1 Objectives">
<link href="ch-clase_9.html#s-sec_92" rel="section" title="9.2 Main items.">
<link href="ch-clase_9.html#s-sec_93" rel="section" title="9.3 Example Codes">
<link href="ch-clase_10.html#s-sec_101" rel="section" title="10.1 Objectives">
<link href="ch-clase_10.html#s-sec_102" rel="section" title="10.2 Main items.">
<link href="ch-clase_10.html#s-sec_103" rel="section" title="10.3 Example codes.">
<link href="ch-clase_11.html#s-sec_111" rel="section" title="11.1 Objetivos">
<link href="ch-clase_11.html#s-sec_112" rel="section" title="11.2 Puntos destacables.">
<link href="ch-clase_11.html#s-sec_113" rel="section" title="11.3 Programas usados como ejemplo.">
<link href="ch-clase_blaslap.html#s-sec_bl1" rel="section" title="12.1 Objetivos">
<link href="ch-clase_blaslap.html#s-sec_bl2" rel="section" title="12.2 Puntos destacables.">
<link href="ch-clase_blaslap.html#s-sec_bl3" rel="section" title="12.3 Programas usados como ejemplo.">
<link href="ch-clase_1.html#s-sec_p_1_1" rel="subsection" title="1.3.1 excode_1_1.f90">
<link href="ch-clase_1.html#s-sec_p_1_2" rel="subsection" title="1.3.2 excode_1_2.f90">
<link href="ch-clase_2.html#s-sec_p_2_1" rel="subsection" title="2.3.1 excode_2_1.f90">
<link href="ch-clase_2.html#s-sec_p_2_2" rel="subsection" title="2.3.2 excode_2_2.f90">
<link href="ch-clase_2.html#s-sec_p_2_3" rel="subsection" title="2.3.3 excode_2_3.f90">
<link href="ch-clase_2.html#s-sec_p_2_4" rel="subsection" title="2.3.4 excode_2_4.f90">
<link href="ch-clase_2.html#s-sec_p_2_5" rel="subsection" title="2.3.5 excode_2_5.f90">
<link href="ch-clase_2.html#s-sec_p_2_6" rel="subsection" title="2.3.6 excode_2_6.f90">
<link href="ch-clase_3.html#s-sec_p_3_1" rel="subsection" title="3.3.1 excode_3_1.f90">
<link href="ch-clase_3.html#s-sec_p_3_2" rel="subsection" title="3.3.2 excode_3_2.f90">
<link href="ch-clase_3.html#s-sec_p_3_3" rel="subsection" title="3.3.3 excode_3_3.f90">
<link href="ch-clase_3.html#s-sec_p_3_4" rel="subsection" title="3.3.4 excode_3_4.f90">
<link href="ch-clase_4.html#s-sec_p_4_1" rel="subsection" title="4.3.1 excode_4_1.f90">
<link href="ch-clase_4.html#s-sec_p_4_2" rel="subsection" title="4.3.2 excode_4_2.f90">
<link href="ch-clase_4.html#s-sec_p_4_3" rel="subsection" title="4.3.3 excode_4_3.f90">
<link href="ch-clase_4.html#s-sec_p_4_4" rel="subsection" title="4.3.4 excode_4_4.f90">
<link href="ch-clase_4.html#s-sec_p_4_5" rel="subsection" title="4.3.5 excode_4_5.f90">
<link href="ch-clase_4.html#s-sec_p_4_6" rel="subsection" title="4.3.6 excode_4_6.f90">
<link href="ch-clase_7.html#s-sec_p_7_1" rel="subsection" title="5.3.1 excode_5_1.f90">
<link href="ch-clase_7.html#s-sec_p_7_2" rel="subsection" title="5.3.2 excode_5_2.f90">
<link href="ch-clase_7.html#s-sec_p_7_3" rel="subsection" title="5.3.3 excode_5_3.f90">
<link href="ch-clase_7.html#s-sec_p_7_4" rel="subsection" title="5.3.4 Programa ejemplo_5_4.f90">
<link href="ch-clase_5.html#s-sec_p_5_1" rel="subsection" title="6.3.1 excode_6_1.f90">
<link href="ch-clase_5.html#s-sec_p_5_2" rel="subsection" title="6.3.2 excode_6_2.f90">
<link href="ch-clase_5.html#s-sec_p_5_3" rel="subsection" title="6.3.3 excode_6_3.f90">
<link href="ch-clase_5.html#s-sec_p_5_4" rel="subsection" title="6.3.4 excode_6_4.f90">
<link href="ch-clase_5.html#s-sec_p_5_5" rel="subsection" title="6.3.5 excode_6_5.f90">
<link href="ch-clase_5.html#s-sec_p_5_6" rel="subsection" title="6.3.6 excode_6_6.f90">
<link href="ch-clase_5.html#s-sec_p_5_7" rel="subsection" title="6.3.7 excode_6_7.f90">
<link href="ch-clase_6.html#s-sec_p_6_1" rel="subsection" title="7.3.1 Programa ejemplo_7_1.f90">
<link href="ch-clase_6.html#s-sec_p_6_2" rel="subsection" title="7.3.2 excode_7_2.f90">
<link href="ch-clase_6.html#s-sec_p_6_22" rel="subsection" title="7.3.3 Script ej_here_file">
<link href="ch-clase_6.html#s-sec_p_6_3" rel="subsection" title="7.3.4 excode_7_3.f90">
<link href="ch-clase_6.html#s-sec_p_6_32" rel="subsection" title="7.3.5 namelist input file">
<link href="ch-clase_6.html#s-sec_p_6_4" rel="subsection" title="7.3.6 excode_7_4.f90">
<link href="ch-clase_8.html#s-sec_p_8_1" rel="subsection" title="8.3.1 excode_8_1.f90">
<link href="ch-clase_8.html#s-sec_p_8_2" rel="subsection" title="8.3.2 excode_8_2.f90">
<link href="ch-clase_8.html#s-sec_p_8_3" rel="subsection" title="8.3.3 Programa ejemplo_8_3.f90">
<link href="ch-clase_8.html#s-sec_p_8_4" rel="subsection" title="8.3.4 Programa ejemplo_8_4.f90">
<link href="ch-clase_8.html#s-sec_p_8_5" rel="subsection" title="8.3.5 excode_8_5.f90">
<link href="ch-clase_8.html#s-sec_p_8_6" rel="subsection" title="8.3.6 excode_8_6.f90">
<link href="ch-clase_8.html#s-sec_p_8_7" rel="subsection" title="8.3.7 excode_8_7.f90">
<link href="ch-clase_9.html#s-sec_p_9_1" rel="subsection" title="9.3.1 excode_9_1.f90">
<link href="ch-clase_9.html#s-sec_p_9_2" rel="subsection" title="9.3.2 excode_9_2.f90">
<link href="ch-clase_9.html#s-sec_p_9_3" rel="subsection" title="9.3.3 excode_9_3.f90">
<link href="ch-clase_9.html#s-sec_p_9_4" rel="subsection" title="9.3.4 excode_9_4.f90">
<link href="ch-clase_9.html#s-sec_p_9_5" rel="subsection" title="9.3.5 excode_9_5.f90">
<link href="ch-clase_9.html#s-sec_p_9_6" rel="subsection" title="9.3.6 excode_9_6.f90">
<link href="ch-clase_9.html#s-sec_p_9_7" rel="subsection" title="9.3.7 excode_9_7.f90">
<link href="ch-clase_10.html#s-sec_p_10_1" rel="subsection" title="10.3.1 excode_10_1.f90">
<link href="ch-clase_10.html#s-sec_p_10_1_mod" rel="subsection" title="10.3.2 excode_10_1_mod.f90">
<link href="ch-clase_10.html#s-sec_p_10_2" rel="subsection" title="10.3.3 excode_10_2.f90">
<link href="ch-clase_10.html#s-sec_p_10_2_mod" rel="subsection" title="10.3.4 excode_10_2_mod.f90">
<link href="ch-clase_11.html#s-sec_p_11_1" rel="subsection" title="11.3.1 Programa ejemplo_11_1.f90">
<link href="ch-clase_11.html#s-sec_p_11_2" rel="subsection" title="11.3.2 Programa ejemplo_11_2.f90">
<link href="ch-clase_11.html#s-sec_p_11_3" rel="subsection" title="11.3.3 Programa ejemplo_11_3.f90">
<link href="ch-clase_11.html#s-sec_p_11_4" rel="subsection" title="11.3.4 Programa ejemplo_11_4.f90">
<link href="ch-clase_blaslap.html#s-sec_p_bl_1" rel="subsection" title="12.3.1 Ejemplo de fichero make.inc para LAPACK">
<link href="ch-clase_blaslap.html#s-sec_p_bl_2" rel="subsection" title="12.3.2 Ejemplo de fichero make.inc para LAPACK95">
<link href="ch-clase_blaslap.html#s-sec_p_bl_3" rel="subsection" title="12.3.3 Ejemplo de programa que invoca LAPACK95">
<link href="ch-clase_blaslap.html#s-sec_p_bl_4" rel="subsection" title="12.3.4 Ejemplo de makefile para compilar programas que invocan LAPACK95">

</head>

<body>

<p><a name="ch-clase_9"></a></p>
<hr>

<p>
[ <a href="ch-clase_8.html">previous</a> ]
[ <a href="index.html#contents">Contents</a> ]
[ <a href="ch-clase_1.html">1</a> ]
[ <a href="ch-clase_2.html">2</a> ]
[ <a href="ch-clase_3.html">3</a> ]
[ <a href="ch-clase_4.html">4</a> ]
[ <a href="ch-clase_7.html">5</a> ]
[ <a href="ch-clase_5.html">6</a> ]
[ <a href="ch-clase_6.html">7</a> ]
[ <a href="ch-clase_8.html">8</a> ]
[ 9 ]
[ <a href="ch-clase_10.html">10</a> ]
[ <a href="ch-clase_11.html">11</a> ]
[ <a href="ch-clase_blaslap.html">12</a> ]
[ <a href="ch-cap_ref.html">13</a> ]
[ <a href="ch-clase_10.html">next</a> ]
</p>

<hr>

<h1>
<code>Fortran 90</code> Lessons for Computational Chemistry
<br>Chapter 9 - Subprograms (II): subroutines
</h1>

<hr>

<h2 id="s-sec_91">9.1 Objectives</h2>

<p>
The main aims of this session consist of:
</p>
<ol type="1" start="1" >
<li>
<p>
considering the differences between functions and subroutines and in what cases
are the latter useful.
</p>
</li>
</ol>
<ol type="1" start="2" >
<li>
<p>
introducing the user to the subroutine definition procedures.
</p>
</li>
</ol>
<ol type="1" start="3" >
<li>
<p>
explaining subroutine arguments roles.
</p>
</li>
</ol>
<ol type="1" start="4" >
<li>
<p>
defining the commands <samp>CALL</samp> and <samp>INTERFACE</samp>.
</p>
</li>
</ol>
<ol type="1" start="5" >
<li>
<p>
explaining the <em>scope</em> of the variables of a subroutine and the role of
local variables and of variables with the <samp>SAVE</samp> attribute.
</p>
</li>
</ol>
<ol type="1" start="6" >
<li>
<p>
presenting the different ways of passing an array as an argument to a
subroutine.
</p>
</li>
</ol>
<ol type="1" start="7" >
<li>
<p>
defining the so called automatic arrays.
</p>
</li>
</ol>

<hr>

<h2 id="s-sec_92">9.2 Main items.</h2>
<ol type="1" start="1" >
<li>
<p>
The use of subroutines favors a structured programming through the definition
of subtasks and avoiding code duplication.  Together with functions, they make
possible to access to an extense collection of libraries for multiple
applications.
</p>
</li>
</ol>
<ol type="1" start="2" >
<li>
<p>
To better explain this point we will make use of a simple example: solving a
second order equation.  A possible way of dividing this task in simpler
subtasks is as follows
</p>
<ol type="1" start="1" >
<li>
<p>
Main program.
</p>
</li>
</ol>
<ol type="1" start="2" >
<li>
<p>
Equation coefficient input.
</p>
</li>
</ol>
<ol type="1" start="3" >
<li>
<p>
Solution of the algebraic equation.
</p>
</li>
</ol>
<ol type="1" start="4" >
<li>
<p>
Solution output.
</p>
</li>
</ol>

<p>
The program <a href="#s-sec_p_9_1"><samp>excode_9_1.f90</samp>, Section
9.3.1</a> follows closely this scheme with two subroutines:
<samp>Interact</samp> and <samp>Solve</samp>.
</p>
</li>
</ol>
<ol type="1" start="3" >
<li>
<p>
The syntax to define a subroutine is as follows
</p>

<pre>
       SUBROUTINE <var>subroutine_name</var>(arguments [optional])
              IMPLICIT NONE
              Arguments (dummy variables) definition (INTENT)
              ...
              Local variables definition
              ...
              Execution Section
              ...
              [RETURN]
      END SUBROUTINE  <var>subroutine_name</var>
</pre>

<p>
Argumentos are called <em>dummy</em> because their definition is not followed
by a memory assignment, this assignment will take place once the subroutine is
called.
</p>

<p>
Each subroutine is compiled in a separate way by the compiler, what allows for
the use of <em>local variables</em> that may have the same name in different
subroutines and the main program without clashing due to the different scopes.
</p>

<p>
This scheme can be seen in program <a
href="#s-sec_p_9_1"><samp>excode_9_1.f90</samp>, Section 9.3.1</a>.
</p>
</li>
</ol>
<ol type="1" start="4" >
<li>
<p>
A subroutine is invoked with the <samp>CALL</samp> command as follows
</p>

<pre>
     CALL subroutine_name(arguments [optional])
</pre>

<p>
Once the subroutine is executed the program flow returns to the program unit
where the subroutine was invoked, after the <samp>CALL</samp> statement.  The
subroutine determines when to return to the invoking unit once the
<samp>RETURN</samp> statement is found or if the subroutine execution ends.
</p>
</li>
</ol>
<ol type="1" start="5" >
<li>
<p>
The subroutine and the main program data flow takes place through the
arguments, also called subroutine parameters.  Arguments in the subroutine
definition are <em>dummy</em> variables, with an associated type but no space
reserved in memory.  For example, the <samp>E</samp>, <samp>F</samp>, and
<samp>G</samp> arguments in the <samp>Solve</samp> subroutine in the code <a
href="#s-sec_p_9_1"><samp>excode_9_1.f90</samp>, Section 9.3.1</a> are of
<samp>REAL</samp> type, but without any memory allocation.  Only when the
subroutine is invoked with the <samp>CALL Solve(P,Q,R,Root1,Root2,IFail)</samp>
command the arguments <samp>E</samp>, <samp>F</samp>, and <samp>G</samp> are
replaced by pointers to the main program variables <samp>P</samp>,
<samp>Q</samp>, and <samp>R</samp>.  This is why it is of great importance that
the data type of variables and arguments match correctly.
</p>
</li>
</ol>
<ol type="1" start="6" >
<li>
<p>
Some of the arguments provide the necessary input for the subroutine, while
others are output arguments that send the subroutine results to the invoking
program unit.  Mixed character input/output arguments can also be used.
</p>

<p>
Those parameters that are only input parameters should be defined using the
<samp>INTENT(IN)</samp> attribute that, as it is the case with functions,
indicate that the argument values cannot be altered in the subroutine.
</p>

<p>
If the parameters are output, the arguments should be defined with the
<samp>INTENT(OUT)</samp> attribute, to avoid taking into account the input
value of the argument.
</p>

<p>
Mixed character arguments should be defined with the <samp>INTENT(INOUT)</samp>
attribute.
</p>

<p>
The subroutine <samp>Solve</samp> in example <a
href="#s-sec_p_9_1"><samp>excode_9_1.f90</samp>, Section 9.3.1</a> provides
examples for the three cases.  It is advisable to label with the corresponding
<samp>INTENT</samp> attribute every argument.
</p>
</li>
</ol>
<ol type="1" start="7" >
<li>
<p>
In order to facilitate the accordance between variables in the invoking program
unit and the subroutine the user can defined the so called <em>interface
blocks</em>.  The example <a href="#s-sec_p_9_2"><samp>excode_9_2.f90</samp>,
Section 9.3.2</a> is the same code than <a
href="#s-sec_p_9_1"><samp>excode_9_1.f90</samp>, Section 9.3.1</a> to which
interface blocks have been added for the <samp>Interact</samp> and
<samp>Solve</samp> subroutines.
</p>
</li>
</ol>
<ol type="1" start="8" >
<li>
<p>
As in the case of functions, those variables defined in a subroutine that are
not arguments are considered as local variables.  For example, the
<samp>Interact</samp> subroutine in <a
href="#s-sec_p_9_1"><samp>excode_9_1.f90</samp>, Section 9.3.1</a> has a local
variable called <samp>IO_Status</samp>.
</p>

<p>
In general the local variables are created once the subroutine is called and
the value is lost unless they possess the <samp>SAVE</samp> attribute, that
makes possible to store the variable value from one call to the next.  For
example
</p>

<pre>
     INTEGER, SAVE:: It = 0
</pre>

<p>
The variable <samp>It</samp> value is kept among different calls to the
subroutine.
</p>

<p>
As it is the case for functions, it is possible that the subprogram has access
to the main program variables making use of the <samp>CONTAINS</samp>
statement.  This solution can be hard to scale once programs acquire certain
size and it is not very advisable.
</p>
</li>
</ol>
<ol type="1" start="9" >
<li>
<p>
When the argument of a subroutine is of <em>array</em> type it is necessary to
provide some extra information about the matrix to avoid the possible access of
the subroutine to wrong memory areas.  In order to achieve this there are three
possible ways of specifying the dimensiones of an array included in a
subroutine list of arguments.
</p>
<ol type="1" start="1" >
<li>
<p>
<em>explicit-shape approach</em>:
</p>

<p>
In this case the dimensions of the matrices are included as arguments in the
subroutine call and the matrices are declared making use of these arguments.
For example, if in a subroutine called <samp>test_pass</samp> an input vector
(<samp>space_vec_in</samp>) and an output vector (<samp>space_vec_out</samp>)
with equal dimensions are used, if we make use of the <em>explicit-shape
approach</em> the subroutine starts as follows
</p>

<pre>
     SUBROUTINE test_pass(space_vec_in, space_vec_out, dim_vec)
              IMPLICIT NONE
              INTEGER, INTENT(IN) :: dim_vec
              REAL, INTENT(IN), DIMENSION(1:dim_vec) :: space_vec_in
              REAL, INTENT(OUT), DIMENSION(1:dim_vec) :: space_vec_out
              ......
      END SUBROUTINE test_pass
</pre>
</li>
</ol>
<ol type="1" start="2" >
<li>
<p>
<em>assumed-shape approach</em>:
</p>

<p>
The main difference with the previous case is that either the corresponding
<samp>INTERFACE</samp> block is added or, as explained in <a
href="ch-clase_10.html">Subprograms (III): modules, Chapter 10</a>, the
subroutine is embedded in a module.
</p>

<p>
The example code <a href="#s-sec_p_9_3"><samp>excode_9_3.f90</samp>, Section
9.3.3</a> calculates the mean, the median[<a href="footnotes.html#f11"
name="fr11">11</a>], the variance and the standard deviation of a set of random
numbers following a continuous uniform distribution.  Several points of
interest has been marked in the program.
</p>
<ul>
<li>
<p>
<em>(1-3)</em> Dynamic memory storage using the <samp>ALLOCATABLE</samp>
attribute and the <samp>ALLOCATE</samp> statement.  Notice that the array is a
vector (<samp>DIMENSION(:)</samp>) and this piece of info needs to be also
include in the <em>interface block</em>.  The use of the <em>interface
block</em> in cases like this one is mandatory.  The statement <em>(3)</em>,
<samp>ALLOCATE(X(1:N), STAT = IERR)</samp> defines the length of the
<samp>X</samp> vector.  We also use the optional field <samp>STAT</samp> to
check whether the array has been correctly dimensioned or not.  Only if the
output of this field, in the <samp>IERR</samp> variable, is zero the dynamic
allocation has worked flawlessly.
</p>

<pre>
       REAL , ALLOCATABLE , DIMENSION(:) :: X  !! (1)
     
       ...
     
       INTERFACE
          SUBROUTINE STATS(X,N,MEAN,STD_DEV,MEDIAN)
            IMPLICIT NONE
     
            ...
     
            REAL      , INTENT(IN) , DIMENSION(:)   ::    X  !!  (1)
     
            ...
     
          END SUBROUTINE STATS
       END INTERFACE
</pre>

<p>
It is important to take into account that an argument of a subroutine can have
the <samp>ALLOCATABLE</samp> attribute, as well as local subroutine variables,
but not <em>dummy</em> variables.
</p>

<p>
The <em>assumed shape arguments</em> are nonexistent in <code>FORTRAN
77</code>, and it is the recommended form of transmitting arguments between a
main program and a subprogram.  In this form there is no transmitted
information about the dimension of the array, and the argument and the main
program variable need to have equal type, range, and class (<samp>KIND</samp>).
</p>
</li>
</ul>
<ul>
<li>
<p>
<em>(4)</em> and <em>(6)</em>: these statements take advantage of the
<code>Fortran 90</code> rules to work with vector and arrays.
</p>
</li>
</ul>
<ul>
<li>
<p>
<em>(5)</em> In this statement the allocated memory is revoked and freed using
the <samp>DEALLOCATE</samp> statement.  This is not mandatory in programs like
the present example, though it is necessary to do so when the allocatable array
has been defined in a function of subroutine without the <samp>SAVE</samp>
attribute.
</p>
</li>
</ul>
<ul>
<li>
<p>
<em>(7)</em> The <samp>CONTAINS</samp> statement is used to make the sorting
subroutine <samp>SELECTION</samp> have access to the variables of the
<samp>STATS</samp> subroutine.  This is why in the <samp>SELECTION</samp>
subroutine with the sorting algorithm only local variables need to be defined.
</p>
</li>
</ul>

<p>
The definition of <samp>INTERFACE</samp> blocks is a task simplified making use
of modules, that are introduced in the next chapter.
</p>
</li>
</ol>
<ol type="1" start="3" >
<li>
<p>
<em>assumed-size approach</em>
</p>

<p>
This case is not advised due to the lack of info in the subroutine about the
matrix dimensiones.  This makes easy to make errors of difficult diagnose.  Its
use is not encouraged.
</p>
</li>
</ol>
</li>
</ol>
<ol type="1" start="10" >
<li>
<p>
Multidimensional arrays.  The source code <a
href="#s-sec_p_9_5"><samp>excode_9_5.f90</samp>, Section 9.3.5</a> is an
example of how to pass multidimensional arrays as arguments of a subroutine as
<em>assumed shape arrays</em>.  The user defines two arrays , <samp>A</samp>
and <samp>B</samp>, and the program computes the <samp>C</samp> array as the
matrix product <samp>A</samp> times <samp>B</samp>.  Then, the program computes
the transpose matrix of <samp>A</samp>.  The program makes use of the
<code>Fortran 90</code> functions <samp>MATMUL</samp> and
<samp>TRANSPOSE</samp>.
</p>
</li>
</ol>
<ol type="1" start="11" >
<li>
<p>
Subroutines can contain <em>automatic arrays</em>, that may depend on the
subroutine argument values.  These are local array that may not have the
<samp>SAVE</samp> attribute.  They are created when the subroutine is invoked
and destroyed when the execution flow leaves the subroutine.  It is preferable
to use <samp>ALLOCATABLE</samp> arrays.
</p>
</li>
</ol>
<ol type="1" start="12" >
<li>
<p>
An argument of <samp>CHARACTER</samp> type is also diffenrent in the sense that
if such argument is declared with a length <samp>LEN = *</samp>, once the
subroutine is called the variable length is the legth of the variable in the
call.
</p>

<p>
The code <a href="#s-sec_p_9_4"><samp>excode_9_4.f90</samp>, Section 9.3.4</a>
is a program to which a file name is given and the number of data pairs stored
in the file.  The program opens the file and reads the two-column dataset.
Notice that, due to the variable size of the <samp>CHARACTER</samp> variable,
the <em>interface block</em> is required.
</p>

<p>
The example <a href="#s-sec_p_9_6"><samp>excode_9_6.f90</samp>, Section
9.3.6</a> caluculate two pseudo random number vectors with a Gaussian or normal
distribution with a dimension defined by the user.  This is achieved with the
<em>Box-Mueller</em> method.
</p>

<p>
Two <samp>ALLOCATABLE</samp> arrays, <samp>X</samp> and <samp>Y</samp> are
difined and in the internal subroutine <samp>BOX_MULLER</samp> two vectors of
automatic type are defined: <samp>RANDOM_u</samp> and <samp>RANDOM_v</samp>.
</p>

<p>
The mean value, the median and the standard deviation are computed making use
of the <samp>STATS</samp> subroutine in the source code <a
href="#s-sec_p_9_3"><samp>excode_9_3.f90</samp>, Section 9.3.3</a>.  The
necessary <samp>INTERFACE</samp> block is included in the main program and the
subroutine should be compiled in a separate file.
</p>
</li>
</ol>
<ol type="1" start="13" >
<li>
<p>
It is important to take into account that when array arguments are used as
<em>assumed shape arguments</em> the first index of the variable in the
subroutine by default takes a value <samp>1</samp>, unless it is explicitly
indicated.  The example <a href="#s-sec_p_9_7"><samp>excode_9_7.f90</samp>,
Section 9.3.7</a> is a simple case where this initial value is indicated.  This
program cmputes the factorial of the integers in the range between
<samp>IMIN</samp> and <samp>IMAX</samp>, storing them in a real vector.  The
program can be compiled making <samp>IMIN = 1</samp> or <samp>IMIN = 0</samp>
with and without the definition of the initial index in the subroutine to check
the different outputs.
</p>
</li>
</ol>

<hr>

<h2 id="s-sec_93">9.3 Example Codes</h2>

<hr>

<h3 id="s-sec_p_9_1">9.3.1 <samp>excode_9_1.f90</samp></h3>

<pre>
     PROGRAM ex_9_1
       !
       IMPLICIT NONE
       ! Simple program with two subroutines.
       ! subroutine (1):: Interact :: Data input.
       ! subroutine (2):: Solve :: Solve second order Eq.
       !
       ! Variables
       REAL :: P, Q, R, Root1, Root2
       INTEGER :: IFail=0
       LOGICAL :: OK=.TRUE.
       !
       CALL Interact(P,Q,R,OK) ! Subrutina (1)
       !
       IF (OK) THEN
          !
          CALL Solve(P,Q,R,Root1,Root2,IFail) ! Subrutina (2)
          !
          IF (IFail == 1) THEN
             PRINT *,' Complex roots'
             PRINT *,' calculation aborted'
          ELSE
             PRINT *,' Roots are ',Root1,' ',Root2
          ENDIF
          !
       ELSE
          !
          PRINT*,' Error in data input program ends'
          !
       ENDIF
       !
     END PROGRAM ex_9_1
     !
     !
     SUBROUTINE Interact(A,B,C,OK)
       IMPLICIT NONE
       REAL , INTENT(OUT) :: A
       REAL , INTENT(OUT) :: B
       REAL , INTENT(OUT) :: C
       LOGICAL , INTENT(OUT) :: OK
       INTEGER :: IO_Status=0
       PRINT*,' Type in the coefficients A, B AND C'
       READ(UNIT=*,FMT=*,IOSTAT=IO_Status) A,B,C
       IF (IO_Status == 0) THEN
          OK=.TRUE.
       ELSE
          OK=.FALSE.
       ENDIF
     END SUBROUTINE Interact
     !
     !
     SUBROUTINE Solve(E,F,G,Root1,Root2,IFail)
       IMPLICIT NONE
       REAL , INTENT(IN) :: E
       REAL , INTENT(IN) :: F
       REAL , INTENT(IN) :: G
       REAL , INTENT(OUT) :: Root1
       REAL , INTENT(OUT) :: Root2
       INTEGER , INTENT(INOUT) :: IFail
       ! Local variables
       REAL :: Term
       REAL :: A2
       Term = F*F - 4.*E*G
       A2 = E*2.0
       ! if term &lt; 0, roots are complex
       IF(Term &lt; 0.0)THEN
          IFail=1
       ELSE
          Term = SQRT(Term)
          Root1 = (-F+Term)/A2
          Root2 = (-F-Term)/A2
       ENDIF
     END SUBROUTINE Solve
</pre>

<hr>

<h3 id="s-sec_p_9_2">9.3.2 <samp>excode_9_2.f90</samp></h3>

<pre>
     PROGRAM ex_9_2
       !
       IMPLICIT NONE
       ! Simple program with two subroutines.
       ! subroutine (1):: Interact :: Data input.
       ! subroutine (2):: Solve :: Solve second order Eq.
       !
       ! Interface blocks
       INTERFACE
          SUBROUTINE Interact(A,B,C,OK)
            IMPLICIT NONE
            REAL , INTENT(OUT) ::  A
            REAL , INTENT(OUT) ::  B
            REAL , INTENT(OUT) ::  C
            LOGICAL , INTENT(OUT) :: OK
          END SUBROUTINE Interact
          SUBROUTINE Solve(E,F,G,Root1,Root2,IFail)
            IMPLICIT NONE
            REAL , INTENT(IN) :: E
            REAL , INTENT(IN) :: F
            REAL , INTENT(IN) :: G
            REAL , INTENT(OUT) :: Root1
            REAL , INTENT(OUT) :: Root2
            INTEGER , INTENT(INOUT) :: IFail
          END SUBROUTINE Solve
       END INTERFACE
       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       !
       ! Variables
       REAL :: P, Q, R, Root1, Root2
       INTEGER :: IFail=0
       LOGICAL :: OK=.TRUE.
       !
       CALL Interact(P,Q,R,OK) ! Subrutina (1)
       !
       IF (OK) THEN
          !
          CALL Solve(P,Q,R,Root1,Root2,IFail) ! Subrutina (2)
          !
          IF (IFail == 1) THEN
             PRINT *,' Complex roots'
             PRINT *,' calculation aborted'
          ELSE
             PRINT *,' Roots are ',Root1,' ',Root2
          ENDIF
          !
       ELSE
          !
          PRINT*,' Error in data input program ends'
          !
       ENDIF
       !
     END PROGRAM ex_9_2
     !
     !
     SUBROUTINE Interact(A,B,C,OK)
       IMPLICIT NONE
       REAL , INTENT(OUT) :: A
       REAL , INTENT(OUT) :: B
       REAL , INTENT(OUT) :: C
       LOGICAL , INTENT(OUT) :: OK
       INTEGER :: IO_Status=0
       PRINT*,' Type in the coefficients A, B AND C'
       READ(UNIT=*,FMT=*,IOSTAT=IO_Status)A,B,C
       IF (IO_Status == 0) THEN
          OK=.TRUE.
       ELSE
          OK=.FALSE.
       ENDIF
     END SUBROUTINE Interact
     !
     !
     SUBROUTINE Solve(E,F,G,Root1,Root2,IFail)
       IMPLICIT NONE
       REAL , INTENT(IN) :: E
       REAL , INTENT(IN) :: F
       REAL , INTENT(IN) :: G
       REAL , INTENT(OUT) :: Root1
       REAL , INTENT(OUT) :: Root2
       INTEGER , INTENT(INOUT) :: IFail
       ! Local variables
       REAL :: Term
       REAL :: A2
       Term = F*F - 4.*E*G
       A2 = E*2.0
       ! if term &lt; 0, roots are complex
       IF(Term &lt; 0.0)THEN
          IFail=1
       ELSE
          Term = SQRT(Term)
          Root1 = (-F+Term)/A2
          Root2 = (-F-Term)/A2
       ENDIF
     END SUBROUTINE Solve
</pre>

<hr>

<h3 id="s-sec_p_9_3">9.3.3 <samp>excode_9_3.f90</samp></h3>

<pre>
     PROGRAM ex_9_3
       !
       IMPLICIT NONE
       !
       ! Variables
       INTEGER :: N
       REAL , ALLOCATABLE , DIMENSION(:) :: X  !! (1)
       REAL :: M,SD,MEDIAN
       INTEGER :: IERR
       !
       ! interface block   !! (2)
       INTERFACE
          SUBROUTINE STATS(VECTOR,N,MEAN,STD_DEV,MEDIAN)
            IMPLICIT NONE
            INTEGER , INTENT(IN)                    ::  N
            REAL      , INTENT(IN) , DIMENSION(:)   :: VECTOR  !!  (1)
            REAL      , INTENT(OUT)                 :: MEAN
            REAL      , INTENT(OUT)                 :: STD_DEV
            REAL      , INTENT(OUT)                 :: MEDIAN
          END SUBROUTINE STATS
       END INTERFACE
       PRINT *,' Length of random values vector ?'
       READ *,N
       ALLOCATE(X(1:N), STAT = IERR)     !!  (3)
       IF (IERR /= 0) THEN
          PRINT*, &quot;X allocation request denied.&quot;
          STOP
       ENDIF
       CALL RANDOM_NUMBER(X)
       X=X*1000             !!  (4)
       CALL STATS(X,N,M,SD,MEDIAN)
       !
       PRINT *,' MEAN = ',M
       PRINT *,' STANDARD DEVIATION = ',SD
       PRINT *,' MEDIAN IS = ',MEDIAN
       !
       IF (ALLOCATED(X)) DEALLOCATE(X, STAT = IERR)   !! (5)
       IF (IERR /= 0) THEN
          PRINT*, &quot;X NON DEALLOCATED!&quot;
          STOP
       ENDIF
     END PROGRAM ex_9_3
     !
     SUBROUTINE STATS(VECTOR,N,MEAN,STD_DEV,MEDIAN)
       IMPLICIT NONE
       ! Defincion de variables
       INTEGER , INTENT(IN)                    ::  N
       REAL      , INTENT(IN) , DIMENSION(:)    ::  VECTOR    !! (1)
       REAL      , INTENT(OUT)                  ::  MEAN
       REAL      , INTENT(OUT)                  ::  STD_DEV
       REAL      , INTENT(OUT)                  ::  MEDIAN
       REAL      , DIMENSION(1:N)              ::  Y
       REAL :: VARIANCE = 0.0
       REAL      :: SUMXI = 0.0, SUMXI2 = 0.0
       !
       SUMXI=SUM(VECTOR)       !! (6)
       SUMXI2=SUM(VECTOR*VECTOR)    !! (6)
       MEAN=SUMXI/N       
       VARIANCE=(SUMXI2-SUMXI*SUMXI/N)/(N-1)
       STD_DEV = SQRT(VARIANCE)
       Y=VECTOR
       ! Ordena valores por proceso de seleccion
       CALL SELECTION
       IF (MOD(N,2) == 0) THEN
          MEDIAN=(Y(N/2)+Y((N/2)+1))/2
       ELSE
          MEDIAN=Y((N/2)+1)
       ENDIF
     CONTAINS     !! (7)
       SUBROUTINE SELECTION
         IMPLICIT NONE
         INTEGER :: I,J,K
         REAL :: MINIMUM
         DO I=1,N-1
            K=I
            MINIMUM=Y(I)
            DO J=I+1,N
               IF (Y(J) &lt; MINIMUM) THEN
                  K=J
                  MINIMUM=Y(K)
               END IF
            END DO
            Y(K)=Y(I)
            Y(I)=MINIMUM
         END DO
       END SUBROUTINE SELECTION
     END SUBROUTINE STATS
</pre>

<hr>

<h3 id="s-sec_p_9_4">9.3.4 <samp>excode_9_4.f90</samp></h3>

<pre>
     PROGRAM ex_9_4
       IMPLICIT NONE
       REAL,DIMENSION(1:100)::A,B
       INTEGER :: Nos,I
       CHARACTER(LEN=32)::Filename
       INTERFACE
          SUBROUTINE Readin(Name,X,Y,N)
            IMPLICIT NONE
            INTEGER , INTENT(IN) :: N
            REAL,DIMENSION(1:N),INTENT(OUT)::X,Y
            CHARACTER (LEN=*),INTENT(IN)::Name
          END SUBROUTINE Readin
       END INTERFACE
       PRINT *,' Type in the name of the data file'
       READ '(A)' , Filename
       PRINT *,' Input the number of items in the file'
       READ * , Nos
       CALL Readin(Filename,A,B,Nos)
       PRINT * , ' Data read in was'
       DO I=1,Nos
          PRINT *,' ',A(I),' ',B(I)
       ENDDO
     END PROGRAM ex_9_4
     SUBROUTINE Readin(Name,X,Y,N)
       IMPLICIT NONE
       INTEGER , INTENT(IN) :: N
       REAL,DIMENSION(1:N),INTENT(OUT)::X,Y
       CHARACTER (LEN=*),INTENT(IN)::Name
       INTEGER::I
       OPEN(UNIT=10,STATUS='OLD',FILE=Name)
       DO I=1,N
          READ(10,*)X(I),Y(I)
       END DO
       CLOSE(UNIT=10)
     END SUBROUTINE Readin
</pre>

<hr>

<h3 id="s-sec_p_9_5">9.3.5 <samp>excode_9_5.f90</samp></h3>

<pre>
     PROGRAM ex_9_5
       IMPLICIT NONE
       REAL , ALLOCATABLE , DIMENSION &amp;
            (:,:)::One,Two,Three,One_T
       INTEGER :: I,N
       INTERFACE
          SUBROUTINE Matrix_bits(A,B,C,A_T)
            IMPLICIT NONE
            REAL, DIMENSION (:,:), INTENT(IN) :: A,B
            REAL, DIMENSION (:,:), INTENT(OUT) :: C,A_T
          END SUBROUTINE Matrix_bits
       END INTERFACE
       PRINT *,'Matrix Dimension?'
       READ*,N
       ALLOCATE(One(1:N,1:N))
       ALLOCATE(Two(1:N,1:N))
       ALLOCATE(Three(1:N,1:N))
       ALLOCATE(One_T(1:N,1:N))
       DO I=1,N
          PRINT*, 'Row ', I,'-th of the first array?'
          READ*,One(I,1:N)
       END DO
       DO I=1,N
          PRINT*, 'Row ', I,'-th of the second array?'
          READ*,Two(I,1:N)
       END DO
       CALL Matrix_bits(One,Two,Three,One_T)
       PRINT*,' Result: Matrix Product'
       DO I=1,N
          PRINT *,Three(I,1:N)
       END DO
       PRINT *,' Transpose A^T:'
       DO I=1,N
          PRINT *,One_T(I,1:N)
       END DO
     END PROGRAM ex_9_5
     !
     SUBROUTINE Matrix_bits(A,B,C,A_T)
       IMPLICIT NONE
       REAL, DIMENSION (:,:), INTENT(IN) :: A,B
       REAL, DIMENSION (:,:), INTENT(OUT) :: C,A_T
       C=MATMUL(A,B)
       A_T=TRANSPOSE(A)
     END SUBROUTINE Matrix_bits
</pre>

<hr>

<h3 id="s-sec_p_9_6">9.3.6 <samp>excode_9_6.f90</samp></h3>

<pre>
     PROGRAM ex_9_6
       !
       IMPLICIT NONE
       !
       INTEGER :: I, IERR
       REAL, DIMENSION(:), ALLOCATABLE :: X, Y
       REAL :: M, SD, MEDIAN
       ! interface block   
       INTERFACE
          SUBROUTINE STATS(VECTOR,N,MEAN,STD_DEV,MEDIAN)
            IMPLICIT NONE
            INTEGER , INTENT(IN)                    ::  N
            REAL      , INTENT(IN) , DIMENSION(:)   :: VECTOR  
            REAL      , INTENT(OUT)                 :: MEAN
            REAL      , INTENT(OUT)                 :: STD_DEV
            REAL      , INTENT(OUT)                 :: MEDIAN
          END SUBROUTINE STATS
       END INTERFACE
       !
       READ*, I  
       !
       ALLOCATE(X(1:I), STAT = IERR)    
       IF (IERR /= 0) THEN
          PRINT*, &quot;X allocation request denied.&quot;
          STOP
       ENDIF
       !
       ALLOCATE(Y(1:I), STAT = IERR)    
       IF (IERR /= 0) THEN
          PRINT*, &quot;Y allocation request denied.&quot;
          STOP
       ENDIF
       !
       CALL BOX_MULLER(I)
       !
       PRINT*, X
       CALL STATS(X,I,M,SD,MEDIAN)
       !
       PRINT *,' MEAN = ',M
       PRINT *,' STANDARD DEVIATION = ',SD
       PRINT *,' MEDIAN IS = ',MEDIAN
       !
       IF (ALLOCATED(X)) DEALLOCATE(X, STAT = IERR) 
       IF (IERR /= 0) THEN
          PRINT*, &quot;X NON DEALLOCATED!&quot;
          STOP
       ENDIF
       PRINT*, Y
       CALL STATS(Y,I,M,SD,MEDIAN)
       !
       PRINT *,' MEAN = ',M
       PRINT *,' STANDARD DEVIATION = ',SD
       PRINT *,' MEDIAN IS = ',MEDIAN
       !
       IF (ALLOCATED(Y)) DEALLOCATE(Y, STAT = IERR)   
       IF (IERR /= 0) THEN
          PRINT*, &quot;Y NON DEALLOCATED!&quot;
          STOP
       ENDIF
       !
     CONTAINS
       !
       SUBROUTINE BOX_MULLER(dim)
         ! 
         ! Uses the Box-Muller method to create two normally distributed vectors
         !
         INTEGER, INTENT(IN) :: dim
         !
         REAL, PARAMETER :: PI = ACOS(-1.0)
         REAL, DIMENSION(dim) :: RANDOM_u, RANDOM_v ! Automatic arrays
         !
         CALL RANDOM_NUMBER(RANDOM_u)
         CALL RANDOM_NUMBER(RANDOM_v)
         !
         X = SQRT(-2.0*LOG(RANDOM_u))
         Y = X*SIN(2*PI*RANDOM_v)
         X = X*COS(2*PI*RANDOM_v)
         !
       END SUBROUTINE BOX_MULLER
       !
     END PROGRAM ex_9_6
     !!!!!!!!!!!!!!!!!!!!!!!!!
     !!!!!!!!!!!!!!!!!!!!!!!!!
     SUBROUTINE STATS(VECTOR,N,MEAN,STD_DEV,MEDIAN)
       IMPLICIT NONE
       ! Arguments
       INTEGER , INTENT(IN)                    ::  N
       REAL      , INTENT(IN) , DIMENSION(:)    ::  VECTOR    !! (1)
       REAL      , INTENT(OUT)                  ::  MEAN
       REAL      , INTENT(OUT)                  ::  STD_DEV
       REAL      , INTENT(OUT)                  ::  MEDIAN
       ! Local Variables
       REAL      , DIMENSION(1:N)              ::  Y
       REAL      :: VARIANCE = 0.0
       REAL      :: SUMXI = 0.0, SUMXI2 = 0.0
       !
       SUMXI=SUM(VECTOR)       !! (6)
       SUMXI2=SUM(VECTOR*VECTOR)    !! (6)
       MEAN=SUMXI/N       
       VARIANCE=(SUMXI2-SUMXI*SUMXI/N)/(N-1)
       STD_DEV = SQRT(VARIANCE)
       Y=VECTOR
       ! Sort values
       CALL SELECTION
       IF (MOD(N,2) == 0) THEN
          MEDIAN=(Y(N/2)+Y((N/2)+1))/2
       ELSE
          MEDIAN=Y((N/2)+1)
       ENDIF
     CONTAINS     !! (7)
       SUBROUTINE SELECTION
         IMPLICIT NONE
         INTEGER :: I,J,K
         REAL :: MINIMUM
         DO I=1,N-1
            K=I
            MINIMUM=Y(I)
            DO J=I+1,N
               IF (Y(J) &lt; MINIMUM) THEN
                  K=J
                  MINIMUM=Y(K)
               END IF
            END DO
            Y(K)=Y(I)
            Y(I)=MINIMUM
         END DO
       END SUBROUTINE SELECTION
     END SUBROUTINE STATS
</pre>

<hr>

<h3 id="s-sec_p_9_7">9.3.7 <samp>excode_9_7.f90</samp></h3>

<pre>
     PROGRAM ex_9_7
       !
       IMPLICIT NONE
       !
       INTERFACE
          SUBROUTINE SUBEXAMPLE(IMIN, IMAX, FACT_MAT)
            INTEGER, intent(in) :: IMIN, IMAX
            REAL, DIMENSION(IMIN:), intent(out) :: FACT_MAT
          END SUBROUTINE SUBEXAMPLE
       END INTERFACE
       !
       ! Variables
       REAL, DIMENSION(:), ALLOCATABLE :: FACT_MAT
       INTEGER :: IMIN, IMAX, I
       !
       IMIN = 0
       IMAX = 5
       !
       ALLOCATE(FACT_MAT(IMIN:IMAX))
       !
       PRINT*, &quot;MAIN&quot;, SIZE(FACT_MAT)
       !
       CALL SUBEXAMPLE(IMIN, IMAX, FACT_MAT)
       !
       DO I = IMIN, IMAX
          PRINT*, I, FACT_MAT(I)
       ENDDO
       !
     END PROGRAM ex_9_7
     !!!!!!!!!!
     !!!!!!!!!!
     SUBROUTINE SUBEXAMPLE(IMIN, IMAX, FACT_MAT)
       !
       IMPLICIT NONE
       INTEGER, intent(in) :: IMIN, IMAX
       REAL, DIMENSION(IMIN:), intent(out) :: FACT_MAT
       ! The subroutine with the next line only would work for IMIN = 1
       !  REAL, DIMENSION(:), intent(out) :: FACT_MAT
       !
       INTEGER :: j,k
       !
       PRINT*, &quot;SUB&quot;, SIZE(FACT_MAT)
       !
       DO j = imin, imax
          fact_mat(j) = 1.0
          do k = 2, j
             fact_mat(j) = k*fact_mat(j)
          enddo
       ENDDO
       !
       !
     END SUBROUTINE SUBEXAMPLE
</pre>

<hr>

<p>
[ <a href="ch-clase_8.html">previous</a> ]
[ <a href="index.html#contents">Contents</a> ]
[ <a href="ch-clase_1.html">1</a> ]
[ <a href="ch-clase_2.html">2</a> ]
[ <a href="ch-clase_3.html">3</a> ]
[ <a href="ch-clase_4.html">4</a> ]
[ <a href="ch-clase_7.html">5</a> ]
[ <a href="ch-clase_5.html">6</a> ]
[ <a href="ch-clase_6.html">7</a> ]
[ <a href="ch-clase_8.html">8</a> ]
[ 9 ]
[ <a href="ch-clase_10.html">10</a> ]
[ <a href="ch-clase_11.html">11</a> ]
[ <a href="ch-clase_blaslap.html">12</a> ]
[ <a href="ch-cap_ref.html">13</a> ]
[ <a href="ch-clase_10.html">next</a> ]
</p>

<hr>

<p>
<code>Fortran 90</code> Lessons for Computational Chemistry
</p>

<address>
0.0<br>
<br>
Curro Pérez-Bernal <code><a href="mailto:francisco.perez@dfaie.uhu.es">mailto:francisco.perez@dfaie.uhu.es</a></code><br>
<br>
</address>
<hr>

</body>

</html>

